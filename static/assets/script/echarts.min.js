! function(t, e) {
	"object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define
		.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).echarts = {})
}(this, function(t) {
	"use strict";
	var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	// An highlighted block
	function Pe(t, e, n, i) {
		if (isDomLevel2) {
			t.addEventListener(e, n, i)
		} else {
			t.attachEvent('on' + e, n)
		}
	}

	function Le(t, e, n, i) {
		if (isDomLevel2) {
			t.removeEventListener(e, n, i)
		} else {
			t.detachEvent('on' + e, n)
		}
	}
	var m = function(t, e) {
		return (m = Object.setPrototypeOf || ({
				__proto__: []
			}
			instanceof Array ? function(t, e) {
				t.__proto__ = e
			} : function(t, e) {
				for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
			}))(t, e)
	};

	function u(t, e) {
		if ("function" != typeof e && null !== e) throw new TypeError("Class extends value " + String(e) +
			" is not a constructor or null");

		function n() {
			this.constructor = t
		}
		m(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n)
	}

	function v() {
		this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1
	}
	var b = new function() {
		this.browser = new v, this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this
			.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this
			.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = "undefined" !=
			typeof window
	};
	"object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? (b.wxa = !0, b.touchEventsSupported = !0) :
		"undefined" == typeof document && "undefined" != typeof self ? b.worker = !0 : "undefined" ==
		typeof navigator ? (b.node = !0, b.svgSupported = !0) : (et = navigator.userAgent, ae = (Gt = b).browser,
			at = et.match(/Firefox\/([\d.]+)/), q = et.match(/MSIE\s([\d.]+)/) || et.match(
				/Trident\/.+?rv:(([\d.]+))/), tt = et.match(/Edge?\/([\d.]+)/), et = /micromessenger/i.test(et),
			at && (ae.firefox = !0, ae.version = at[1]), q && (ae.ie = !0, ae.version = q[1]), tt && (ae.edge = !0,
				ae.version = tt[1], ae.newEdge = 18 < +tt[1].split(".")[0]), et && (ae.weChat = !0), Gt
			.svgSupported = "undefined" != typeof SVGRect, Gt.touchEventsSupported = "ontouchstart" in window && !ae
			.ie && !ae.edge, Gt.pointerEventsSupported = "onpointerdown" in window && (ae.edge || ae.ie && 11 <= +ae
				.version), Gt.domSupported = "undefined" != typeof document, at = document.documentElement.style, Gt
			.transform3dSupported = (ae.ie && "transition" in at || ae.edge || "WebKitCSSMatrix" in window &&
				"m11" in new WebKitCSSMatrix || "MozPerspective" in at) && !("OTransition" in at), Gt
			.transformSupported = Gt.transform3dSupported || ae.ie && 9 <= +ae.version);
	var x = 12,
		w = "sans-serif",
		K = x + "px " + w;
	var M, T, C = function(t) {
			var e = {};
			if ("undefined" != typeof JSON)
				for (var n = 0; n < t.length; n++) {
					var i = String.fromCharCode(n + 32),
						r = (t.charCodeAt(n) - 20) / 100;
					e[i] = r
				}
			return e
		}("007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N"),
		X = {
			createCanvas: function() {
				return "undefined" != typeof document && document.createElement("canvas")
			},
			measureText: function(t, e) {
				if (M || (n = X.createCanvas(), M = n && n.getContext("2d")), M) return T !== e && (T = M.font =
					e || K), M.measureText(t);
				t = t || "";
				var n = /(\d+)px/.exec(e = e || K),
					i = n && +n[1] || x,
					r = 0;
				if (0 <= e.indexOf("mono")) r = i * t.length;
				else
					for (var o = 0; o < t.length; o++) {
						var a = C[t[o]];
						r += null == a ? i : a * i
					}
				return {
					width: r
				}
			},
			loadImage: function(t, e, n) {
				var i = new Image;
				return i.onload = e, i.onerror = n, i.src = t, i
			}
		};

	function D(t) {
		for (var e in X) t[e] && (X[e] = t[e])
	}
	var A = ht(["Function", "RegExp", "Date", "Error", "CanvasGradient", "CanvasPattern", "Image", "Canvas"],
			function(t, e) {
				return t["[object " + e + "]"] = !0, t
			}, {}),
		P = ht(["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64"],
			function(t, e) {
				return t["[object " + e + "Array]"] = !0, t
			}, {}),
		Y = Object.prototype.toString,
		q = Array.prototype,
		j = q.forEach,
		$ = q.filter,
		Q = q.slice,
		J = q.map,
		tt = function() {}.constructor,
		et = tt ? tt.prototype : null,
		nt = "__proto__",
		it = 2311;

	function rt() {
		return it++
	}

	function ot() {
		for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
		"undefined" != typeof console && console.error.apply(console, t)
	}

	function _(t) {
		if (null == t || "object" != typeof t) return t;
		var e = t,
			n = Y.call(t);
		if ("[object Array]" === n) {
			if (!At(t))
				for (var e = [], i = 0, r = t.length; i < r; i++) e[i] = _(t[i])
		} else if (P[n]) {
			if (!At(t)) {
				var o = t.constructor;
				if (o.from) e = o.from(t);
				else
					for (e = new o(t.length), i = 0, r = t.length; i < r; i++) e[i] = t[i]
			}
		} else if (!A[n] && !At(t) && !mt(t))
			for (var a in e = {}, t) t.hasOwnProperty(a) && a !== nt && (e[a] = _(t[a]));
		return e
	}

	function d(t, e, n) {
		if (!L(e) || !L(t)) return n ? _(e) : t;
		for (var i in e) {
			var r, o;
			e.hasOwnProperty(i) && i !== nt && (r = t[i], !L(o = e[i]) || !L(r) || V(o) || V(r) || mt(o) || mt(r) ||
				gt(o) || gt(r) || At(o) || At(r) ? !n && i in t || (t[i] = _(e[i])) : d(r, o, n))
		}
		return t
	}

	function O(t, e) {
		if (Object.assign) Object.assign(t, e);
		else
			for (var n in e) e.hasOwnProperty(n) && n !== nt && (t[n] = e[n]);
		return t
	}

	function B(t, e, n) {
		for (var i = R(e), r = 0; r < i.length; r++) {
			var o = i[r];
			(n ? null != e[o] : null == t[o]) && (t[o] = e[o])
		}
		return t
	}
	var at = X.createCanvas;

	function I(t, e) {
		if (t) {
			if (t.indexOf) return t.indexOf(e);
			for (var n = 0, i = t.length; n < i; n++)
				if (t[n] === e) return n
		}
		return -1
	}

	function st(t, e) {
		var n, i = t.prototype;

		function r() {}
		for (n in r.prototype = e.prototype, t.prototype = new r, i) i.hasOwnProperty(n) && (t.prototype[n] = i[n]);
		(t.prototype.constructor = t).superClass = e
	}

	function lt(t, e, n) {
		if (t = "prototype" in t ? t.prototype : t, e = "prototype" in e ? e.prototype : e, Object
			.getOwnPropertyNames)
			for (var i = Object.getOwnPropertyNames(e), r = 0; r < i.length; r++) {
				var o = i[r];
				"constructor" !== o && (n ? null != e[o] : null == t[o]) && (t[o] = e[o])
			} else B(t, e, n)
	}

	function ut(t) {
		return !!t && "string" != typeof t && "number" == typeof t.length
	}

	function E(t, e, n) {
		if (t && e)
			if (t.forEach && t.forEach === j) t.forEach(e, n);
			else if (t.length === +t.length)
			for (var i = 0, r = t.length; i < r; i++) e.call(n, t[i], i, t);
		else
			for (var o in t) t.hasOwnProperty(o) && e.call(n, t[o], o, t)
	}

	function F(t, e, n) {
		if (!t) return [];
		if (!e) return Mt(t);
		if (t.map && t.map === J) return t.map(e, n);
		for (var i = [], r = 0, o = t.length; r < o; r++) i.push(e.call(n, t[r], r, t));
		return i
	}

	function ht(t, e, n, i) {
		if (t && e) {
			for (var r = 0, o = t.length; r < o; r++) n = e.call(i, n, t[r], r, t);
			return n
		}
	}

	function ct(t, e, n) {
		if (!t) return [];
		if (!e) return Mt(t);
		if (t.filter && t.filter === $) return t.filter(e, n);
		for (var i = [], r = 0, o = t.length; r < o; r++) e.call(n, t[r], r, t) && i.push(t[r]);
		return i
	}

	function R(t) {
		if (!t) return [];
		if (Object.keys) return Object.keys(t);
		var e, n = [];
		for (e in t) t.hasOwnProperty(e) && n.push(e);
		return n
	}
	var pt = et && S(et.bind) ? et.call.bind(et.bind) : function(t, e) {
		for (var n = [], i = 2; i < arguments.length; i++) n[i - 2] = arguments[i];
		return function() {
			return t.apply(e, n.concat(Q.call(arguments)))
		}
	};

	function dt(t) {
		for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
		return function() {
			return t.apply(this, e.concat(Q.call(arguments)))
		}
	}

	function V(t) {
		return Array.isArray ? Array.isArray(t) : "[object Array]" === Y.call(t)
	}

	function S(t) {
		return "function" == typeof t
	}

	function H(t) {
		return "string" == typeof t
	}

	function ft(t) {
		return "[object String]" === Y.call(t)
	}

	function G(t) {
		return "number" == typeof t
	}

	function L(t) {
		var e = typeof t;
		return "function" == e || !!t && "object" == e
	}

	function gt(t) {
		return !!A[Y.call(t)]
	}

	function yt(t) {
		return !!P[Y.call(t)]
	}

	function mt(t) {
		return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument
	}

	function vt(t) {
		return null != t.colorStops
	}

	function _t(t) {
		return null != t.image
	}

	function xt(t) {
		return "[object RegExp]" === Y.call(t)
	}

	function wt(t) {
		return t != t
	}

	function bt() {
		for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
		for (var n = 0, i = t.length; n < i; n++)
			if (null != t[n]) return t[n]
	}

	function N(t, e) {
		return null != t ? t : e
	}

	function St(t, e, n) {
		return null != t ? t : null != e ? e : n
	}

	function Mt(t) {
		for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
		return Q.apply(t, e)
	}

	function Tt(t) {
		var e;
		return "number" == typeof t ? [t, t, t, t] : 2 === (e = t.length) ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[
			0], t[1], t[2], t[1]] : t
	}

	function Ct(t, e) {
		if (!t) throw new Error(e)
	}

	function It(t) {
		return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(
			/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
	}
	var kt = "__ec_primitive__";

	function Dt(t) {
		t[kt] = !0
	}

	function At(t) {
		return t[kt]
	}
	Ot.prototype.delete = function(t) {
		var e = this.has(t);
		return e && delete this.data[t], e
	}, Ot.prototype.has = function(t) {
		return this.data.hasOwnProperty(t)
	}, Ot.prototype.get = function(t) {
		return this.data[t]
	}, Ot.prototype.set = function(t, e) {
		return this.data[t] = e, this
	}, Ot.prototype.keys = function() {
		return R(this.data)
	}, Ot.prototype.forEach = function(t) {
		var e, n = this.data;
		for (e in n) n.hasOwnProperty(e) && t(n[e], e)
	};
	var Pt = Ot,
		Lt = "function" == typeof Map;

	function Ot() {
		this.data = {}
	}
	Nt.prototype.hasKey = function(t) {
		return this.data.has(t)
	}, Nt.prototype.get = function(t) {
		return this.data.get(t)
	}, Nt.prototype.set = function(t, e) {
		return this.data.set(t, e), e
	}, Nt.prototype.each = function(n, i) {
		this.data.forEach(function(t, e) {
			n.call(i, t, e)
		})
	}, Nt.prototype.keys = function() {
		var t = this.data.keys();
		return Lt ? Array.from(t) : t
	}, Nt.prototype.removeKey = function(t) {
		this.data.delete(t)
	};
	var Rt = Nt;

	function Nt(t) {
		var n = V(t),
			i = (this.data = new(Lt ? Map : Pt), this);

		function e(t, e) {
			n ? i.set(t, e) : i.set(e, t)
		}
		t instanceof Nt ? t.each(e) : t && E(t, e)
	}

	function z(t) {
		return new Rt(t)
	}

	function Et(t, e) {
		for (var n = new t.constructor(t.length + e.length), i = 0; i < t.length; i++) n[i] = t[i];
		for (var r = t.length, i = 0; i < e.length; i++) n[i + r] = e[i];
		return n
	}

	function zt(t, e) {
		var n, t = Object.create ? Object.create(t) : ((n = function() {}).prototype = t, new n);
		return e && O(t, e), t
	}

	function Bt(t) {
		t = t.style;
		t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t[
			"-webkit-touch-callout"] = "none"
	}

	function Ft(t, e) {
		return t.hasOwnProperty(e)
	}

	function Vt() {}
	var Ht = 180 / Math.PI,
		Gt = Object.freeze({
			__proto__: null,
			HashMap: Rt,
			RADIAN_TO_DEGREE: Ht,
			assert: Ct,
			bind: pt,
			clone: _,
			concatArray: Et,
			createCanvas: at,
			createHashMap: z,
			createObject: zt,
			curry: dt,
			defaults: B,
			disableUserSelect: Bt,
			each: E,
			eqNaN: wt,
			extend: O,
			filter: ct,
			find: function(t, e, n) {
				if (t && e)
					for (var i = 0, r = t.length; i < r; i++)
						if (e.call(n, t[i], i, t)) return t[i]
			},
			guid: rt,
			hasOwn: Ft,
			indexOf: I,
			inherits: st,
			isArray: V,
			isArrayLike: ut,
			isBuiltInObject: gt,
			isDom: mt,
			isFunction: S,
			isGradientObject: vt,
			isImagePatternObject: _t,
			isNumber: G,
			isObject: L,
			isPrimitive: At,
			isRegExp: xt,
			isString: H,
			isStringSafe: ft,
			isTypedArray: yt,
			keys: R,
			logError: ot,
			map: F,
			merge: d,
			mergeAll: function(t, e) {
				for (var n = t[0], i = 1, r = t.length; i < r; i++) n = d(n, t[i], e);
				return n
			},
			mixin: lt,
			noop: Vt,
			normalizeCssArray: Tt,
			reduce: ht,
			retrieve: bt,
			retrieve2: N,
			retrieve3: St,
			setAsPrimitive: Dt,
			slice: Mt,
			trim: It
		});

	function Wt(t, e) {
		return [t = null == t ? 0 : t, e = null == e ? 0 : e]
	}

	function Ut(t) {
		return [t[0], t[1]]
	}

	function Xt(t, e, n) {
		return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t
	}

	function Yt(t, e, n) {
		return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t
	}

	function qt(t) {
		return Math.sqrt(jt(t))
	}

	function jt(t) {
		return t[0] * t[0] + t[1] * t[1]
	}

	function Zt(t, e, n) {
		return t[0] = e[0] * n, t[1] = e[1] * n, t
	}

	function Kt(t, e) {
		var n = qt(e);
		return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / n, t[1] = e[1] / n), t
	}

	function $t(t, e) {
		return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
	}
	var Qt = $t;

	function Jt(t, e) {
		return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
	}
	var te = Jt;

	function ee(t, e, n, i) {
		return t[0] = e[0] + i * (n[0] - e[0]), t[1] = e[1] + i * (n[1] - e[1]), t
	}

	function ne(t, e, n) {
		var i = e[0],
			e = e[1];
		return t[0] = n[0] * i + n[2] * e + n[4], t[1] = n[1] * i + n[3] * e + n[5], t
	}

	function ie(t, e, n) {
		return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t
	}

	function re(t, e, n) {
		return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t
	}

	function oe(t, e) {
		this.target = t, this.topTarget = e && e.topTarget
	}
	var ae = Object.freeze({
			__proto__: null,
			add: Xt,
			applyTransform: ne,
			clone: Ut,
			copy: function(t, e) {
				return t[0] = e[0], t[1] = e[1], t
			},
			create: Wt,
			dist: Qt,
			distSquare: te,
			distance: $t,
			distanceSquare: Jt,
			div: function(t, e, n) {
				return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t
			},
			dot: function(t, e) {
				return t[0] * e[0] + t[1] * e[1]
			},
			len: qt,
			lenSquare: jt,
			length: qt,
			lengthSquare: jt,
			lerp: ee,
			max: re,
			min: ie,
			mul: function(t, e, n) {
				return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t
			},
			negate: function(t, e) {
				return t[0] = -e[0], t[1] = -e[1], t
			},
			normalize: Kt,
			scale: Zt,
			scaleAndAdd: function(t, e, n, i) {
				return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t
			},
			set: function(t, e, n) {
				return t[0] = e, t[1] = n, t
			},
			sub: Yt
		}),
		se = (le.prototype._dragStart = function(t) {
			for (var e = t.target; e && !e.draggable;) e = e.parent || e.__hostTarget;
			e && ((this._draggingTarget = e).dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this
				.handler.dispatchToElement(new oe(e, t), "dragstart", t.event))
		}, le.prototype._drag = function(t) {
			var e, n, i, r, o = this._draggingTarget;
			o && (e = t.offsetX, n = t.offsetY, i = e - this._x, r = n - this._y, this._x = e, this._y = n, o
					.drift(i, r, t), this.handler.dispatchToElement(new oe(o, t), "drag", t.event), i = this
					.handler.findHover(e, n, o).target, r = this._dropTarget, o !== (this._dropTarget = i)) && (
					r && i !== r && this.handler.dispatchToElement(new oe(r, t), "dragleave", t.event), i) &&
				i !== r && this.handler.dispatchToElement(new oe(i, t), "dragenter", t.event)
		}, le.prototype._dragEnd = function(t) {
			var e = this._draggingTarget;
			e && (e.dragging = !1), this.handler.dispatchToElement(new oe(e, t), "dragend", t.event), this
				._dropTarget && this.handler.dispatchToElement(new oe(this._dropTarget, t), "drop", t.event),
				this._draggingTarget = null, this._dropTarget = null
		}, le);

	function le(t) {
		(this.handler = t).on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on(
			"mouseup", this._dragEnd, this)
	}
	he.prototype.on = function(t, e, n, i) {
		this._$handlers || (this._$handlers = {});
		var r = this._$handlers;
		if ("function" == typeof e && (i = n, n = e, e = null), n && t) {
			var o = this._$eventProcessor;
			null != e && o && o.normalizeQuery && (e = o.normalizeQuery(e)), r[t] || (r[t] = []);
			for (var a = 0; a < r[t].length; a++)
				if (r[t][a].h === n) return this;
			o = {
				h: n,
				query: e,
				ctx: i || this,
				callAtLast: n.zrEventfulCallAtLast
			}, e = r[t].length - 1, i = r[t][e];
			i && i.callAtLast ? r[t].splice(e, 0, o) : r[t].push(o)
		}
		return this
	}, he.prototype.isSilent = function(t) {
		var e = this._$handlers;
		return !e || !e[t] || !e[t].length
	}, he.prototype.off = function(t, e) {
		var n = this._$handlers;
		if (n)
			if (t)
				if (e) {
					if (n[t]) {
						for (var i = [], r = 0, o = n[t].length; r < o; r++) n[t][r].h !== e && i.push(n[t][r]);
						n[t] = i
					}
					n[t] && 0 === n[t].length && delete n[t]
				} else delete n[t];
		else this._$handlers = {};
		return this
	}, he.prototype.trigger = function(t) {
		for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
		if (this._$handlers) {
			var i = this._$handlers[t],
				r = this._$eventProcessor;
			if (i)
				for (var o = e.length, a = i.length, s = 0; s < a; s++) {
					var l = i[s];
					if (!r || !r.filter || null == l.query || r.filter(t, l.query)) switch (o) {
						case 0:
							l.h.call(l.ctx);
							break;
						case 1:
							l.h.call(l.ctx, e[0]);
							break;
						case 2:
							l.h.call(l.ctx, e[0], e[1]);
							break;
						default:
							l.h.apply(l.ctx, e)
					}
				}
			r && r.afterTrigger && r.afterTrigger(t)
		}
		return this
	}, he.prototype.triggerWithContext = function(t) {
		for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
		if (this._$handlers) {
			var i = this._$handlers[t],
				r = this._$eventProcessor;
			if (i)
				for (var o = e.length, a = e[o - 1], s = i.length, l = 0; l < s; l++) {
					var u = i[l];
					if (!r || !r.filter || null == u.query || r.filter(t, u.query)) switch (o) {
						case 0:
							u.h.call(a);
							break;
						case 1:
							u.h.call(a, e[0]);
							break;
						case 2:
							u.h.call(a, e[0], e[1]);
							break;
						default:
							u.h.apply(a, e.slice(1, o - 1))
					}
				}
			r && r.afterTrigger && r.afterTrigger(t)
		}
		return this
	};
	var ue = he;

	function he(t) {
		t && (this._$eventProcessor = t)
	}
	var ce = Math.log(2);

	function pe(t, e, n, i, r, o) {
		var a, s = i + "-" + r,
			l = t.length;
		if (o.hasOwnProperty(s)) return o[s];
		if (1 === e) return a = Math.round(Math.log((1 << l) - 1 & ~r) / ce), t[n][a];
		for (var u = i | 1 << n, h = n + 1; i & 1 << h;) h++;
		for (var c = 0, p = 0, d = 0; p < l; p++) {
			var f = 1 << p;
			f & r || (c += (d % 2 ? -1 : 1) * t[n][p] * pe(t, e - 1, h, u, r | f, o), d++)
		}
		return o[s] = c
	}

	function de(t, e) {
		var n = [
				[t[0], t[1], 1, 0, 0, 0, -e[0] * t[0], -e[0] * t[1]],
				[0, 0, 0, t[0], t[1], 1, -e[1] * t[0], -e[1] * t[1]],
				[t[2], t[3], 1, 0, 0, 0, -e[2] * t[2], -e[2] * t[3]],
				[0, 0, 0, t[2], t[3], 1, -e[3] * t[2], -e[3] * t[3]],
				[t[4], t[5], 1, 0, 0, 0, -e[4] * t[4], -e[4] * t[5]],
				[0, 0, 0, t[4], t[5], 1, -e[5] * t[4], -e[5] * t[5]],
				[t[6], t[7], 1, 0, 0, 0, -e[6] * t[6], -e[6] * t[7]],
				[0, 0, 0, t[6], t[7], 1, -e[7] * t[6], -e[7] * t[7]]
			],
			i = {},
			r = pe(n, 8, 0, 0, 0, i);
		if (0 !== r) {
			for (var o = [], a = 0; a < 8; a++)
				for (var s = 0; s < 8; s++) null == o[s] && (o[s] = 0), o[s] += ((a + s) % 2 ? -1 : 1) * pe(n, 7,
					0 === a ? 1 : 0, 1 << a, 1 << s, i) / r * e[a];
			return function(t, e, n) {
				var i = e * o[6] + n * o[7] + 1;
				t[0] = (e * o[0] + n * o[1] + o[2]) / i, t[1] = (e * o[3] + n * o[4] + o[5]) / i
			}
		}
	}
	var fe = "___zrEVENTSAVED",
		ge = [];

	function ye(t, e, n, i, r) {
		if (e.getBoundingClientRect && b.domSupported && !me(e)) {
			var o = e[fe] || (e[fe] = {}),
				e = function(t, e, n) {
					for (var i = n ? "invTrans" : "trans", r = e[i], o = e.srcCoords, a = [], s = [], l = !0, u =
							0; u < 4; u++) {
						var h = t[u].getBoundingClientRect(),
							c = 2 * u,
							p = h.left,
							h = h.top;
						a.push(p, h), l = l && o && p === o[c] && h === o[1 + c], s.push(t[u].offsetLeft, t[u]
							.offsetTop)
					}
					return l && r ? r : (e.srcCoords = a, e[i] = n ? de(s, a) : de(a, s))
				}(function(t, e) {
					var n = e.markers;
					if (!n) {
						n = e.markers = [];
						for (var i = ["left", "right"], r = ["top", "bottom"], o = 0; o < 4; o++) {
							var a = document.createElement("div"),
								s = o % 2,
								l = (o >> 1) % 2;
							a.style.cssText = ["position: absolute", "visibility: hidden", "padding: 0",
								"margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0",
								i[s] + ":0", r[l] + ":0", i[1 - s] + ":auto", r[1 - l] + ":auto", ""
							].join("!important;"), t.appendChild(a), n.push(a)
						}
					}
					return n
				}(e, o), o, r);
			if (e) return e(t, n, i), !0
		}
		return !1
	}

	function me(t) {
		return "CANVAS" === t.nodeName.toUpperCase()
	}
	var ve = /([&<>"'])/g,
		_e = {
			"&": "&amp;",
			"<": "&lt;",
			">": "&gt;",
			'"': "&quot;",
			"'": "&#39;"
		};

	function xe(t) {
		return null == t ? "" : (t + "").replace(ve, function(t, e) {
			return _e[e]
		})
	}
	var we = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		be = [],
		Se = b.browser.firefox && +b.browser.version.split(".")[0] < 39;

	function Me(t, e, n, i) {
		return n = n || {}, i ? Te(t, e, n) : Se && null != e.layerX && e.layerX !== e.offsetX ? (n.zrX = e.layerX,
			n.zrY = e.layerY) : null != e.offsetX ? (n.zrX = e.offsetX, n.zrY = e.offsetY) : Te(t, e, n), n
	}

	function Te(t, e, n) {
		if (b.domSupported && t.getBoundingClientRect) {
			var i, r = e.clientX,
				e = e.clientY;
			if (me(t)) return i = t.getBoundingClientRect(), n.zrX = r - i.left, n.zrY = e - i.top;
			if (ye(be, t, r, e)) return n.zrX = be[0], n.zrY = be[1]
		}
		n.zrX = n.zrY = 0
	}

	function Ce(t) {
		return t || window.event
	}

	function Ie(t, e, n) {
		var i;
		return null == (e = Ce(e)).zrX && ((i = e.type) && 0 <= i.indexOf("touch") ? (i = ("touchend" !== i ? e
			.targetTouches : e.changedTouches)[0]) && Me(t, i, e, n) : (Me(t, e, e, n), t = (t = (i = e)
				.wheelDelta) || (n = i.deltaX, i = i.deltaY, null == n || null == i ? t : 3 * (0 !== i ?
				Math.abs(i) : Math.abs(n)) * (0 < i || !(i < 0) && 0 < n ? -1 : 1)), e.zrDelta = t ? t /
			120 : -(e.detail || 0) / 3), i = e.button, null == e.which && void 0 !== i && we.test(e.type)) && (e
			.which = 1 & i ? 1 : 2 & i ? 3 : 4 & i ? 2 : 0), e
	}
	var ke = function(t) {
			// t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
			// An highlighted block
			if (isDomLevel2) {
				t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
			} else {
				t.returnValue = false;
				t.cancelBubble = !0
			}
		},
		De = (Ae.prototype.recognize = function(t, e, n) {
			return this._doTrack(t, e, n), this._recognize(t)
		}, Ae.prototype.clear = function() {
			return this._track.length = 0, this
		}, Ae.prototype._doTrack = function(t, e, n) {
			var i = t.touches;
			if (i) {
				for (var r = {
						points: [],
						touches: [],
						target: e,
						event: t
					}, o = 0, a = i.length; o < a; o++) {
					var s = i[o],
						l = Me(n, s, {});
					r.points.push([l.zrX, l.zrY]), r.touches.push(s)
				}
				this._track.push(r)
			}
		}, Ae.prototype._recognize = function(t) {
			for (var e in Le)
				if (Le.hasOwnProperty(e)) {
					e = Le[e](this._track, t);
					if (e) return e
				}
		}, Ae);

	function Ae() {
		this._track = []
	}

	function Pe(t) {
		var e = t[1][0] - t[0][0],
			t = t[1][1] - t[0][1];
		return Math.sqrt(e * e + t * t)
	}
	var Le = {
		pinch: function(t, e) {
			var n = t.length;
			if (n) {
				var i = (t[n - 1] || {}).points,
					n = (t[n - 2] || {}).points || i;
				if (n && 1 < n.length && i && 1 < i.length) return n = Pe(i) / Pe(n), isFinite(n) || (n =
						1), e.pinchScale = n, n = [(i[0][0] + i[1][0]) / 2, (i[0][1] + i[1][1]) / 2], e
					.pinchX = n[0], e.pinchY = n[1], {
						type: "pinch",
						target: t[0].target,
						event: e
					}
			}
		}
	};

	function Oe() {
		return [1, 0, 0, 1, 0, 0]
	}

	function Re(t) {
		return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
	}

	function Ne(t, e) {
		return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
	}

	function Ee(t, e, n) {
		var i = e[0] * n[0] + e[2] * n[1],
			r = e[1] * n[0] + e[3] * n[1],
			o = e[0] * n[2] + e[2] * n[3],
			a = e[1] * n[2] + e[3] * n[3],
			s = e[0] * n[4] + e[2] * n[5] + e[4],
			n = e[1] * n[4] + e[3] * n[5] + e[5];
		return t[0] = i, t[1] = r, t[2] = o, t[3] = a, t[4] = s, t[5] = n, t
	}

	function ze(t, e, n) {
		return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + n[0], t[5] = e[5] + n[1], t
	}

	function Be(t, e, n) {
		var i = e[0],
			r = e[2],
			o = e[4],
			a = e[1],
			s = e[3],
			e = e[5],
			l = Math.sin(n),
			n = Math.cos(n);
		return t[0] = i * n + a * l, t[1] = -i * l + a * n, t[2] = r * n + s * l, t[3] = -r * l + n * s, t[4] = n *
			o + l * e, t[5] = n * e - l * o, t
	}

	function Fe(t, e, n) {
		var i = n[0],
			n = n[1];
		return t[0] = e[0] * i, t[1] = e[1] * n, t[2] = e[2] * i, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * n,
			t
	}

	function Ve(t, e) {
		var n = e[0],
			i = e[2],
			r = e[4],
			o = e[1],
			a = e[3],
			e = e[5],
			s = n * a - o * i;
		return s ? (t[0] = a * (s = 1 / s), t[1] = -o * s, t[2] = -i * s, t[3] = n * s, t[4] = (i * e - a * r) * s,
			t[5] = (o * r - n * e) * s, t) : null
	}
	var He = Object.freeze({
			__proto__: null,
			clone: function(t) {
				var e = Oe();
				return Ne(e, t), e
			},
			copy: Ne,
			create: Oe,
			identity: Re,
			invert: Ve,
			mul: Ee,
			rotate: Be,
			scale: Fe,
			translate: ze
		}),
		W = (e.prototype.copy = function(t) {
			return this.x = t.x, this.y = t.y, this
		}, e.prototype.clone = function() {
			return new e(this.x, this.y)
		}, e.prototype.set = function(t, e) {
			return this.x = t, this.y = e, this
		}, e.prototype.equal = function(t) {
			return t.x === this.x && t.y === this.y
		}, e.prototype.add = function(t) {
			return this.x += t.x, this.y += t.y, this
		}, e.prototype.scale = function(t) {
			this.x *= t, this.y *= t
		}, e.prototype.scaleAndAdd = function(t, e) {
			this.x += t.x * e, this.y += t.y * e
		}, e.prototype.sub = function(t) {
			return this.x -= t.x, this.y -= t.y, this
		}, e.prototype.dot = function(t) {
			return this.x * t.x + this.y * t.y
		}, e.prototype.len = function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		}, e.prototype.lenSquare = function() {
			return this.x * this.x + this.y * this.y
		}, e.prototype.normalize = function() {
			var t = this.len();
			return this.x /= t, this.y /= t, this
		}, e.prototype.distance = function(t) {
			var e = this.x - t.x,
				t = this.y - t.y;
			return Math.sqrt(e * e + t * t)
		}, e.prototype.distanceSquare = function(t) {
			var e = this.x - t.x,
				t = this.y - t.y;
			return e * e + t * t
		}, e.prototype.negate = function() {
			return this.x = -this.x, this.y = -this.y, this
		}, e.prototype.transform = function(t) {
			var e, n;
			if (t) return e = this.x, n = this.y, this.x = t[0] * e + t[2] * n + t[4], this.y = t[1] * e + t[
				3] * n + t[5], this
		}, e.prototype.toArray = function(t) {
			return t[0] = this.x, t[1] = this.y, t
		}, e.prototype.fromArray = function(t) {
			this.x = t[0], this.y = t[1]
		}, e.set = function(t, e, n) {
			t.x = e, t.y = n
		}, e.copy = function(t, e) {
			t.x = e.x, t.y = e.y
		}, e.len = function(t) {
			return Math.sqrt(t.x * t.x + t.y * t.y)
		}, e.lenSquare = function(t) {
			return t.x * t.x + t.y * t.y
		}, e.dot = function(t, e) {
			return t.x * e.x + t.y * e.y
		}, e.add = function(t, e, n) {
			t.x = e.x + n.x, t.y = e.y + n.y
		}, e.sub = function(t, e, n) {
			t.x = e.x - n.x, t.y = e.y - n.y
		}, e.scale = function(t, e, n) {
			t.x = e.x * n, t.y = e.y * n
		}, e.scaleAndAdd = function(t, e, n, i) {
			t.x = e.x + n.x * i, t.y = e.y + n.y * i
		}, e.lerp = function(t, e, n, i) {
			var r = 1 - i;
			t.x = r * e.x + i * n.x, t.y = r * e.y + i * n.y
		}, e);

	function e(t, e) {
		this.x = t || 0, this.y = e || 0
	}
	var Ge = Math.min,
		We = Math.max,
		Ue = new W,
		Xe = new W,
		Ye = new W,
		qe = new W,
		je = new W,
		Ze = new W,
		U = (Ke.prototype.union = function(t) {
			var e = Ge(t.x, this.x),
				n = Ge(t.y, this.y);
			isFinite(this.x) && isFinite(this.width) ? this.width = We(t.x + t.width, this.x + this.width) - e :
				this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = We(t.y + t
					.height, this.y + this.height) - n : this.height = t.height, this.x = e, this.y = n
		}, Ke.prototype.applyTransform = function(t) {
			Ke.applyTransform(this, this, t)
		}, Ke.prototype.calculateTransform = function(t) {
			var e = t.width / this.width,
				n = t.height / this.height,
				i = Oe();
			return ze(i, i, [-this.x, -this.y]), Fe(i, i, [e, n]), ze(i, i, [t.x, t.y]), i
		}, Ke.prototype.intersect = function(t, e) {
			if (!t) return !1;
			t instanceof Ke || (t = Ke.create(t));
			var n, i, r, o, a, s, l, u, h = this,
				c = h.x,
				p = h.x + h.width,
				d = h.y,
				h = h.y + h.height,
				f = t.x,
				g = t.x + t.width,
				y = t.y,
				t = t.y + t.height,
				m = !(p < f || g < c || h < y || t < d);
			return e && (n = 1 / 0, i = 0, r = Math.abs(p - f), o = Math.abs(g - c), a = Math.abs(h - y), s =
				Math.abs(t - d), l = Math.min(r, o), u = Math.min(a, s), p < f || g < c ? i < l && (i = l,
					r < o ? W.set(Ze, -r, 0) : W.set(Ze, o, 0)) : l < n && (n = l, r < o ? W.set(je, r, 0) :
					W.set(je, -o, 0)), h < y || t < d ? i < u && (i = u, a < s ? W.set(Ze, 0, -a) : W.set(
					Ze, 0, s)) : l < n && (n = l, a < s ? W.set(je, 0, a) : W.set(je, 0, -s))), e && W.copy(
				e, m ? je : Ze), m
		}, Ke.prototype.contain = function(t, e) {
			var n = this;
			return t >= n.x && t <= n.x + n.width && e >= n.y && e <= n.y + n.height
		}, Ke.prototype.clone = function() {
			return new Ke(this.x, this.y, this.width, this.height)
		}, Ke.prototype.copy = function(t) {
			Ke.copy(this, t)
		}, Ke.prototype.plain = function() {
			return {
				x: this.x,
				y: this.y,
				width: this.width,
				height: this.height
			}
		}, Ke.prototype.isFinite = function() {
			return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height)
		}, Ke.prototype.isZero = function() {
			return 0 === this.width || 0 === this.height
		}, Ke.create = function(t) {
			return new Ke(t.x, t.y, t.width, t.height)
		}, Ke.copy = function(t, e) {
			t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height
		}, Ke.applyTransform = function(t, e, n) {
			var i, r, o, a;
			n ? n[1] < 1e-5 && -1e-5 < n[1] && n[2] < 1e-5 && -1e-5 < n[2] ? (i = n[0], r = n[3], o = n[4], a =
				n[5], t.x = e.x * i + o, t.y = e.y * r + a, t.width = e.width * i, t.height = e.height * r,
				t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t
					.height = -t.height)) : (Ue.x = Ye.x = e.x, Ue.y = qe.y = e.y, Xe.x = qe.x = e.x + e
				.width, Xe.y = Ye.y = e.y + e.height, Ue.transform(n), qe.transform(n), Xe.transform(n), Ye
				.transform(n), t.x = Ge(Ue.x, Xe.x, Ye.x, qe.x), t.y = Ge(Ue.y, Xe.y, Ye.y, qe.y), o = We(Ue
					.x, Xe.x, Ye.x, qe.x), a = We(Ue.y, Xe.y, Ye.y, qe.y), t.width = o - t.x, t.height = a -
				t.y) : t !== e && Ke.copy(t, e)
		}, Ke);

	function Ke(t, e, n, i) {
		n < 0 && (t += n, n = -n), i < 0 && (e += i, i = -i), this.x = t, this.y = e, this.width = n, this.height =
			i
	}
	var $e = "silent";

	function Qe() {
		ke(this.event)
	}

	function Je(t, e) {
		this.x = t, this.y = e
	}
	u(ln, en = ue), ln.prototype.dispose = function() {}, ln.prototype.setCursor = function() {};
	var tn, en, nn = ln,
		rn = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"],
		on = new U(0, 0, 0, 0),
		an = (u(sn, tn = ue), sn.prototype.setHandlerProxy = function(e) {
			this.proxy && this.proxy.dispose(), e && (E(rn, function(t) {
				e.on && e.on(t, this[t], this)
			}, this), e.handler = this), this.proxy = e
		}, sn.prototype.mousemove = function(t) {
			var e = t.zrX,
				n = t.zrY,
				i = hn(this, e, n),
				r = this._hovered,
				o = r.target,
				i = (o && !o.__zr && (o = (r = this.findHover(r.x, r.y)).target), this._hovered = i ? new Je(e,
					n) : this.findHover(e, n)),
				e = i.target,
				n = this.proxy;
			n.setCursor && n.setCursor(e ? e.cursor : "default"), o && e !== o && this.dispatchToElement(r,
					"mouseout", t), this.dispatchToElement(i, "mousemove", t), e && e !== o && this
				.dispatchToElement(i, "mouseover", t)
		}, sn.prototype.mouseout = function(t) {
			var e = t.zrEventControl;
			"only_globalout" !== e && this.dispatchToElement(this._hovered, "mouseout", t), "no_globalout" !==
				e && this.trigger("globalout", {
					type: "globalout",
					event: t
				})
		}, sn.prototype.resize = function() {
			this._hovered = new Je(0, 0)
		}, sn.prototype.dispatch = function(t, e) {
			t = this[t];
			t && t.call(this, e)
		}, sn.prototype.dispose = function() {
			this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null
		}, sn.prototype.setCursorStyle = function(t) {
			var e = this.proxy;
			e.setCursor && e.setCursor(t)
		}, sn.prototype.dispatchToElement = function(t, e, n) {
			var i = (t = t || {}).target;
			if (!i || !i.silent) {
				for (var r = "on" + e, o = {
						type: e,
						event: n,
						target: (t = t).target,
						topTarget: t.topTarget,
						cancelBubble: !1,
						offsetX: n.zrX,
						offsetY: n.zrY,
						gestureEvent: n.gestureEvent,
						pinchX: n.pinchX,
						pinchY: n.pinchY,
						pinchScale: n.pinchScale,
						wheelDelta: n.zrDelta,
						zrByTouch: n.zrByTouch,
						which: n.which,
						stop: Qe
					}; i && (i[r] && (o.cancelBubble = !!i[r].call(i, o)), i.trigger(e, o), i = i
						.__hostTarget || i.parent, !o.cancelBubble););
				o.cancelBubble || (this.trigger(e, o), this.painter && this.painter.eachOtherLayer && this
					.painter.eachOtherLayer(function(t) {
						"function" == typeof t[r] && t[r].call(t, o), t.trigger && t.trigger(e, o)
					}))
			}
		}, sn.prototype.findHover = function(t, e, n) {
			var i = this.storage.getDisplayList(),
				r = new Je(t, e);
			if (un(i, r, t, e, n), this._pointerSize && !r.target) {
				for (var o = [], a = this._pointerSize, s = a / 2, l = new U(t - s, e - s, a, a), u = i.length -
						1; 0 <= u; u--) {
					var h = i[u];
					h === n || h.ignore || h.ignoreCoarsePointer || h.parent && h.parent.ignoreCoarsePointer ||
						(on.copy(h.getBoundingRect()), h.transform && on.applyTransform(h.transform), on
							.intersect(l) && o.push(h))
				}
				if (o.length)
					for (var c = Math.PI / 12, p = 2 * Math.PI, d = 0; d < s; d += 4)
						for (var f = 0; f < p; f += c)
							if (un(o, r, t + d * Math.cos(f), e + d * Math.sin(f), n), r.target) return r
			}
			return r
		}, sn.prototype.processGesture = function(t, e) {
			this._gestureMgr || (this._gestureMgr = new De);
			var n = this._gestureMgr,
				i = ("start" === e && n.clear(), n.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this
					.proxy.dom));
			"end" === e && n.clear(), i && (e = i.type, t.gestureEvent = e, (n = new Je).target = i.target, this
				.dispatchToElement(n, e, i.event))
		}, sn);

	function sn(t, e, n, i, r) {
		var o = tn.call(this) || this;
		return o._hovered = new Je(0, 0), o.storage = t, o.painter = e, o.painterRoot = i, o._pointerSize = r, n =
			n || new nn, o.proxy = null, o.setHandlerProxy(n), o._draggingMgr = new se(o), o
	}

	function ln() {
		var t = null !== en && en.apply(this, arguments) || this;
		return t.handler = null, t
	}

	function un(t, e, n, i, r) {
		for (var o = t.length - 1; 0 <= o; o--) {
			var a = t[o],
				s = void 0;
			if (a !== r && !a.ignore && (s = function(t, e, n) {
					if (t[t.rectHover ? "rectContain" : "contain"](e, n)) {
						for (var i = t, r = void 0, o = !1; i;) {
							if (!(o = i.ignoreClip ? !0 : o)) {
								var a = i.getClipPath();
								if (a && !a.contain(e, n)) return !1;
								i.silent && (r = !0)
							}
							i = i.__hostTarget || i.parent
						}
						return !r || $e
					}
					return !1
				}(a, n, i)) && (e.topTarget || (e.topTarget = a), s !== $e)) {
				e.target = a;
				break
			}
		}
	}

	function hn(t, e, n) {
		t = t.painter;
		return e < 0 || e > t.getWidth() || n < 0 || n > t.getHeight()
	}
	E(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(a) {
		an.prototype[a] = function(t) {
			var e, n, i = t.zrX,
				r = t.zrY,
				o = hn(this, i, r);
			if ("mouseup" === a && o || (n = (e = this.findHover(i, r)).target), "mousedown" === a) this
				._downEl = n, this._downPoint = [t.zrX, t.zrY], this._upEl = n;
			else if ("mouseup" === a) this._upEl = n;
			else if ("click" === a) {
				if (this._downEl !== this._upEl || !this._downPoint || 4 < Qt(this._downPoint, [t.zrX, t
						.zrY
					])) return;
				this._downPoint = null
			}
			this.dispatchToElement(e, a, t)
		}
	});
	var cn = 32,
		pn = 7;

	function dn(t, e, n, i) {
		var r = e + 1;
		if (r === n) return 1;
		if (i(t[r++], t[e]) < 0) {
			for (; r < n && i(t[r], t[r - 1]) < 0;) r++;
			var o = t,
				a = e,
				s = r;
			for (s--; a < s;) {
				var l = o[a];
				o[a++] = o[s], o[s--] = l
			}
		} else
			for (; r < n && 0 <= i(t[r], t[r - 1]);) r++;
		return r - e
	}

	function fn(t, e, n, i, r) {
		for (i === e && i++; i < n; i++) {
			for (var o, a = t[i], s = e, l = i; s < l;) r(a, t[o = s + l >>> 1]) < 0 ? l = o : s = 1 + o;
			var u = i - s;
			switch (u) {
				case 3:
					t[s + 3] = t[s + 2];
				case 2:
					t[s + 2] = t[s + 1];
				case 1:
					t[s + 1] = t[s];
					break;
				default:
					for (; 0 < u;) t[s + u] = t[s + u - 1], u--
			}
			t[s] = a
		}
	}

	function gn(t, e, n, i, r, o) {
		var a = 0,
			s = 0,
			l = 1;
		if (0 < o(t, e[n + r])) {
			for (s = i - r; l < s && 0 < o(t, e[n + r + l]);)(l = 1 + ((a = l) << 1)) <= 0 && (l = s);
			s < l && (l = s), a += r, l += r
		} else {
			for (s = r + 1; l < s && o(t, e[n + r - l]) <= 0;)(l = 1 + ((a = l) << 1)) <= 0 && (l = s);
			i = a, a = r - (l = s < l ? s : l), l = r - i
		}
		for (a++; a < l;) {
			var u = a + (l - a >>> 1);
			0 < o(t, e[n + u]) ? a = u + 1 : l = u
		}
		return l
	}

	function yn(t, e, n, i, r, o) {
		var a = 0,
			s = 0,
			l = 1;
		if (o(t, e[n + r]) < 0) {
			for (s = r + 1; l < s && o(t, e[n + r - l]) < 0;)(l = 1 + ((a = l) << 1)) <= 0 && (l = s);
			var u = a,
				a = r - (l = s < l ? s : l),
				l = r - u
		} else {
			for (s = i - r; l < s && 0 <= o(t, e[n + r + l]);)(l = 1 + ((a = l) << 1)) <= 0 && (l = s);
			s < l && (l = s), a += r, l += r
		}
		for (a++; a < l;) {
			var h = a + (l - a >>> 1);
			o(t, e[n + h]) < 0 ? l = h : a = h + 1
		}
		return l
	}

	function mn(t, e, n, i) {
		var f, g, o, a, y, s, m, r = (i = i || t.length) - (n = n || 0);
		if (!(r < 2)) {
			var l = 0;
			if (r < cn) fn(t, n, i, n + (l = dn(t, n, i, e)), e);
			else {
				g = e, y = pn, s = 0, (f = t).length, m = [], o = [], a = [];
				var u, h = {
						mergeRuns: function() {
							for (; 1 < s;) {
								var t = s - 2;
								if (1 <= t && a[t - 1] <= a[t] + a[t + 1] || 2 <= t && a[t - 2] <= a[t] + a[t -
										1]) a[t - 1] < a[t + 1] && t--;
								else if (a[t] > a[t + 1]) break;
								p(t)
							}
						},
						forceMergeRuns: function() {
							for (; 1 < s;) {
								var t = s - 2;
								0 < t && a[t - 1] < a[t + 1] && t--, p(t)
							}
						},
						pushRun: function(t, e) {
							o[s] = t, a[s] = e, s += 1
						}
					},
					c = function(t) {
						for (var e = 0; cn <= t;) e |= 1 & t, t >>= 1;
						return t + e
					}(r);
				do {} while ((l = dn(t, n, i, e)) < c && (fn(t, n, n + (u = c < (u = r) ? c : r), n + l, e), l = u),
					h.pushRun(n, l), h.mergeRuns(), n += l, 0 !== (r -= l));
				h.forceMergeRuns()
			}
		}

		function p(t) {
			var e = o[t],
				n = a[t],
				i = o[t + 1],
				r = a[t + 1],
				t = (a[t] = n + r, t === s - 3 && (o[t + 1] = o[t + 2], a[t + 1] = a[t + 2]), s--, yn(f[i], f, e, n,
					0, g));
			e += t, 0 != (n -= t) && 0 !== (r = gn(f[e + n - 1], f, i, r, r - 1, g)) && (n <= r ? function(t, e, n,
				i) {
				for (var r = 0, r = 0; r < e; r++) m[r] = f[t + r];
				var o = 0,
					a = n,
					s = t;
				if (f[s++] = f[a++], 0 == --i)
					for (r = 0; r < e; r++) f[s + r] = m[o + r];
				else {
					if (1 === e) {
						for (r = 0; r < i; r++) f[s + r] = f[a + r];
						return f[s + i] = m[o]
					}
					for (var l, u, h, c = y;;) {
						u = l = 0, h = !1;
						do {
							if (g(f[a], m[o]) < 0) {
								if (f[s++] = f[a++], u++, (l = 0) == --i) {
									h = !0;
									break
								}
							} else if (f[s++] = m[o++], l++, u = 0, 1 == --e) {
								h = !0;
								break
							}
						} while ((l | u) < c);
						if (h) break;
						do {
							if (0 !== (l = yn(f[a], m, o, e, 0, g))) {
								for (r = 0; r < l; r++) f[s + r] = m[o + r];
								if (s += l, o += l, (e -= l) <= 1) {
									h = !0;
									break
								}
							}
							if (f[s++] = f[a++], 0 == --i) {
								h = !0;
								break
							}
							if (0 !== (u = gn(m[o], f, a, i, 0, g))) {
								for (r = 0; r < u; r++) f[s + r] = f[a + r];
								if (s += u, a += u, 0 == (i -= u)) {
									h = !0;
									break
								}
							}
							if (f[s++] = m[o++], 1 == --e) {
								h = !0;
								break
							}
						} while (c--, pn <= l || pn <= u);
						if (h) break;
						c < 0 && (c = 0), c += 2
					}
					if ((y = c) < 1 && (y = 1), 1 === e) {
						for (r = 0; r < i; r++) f[s + r] = f[a + r];
						f[s + i] = m[o]
					} else {
						if (0 === e) throw new Error;
						for (r = 0; r < e; r++) f[s + r] = m[o + r]
					}
				}
			} : function(t, e, n, i) {
				for (var r = 0, r = 0; r < i; r++) m[r] = f[n + r];
				var o = t + e - 1,
					a = i - 1,
					s = n + i - 1,
					l = 0,
					u = 0;
				if (f[s--] = f[o--], 0 == --e)
					for (l = s - (i - 1), r = 0; r < i; r++) f[l + r] = m[r];
				else {
					if (1 === i) {
						for (u = 1 + (s -= e), l = 1 + (o -= e), r = e - 1; 0 <= r; r--) f[u + r] = f[l +
							r];
						return f[s] = m[a]
					}
					for (var h = y;;) {
						var c = 0,
							p = 0,
							d = !1;
						do {
							if (g(m[a], f[o]) < 0) {
								if (f[s--] = f[o--], c++, (p = 0) == --e) {
									d = !0;
									break
								}
							} else if (f[s--] = m[a--], p++, c = 0, 1 == --i) {
								d = !0;
								break
							}
						} while ((c | p) < h);
						if (d) break;
						do {
							if (0 != (c = e - yn(m[a], f, t, e, e - 1, g))) {
								for (e -= c, u = 1 + (s -= c), l = 1 + (o -= c), r = c - 1; 0 <= r; r--) f[
									u + r] = f[l + r];
								if (0 === e) {
									d = !0;
									break
								}
							}
							if (f[s--] = m[a--], 1 == --i) {
								d = !0;
								break
							}
							if (0 != (p = i - gn(f[o], m, 0, i, i - 1, g))) {
								for (i -= p, u = 1 + (s -= p), l = 1 + (a -= p), r = 0; r < p; r++) f[u +
									r] = m[l + r];
								if (i <= 1) {
									d = !0;
									break
								}
							}
							if (f[s--] = f[o--], 0 == --e) {
								d = !0;
								break
							}
						} while (h--, pn <= c || pn <= p);
						if (d) break;
						h < 0 && (h = 0), h += 2
					}
					if ((y = h) < 1 && (y = 1), 1 === i) {
						for (u = 1 + (s -= e), l = 1 + (o -= e), r = e - 1; 0 <= r; r--) f[u + r] = f[l +
							r];
						f[s] = m[a]
					} else {
						if (0 === i) throw new Error;
						for (l = s - (i - 1), r = 0; r < i; r++) f[l + r] = m[r]
					}
				}
			})(e, n, i, r)
		}
	}
	var vn = 1,
		_n = 4,
		xn = !1;

	function wn() {
		xn || (xn = !0, console.warn(
			"z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"))
	}

	function bn(t, e) {
		return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
	}
	Mn.prototype.traverse = function(t, e) {
		for (var n = 0; n < this._roots.length; n++) this._roots[n].traverse(t, e)
	}, Mn.prototype.getDisplayList = function(t, e) {
		e = e || !1;
		var n = this._displayList;
		return !t && n.length || this.updateDisplayList(e), n
	}, Mn.prototype.updateDisplayList = function(t) {
		this._displayListLen = 0;
		for (var e = this._roots, n = this._displayList, i = 0, r = e.length; i < r; i++) this
			._updateAndAddDisplayable(e[i], null, t);
		n.length = this._displayListLen, mn(n, bn)
	}, Mn.prototype._updateAndAddDisplayable = function(t, e, n) {
		if (!t.ignore || n) {
			t.beforeUpdate(), t.update(), t.afterUpdate();
			var i = t.getClipPath();
			if (t.ignoreClip) e = null;
			else if (i) {
				e = e ? e.slice() : [];
				for (var r = i, o = t; r;) r.parent = o, r.updateTransform(), e.push(r), r = (o = r)
					.getClipPath()
			}
			if (t.childrenRef) {
				for (var a = t.childrenRef(), s = 0; s < a.length; s++) {
					var l = a[s];
					t.__dirty && (l.__dirty |= vn), this._updateAndAddDisplayable(l, e, n)
				}
				t.__dirty = 0
			} else {
				i = t;
				e && e.length ? i.__clipPaths = e : i.__clipPaths && 0 < i.__clipPaths.length && (i
						.__clipPaths = []), isNaN(i.z) && (wn(), i.z = 0), isNaN(i.z2) && (wn(), i.z2 = 0),
					isNaN(i.zlevel) && (wn(), i.zlevel = 0), this._displayList[this._displayListLen++] = i
			}
			i = t.getDecalElement && t.getDecalElement(), i = (i && this._updateAndAddDisplayable(i, e, n), t
				.getTextGuideLine()), i = (i && this._updateAndAddDisplayable(i, e, n), t.getTextContent());
			i && this._updateAndAddDisplayable(i, e, n)
		}
	}, Mn.prototype.addRoot = function(t) {
		t.__zr && t.__zr.storage === this || this._roots.push(t)
	}, Mn.prototype.delRoot = function(t) {
		if (t instanceof Array)
			for (var e = 0, n = t.length; e < n; e++) this.delRoot(t[e]);
		else {
			var i = I(this._roots, t);
			0 <= i && this._roots.splice(i, 1)
		}
	}, Mn.prototype.delAllRoots = function() {
		this._roots = [], this._displayList = [], this._displayListLen = 0
	}, Mn.prototype.getRoots = function() {
		return this._roots
	}, Mn.prototype.dispose = function() {
		this._displayList = null, this._roots = null
	};
	var Sn = Mn;

	function Mn() {
		this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = bn
	}
	var Tn = b.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) ||
			window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window
			.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
			return setTimeout(t, 16)
		},
		Cn = {
			linear: function(t) {
				return t
			},
			quadraticIn: function(t) {
				return t * t
			},
			quadraticOut: function(t) {
				return t * (2 - t)
			},
			quadraticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
			},
			cubicIn: function(t) {
				return t * t * t
			},
			cubicOut: function(t) {
				return --t * t * t + 1
			},
			cubicInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
			},
			quarticIn: function(t) {
				return t * t * t * t
			},
			quarticOut: function(t) {
				return 1 - --t * t * t * t
			},
			quarticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
			},
			quinticIn: function(t) {
				return t * t * t * t * t
			},
			quinticOut: function(t) {
				return --t * t * t * t * t + 1
			},
			quinticInOut: function(t) {
				return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
			},
			sinusoidalIn: function(t) {
				return 1 - Math.cos(t * Math.PI / 2)
			},
			sinusoidalOut: function(t) {
				return Math.sin(t * Math.PI / 2)
			},
			sinusoidalInOut: function(t) {
				return .5 * (1 - Math.cos(Math.PI * t))
			},
			exponentialIn: function(t) {
				return 0 === t ? 0 : Math.pow(1024, t - 1)
			},
			exponentialOut: function(t) {
				return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
			},
			exponentialInOut: function(t) {
				return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math
					.pow(2, -10 * (t - 1)))
			},
			circularIn: function(t) {
				return 1 - Math.sqrt(1 - t * t)
			},
			circularOut: function(t) {
				return Math.sqrt(1 - --t * t)
			},
			circularInOut: function(t) {
				return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
			},
			elasticIn: function(t) {
				var e, n = .1;
				return 0 === t ? 0 : 1 === t ? 1 : (e = !n || n < 1 ? (n = 1, .1) : .4 * Math.asin(1 / n) / (2 *
					Math.PI), -n * Math.pow(2, 10 * --t) * Math.sin((t - e) * (2 * Math.PI) / .4))
			},
			elasticOut: function(t) {
				var e, n = .1;
				return 0 === t ? 0 : 1 === t ? 1 : (e = !n || n < 1 ? (n = 1, .1) : .4 * Math.asin(1 / n) / (2 *
					Math.PI), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
			},
			elasticInOut: function(t) {
				var e, n = .1;
				return 0 === t ? 0 : 1 === t ? 1 : (e = !n || n < 1 ? (n = 1, .1) : .4 * Math.asin(1 / n) / (2 *
					Math.PI), (t *= 2) < 1 ? n * Math.pow(2, 10 * --t) * Math.sin((t - e) * (2 * Math
					.PI) / .4) * -.5 : n * Math.pow(2, -10 * --t) * Math.sin((t - e) * (2 * Math.PI) /
					.4) * .5 + 1)
			},
			backIn: function(t) {
				return t * t * (2.70158 * t - 1.70158)
			},
			backOut: function(t) {
				return --t * t * (2.70158 * t + 1.70158) + 1
			},
			backInOut: function(t) {
				var e = 2.5949095;
				return (t *= 2) < 1 ? t * t * ((1 + e) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + e) * t + e) +
					2)
			},
			bounceIn: function(t) {
				return 1 - Cn.bounceOut(1 - t)
			},
			bounceOut: function(t) {
				return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t <
					2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t +
					.984375
			},
			bounceInOut: function(t) {
				return t < .5 ? .5 * Cn.bounceIn(2 * t) : .5 * Cn.bounceOut(2 * t - 1) + .5
			}
		},
		In = Math.pow,
		kn = Math.sqrt,
		Dn = 1e-8,
		An = kn(3),
		Pn = 1 / 3,
		Ln = Wt(),
		On = Wt(),
		Rn = Wt();

	function Nn(t) {
		return -Dn < t && t < Dn
	}

	function En(t) {
		return Dn < t || t < -Dn
	}

	function zn(t, e, n, i, r) {
		var o = 1 - r;
		return o * o * (o * t + 3 * r * e) + r * r * (r * i + 3 * o * n)
	}

	function Bn(t, e, n, i, r) {
		var o = 1 - r;
		return 3 * (((e - t) * o + 2 * (n - e) * r) * o + (i - n) * r * r)
	}

	function Fn(t, e, n, i, r, o) {
		var a, s, i = i + 3 * (e - n) - t,
			n = 3 * (n - 2 * e + t),
			e = 3 * (e - t),
			t = t - r,
			r = n * n - 3 * i * e,
			l = n * e - 9 * i * t,
			t = e * e - 3 * n * t,
			u = 0;
		return Nn(r) && Nn(l) ? Nn(n) ? o[0] = 0 : 0 <= (s = -e / n) && s <= 1 && (o[u++] = s) : Nn(e = l * l - 4 *
			r * t) ? (a = -(t = l / r) / 2, 0 <= (s = -n / i + t) && s <= 1 && (o[u++] = s), 0 <= a && a <= 1 &&
			(o[u++] = a)) : 0 < e ? (e = r * n + 1.5 * i * (-l - (t = kn(e))), 0 <= (s = (-n - ((t = (t = r *
			n + 1.5 * i * (-l + t)) < 0 ? -In(-t, Pn) : In(t, Pn)) + (e = e < 0 ? -In(-e, Pn) :
			In(e, Pn)))) / (3 * i)) && s <= 1 && (o[u++] = s)) : (t = (2 * r * n - 3 * i * l) / (2 * kn(r * r *
				r)), e = Math.acos(t) / 3, s = (-n - 2 * (l = kn(r)) * (t = Math.cos(e))) / (3 * i), a = (-n +
				l * (t + An * Math.sin(e))) / (3 * i), r = (-n + l * (t - An * Math.sin(e))) / (3 * i), 0 <=
			s && s <= 1 && (o[u++] = s), 0 <= a && a <= 1 && (o[u++] = a), 0 <= r && r <= 1 && (o[u++] = r)), u
	}

	function Vn(t, e, n, i, r) {
		var o, a = 6 * n - 12 * e + 6 * t,
			i = 9 * e + 3 * i - 3 * t - 9 * n,
			n = 3 * e - 3 * t,
			e = 0;
		return Nn(i) ? En(a) && 0 <= (o = -n / a) && o <= 1 && (r[e++] = o) : Nn(t = a * a - 4 * i * n) ? r[0] = -
			a / (2 * i) : 0 < t && (t = (-a - (n = kn(t))) / (2 * i), 0 <= (o = (-a + n) / (2 * i)) && o <= 1 && (r[
				e++] = o), 0 <= t) && t <= 1 && (r[e++] = t), e
	}

	function Hn(t, e, n, i, r, o) {
		var a = (e - t) * r + t,
			e = (n - e) * r + e,
			n = (i - n) * r + n,
			s = (e - a) * r + a,
			e = (n - e) * r + e,
			r = (e - s) * r + s;
		o[0] = t, o[1] = a, o[2] = s, o[3] = r, o[4] = r, o[5] = e, o[6] = n, o[7] = i
	}

	function Gn(t, e, n, i, r, o, a, s, l, u, h) {
		var c, p, d, f, g = .005,
			y = 1 / 0;
		Ln[0] = l, Ln[1] = u;
		for (var m = 0; m < 1; m += .05) On[0] = zn(t, n, r, a, m), On[1] = zn(e, i, o, s, m), (d = te(Ln, On)) <
			y && (c = m, y = d);
		for (var y = 1 / 0, v = 0; v < 32 && !(g < 1e-4); v++) p = c + g, On[0] = zn(t, n, r, a, f = c - g), On[1] =
			zn(e, i, o, s, f), d = te(On, Ln), 0 <= f && d < y ? (c = f, y = d) : (Rn[0] = zn(t, n, r, a, p), Rn[
				1] = zn(e, i, o, s, p), f = te(Rn, Ln), p <= 1 && f < y ? (c = p, y = f) : g *= .5);
		return h && (h[0] = zn(t, n, r, a, c), h[1] = zn(e, i, o, s, c)), kn(y)
	}

	function Wn(t, e, n, i) {
		var r = 1 - i;
		return r * (r * t + 2 * i * e) + i * i * n
	}

	function Un(t, e, n, i) {
		return 2 * ((1 - i) * (e - t) + i * (n - e))
	}

	function Xn(t, e, n) {
		n = t + n - 2 * e;
		return 0 == n ? .5 : (t - e) / n
	}

	function Yn(t, e, n, i, r) {
		var o = (e - t) * i + t,
			e = (n - e) * i + e,
			i = (e - o) * i + o;
		r[0] = t, r[1] = o, r[2] = i, r[3] = i, r[4] = e, r[5] = n
	}

	function qn(t, e, n, i, r, o, a, s, l) {
		var u, h = .005,
			c = 1 / 0;
		Ln[0] = a, Ln[1] = s;
		for (var p = 0; p < 1; p += .05) On[0] = Wn(t, n, r, p), On[1] = Wn(e, i, o, p), (y = te(Ln, On)) < c && (
			u = p, c = y);
		for (var c = 1 / 0, d = 0; d < 32 && !(h < 1e-4); d++) {
			var f = u - h,
				g = u + h,
				y = (On[0] = Wn(t, n, r, f), On[1] = Wn(e, i, o, f), te(On, Ln));
			0 <= f && y < c ? (u = f, c = y) : (Rn[0] = Wn(t, n, r, g), Rn[1] = Wn(e, i, o, g), f = te(Rn, Ln), g <=
				1 && f < c ? (u = g, c = f) : h *= .5)
		}
		return l && (l[0] = Wn(t, n, r, u), l[1] = Wn(e, i, o, u)), kn(c)
	}
	var jn = /cubic-bezier\(([0-9,\.e ]+)\)/;

	function Zn(t) {
		t = t && jn.exec(t);
		if (t) {
			var e, t = t[1].split(","),
				n = +It(t[0]),
				i = +It(t[1]),
				r = +It(t[2]),
				o = +It(t[3]);
			if (!isNaN(n + i + r + o)) return e = [],
				function(t) {
					return t <= 0 ? 0 : 1 <= t ? 1 : Fn(0, n, r, 1, t, e) && zn(0, i, o, 1, e[0])
				}
		}
	}
	$n.prototype.step = function(t, e) {
		if (this._inited || (this._startTime = t + this._delay, this._inited = !0), !this._paused) {
			var n = this._life,
				i = t - this._startTime - this._pausedTime,
				r = i / n,
				o = (r < 0 && (r = 0), r = Math.min(r, 1), this.easingFunc),
				o = o ? o(r) : r;
			if (this.onframe(o), 1 === r) {
				if (!this.loop) return !0;
				this._startTime = t - i % n, this._pausedTime = 0, this.onrestart()
			}
			return !1
		}
		this._pausedTime += e
	}, $n.prototype.pause = function() {
		this._paused = !0
	}, $n.prototype.resume = function() {
		this._paused = !1
	}, $n.prototype.setEasing = function(t) {
		this.easing = t, this.easingFunc = S(t) ? t : Cn[t] || Zn(t)
	};
	var Kn = $n;

	function $n(t) {
		this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3,
			this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || Vt, this.ondestroy = t
			.ondestroy || Vt, this.onrestart = t.onrestart || Vt, t.easing && this.setEasing(t.easing)
	}

	function Qn(t) {
		this.value = t
	}
	ti.prototype.insert = function(t) {
		t = new Qn(t);
		return this.insertEntry(t), t
	}, ti.prototype.insertEntry = function(t) {
		this.head ? ((this.tail.next = t).prev = this.tail, t.next = null, this.tail = t) : this.head = this
			.tail = t, this._len++
	}, ti.prototype.remove = function(t) {
		var e = t.prev,
			n = t.next;
		e ? e.next = n : this.head = n, n ? n.prev = e : this.tail = e, t.next = t.prev = null, this._len--
	}, ti.prototype.len = function() {
		return this._len
	}, ti.prototype.clear = function() {
		this.head = this.tail = null, this._len = 0
	};
	var Jn = ti;

	function ti() {
		this._len = 0
	}
	ni.prototype.put = function(t, e) {
		var n, i, r = this._list,
			o = this._map,
			a = null;
		return null == o[t] && (i = r.len(), n = this._lastRemovedEntry, i >= this._maxSize && 0 < i && (i = r
				.head, r.remove(i), delete o[i.key], a = i.value, this._lastRemovedEntry = i), n ? n.value =
			e : n = new Qn(e), n.key = t, r.insertEntry(n), o[t] = n), a
	}, ni.prototype.get = function(t) {
		var t = this._map[t],
			e = this._list;
		if (null != t) return t !== e.tail && (e.remove(t), e.insertEntry(t)), t.value
	}, ni.prototype.clear = function() {
		this._list.clear(), this._map = {}
	}, ni.prototype.len = function() {
		return this._list.len()
	};
	var ei = ni;

	function ni(t) {
		this._list = new Jn, this._maxSize = 10, this._map = {}, this._maxSize = t
	}
	var ii = {
		transparent: [0, 0, 0, 0],
		aliceblue: [240, 248, 255, 1],
		antiquewhite: [250, 235, 215, 1],
		aqua: [0, 255, 255, 1],
		aquamarine: [127, 255, 212, 1],
		azure: [240, 255, 255, 1],
		beige: [245, 245, 220, 1],
		bisque: [255, 228, 196, 1],
		black: [0, 0, 0, 1],
		blanchedalmond: [255, 235, 205, 1],
		blue: [0, 0, 255, 1],
		blueviolet: [138, 43, 226, 1],
		brown: [165, 42, 42, 1],
		burlywood: [222, 184, 135, 1],
		cadetblue: [95, 158, 160, 1],
		chartreuse: [127, 255, 0, 1],
		chocolate: [210, 105, 30, 1],
		coral: [255, 127, 80, 1],
		cornflowerblue: [100, 149, 237, 1],
		cornsilk: [255, 248, 220, 1],
		crimson: [220, 20, 60, 1],
		cyan: [0, 255, 255, 1],
		darkblue: [0, 0, 139, 1],
		darkcyan: [0, 139, 139, 1],
		darkgoldenrod: [184, 134, 11, 1],
		darkgray: [169, 169, 169, 1],
		darkgreen: [0, 100, 0, 1],
		darkgrey: [169, 169, 169, 1],
		darkkhaki: [189, 183, 107, 1],
		darkmagenta: [139, 0, 139, 1],
		darkolivegreen: [85, 107, 47, 1],
		darkorange: [255, 140, 0, 1],
		darkorchid: [153, 50, 204, 1],
		darkred: [139, 0, 0, 1],
		darksalmon: [233, 150, 122, 1],
		darkseagreen: [143, 188, 143, 1],
		darkslateblue: [72, 61, 139, 1],
		darkslategray: [47, 79, 79, 1],
		darkslategrey: [47, 79, 79, 1],
		darkturquoise: [0, 206, 209, 1],
		darkviolet: [148, 0, 211, 1],
		deeppink: [255, 20, 147, 1],
		deepskyblue: [0, 191, 255, 1],
		dimgray: [105, 105, 105, 1],
		dimgrey: [105, 105, 105, 1],
		dodgerblue: [30, 144, 255, 1],
		firebrick: [178, 34, 34, 1],
		floralwhite: [255, 250, 240, 1],
		forestgreen: [34, 139, 34, 1],
		fuchsia: [255, 0, 255, 1],
		gainsboro: [220, 220, 220, 1],
		ghostwhite: [248, 248, 255, 1],
		gold: [255, 215, 0, 1],
		goldenrod: [218, 165, 32, 1],
		gray: [128, 128, 128, 1],
		green: [0, 128, 0, 1],
		greenyellow: [173, 255, 47, 1],
		grey: [128, 128, 128, 1],
		honeydew: [240, 255, 240, 1],
		hotpink: [255, 105, 180, 1],
		indianred: [205, 92, 92, 1],
		indigo: [75, 0, 130, 1],
		ivory: [255, 255, 240, 1],
		khaki: [240, 230, 140, 1],
		lavender: [230, 230, 250, 1],
		lavenderblush: [255, 240, 245, 1],
		lawngreen: [124, 252, 0, 1],
		lemonchiffon: [255, 250, 205, 1],
		lightblue: [173, 216, 230, 1],
		lightcoral: [240, 128, 128, 1],
		lightcyan: [224, 255, 255, 1],
		lightgoldenrodyellow: [250, 250, 210, 1],
		lightgray: [211, 211, 211, 1],
		lightgreen: [144, 238, 144, 1],
		lightgrey: [211, 211, 211, 1],
		lightpink: [255, 182, 193, 1],
		lightsalmon: [255, 160, 122, 1],
		lightseagreen: [32, 178, 170, 1],
		lightskyblue: [135, 206, 250, 1],
		lightslategray: [119, 136, 153, 1],
		lightslategrey: [119, 136, 153, 1],
		lightsteelblue: [176, 196, 222, 1],
		lightyellow: [255, 255, 224, 1],
		lime: [0, 255, 0, 1],
		limegreen: [50, 205, 50, 1],
		linen: [250, 240, 230, 1],
		magenta: [255, 0, 255, 1],
		maroon: [128, 0, 0, 1],
		mediumaquamarine: [102, 205, 170, 1],
		mediumblue: [0, 0, 205, 1],
		mediumorchid: [186, 85, 211, 1],
		mediumpurple: [147, 112, 219, 1],
		mediumseagreen: [60, 179, 113, 1],
		mediumslateblue: [123, 104, 238, 1],
		mediumspringgreen: [0, 250, 154, 1],
		mediumturquoise: [72, 209, 204, 1],
		mediumvioletred: [199, 21, 133, 1],
		midnightblue: [25, 25, 112, 1],
		mintcream: [245, 255, 250, 1],
		mistyrose: [255, 228, 225, 1],
		moccasin: [255, 228, 181, 1],
		navajowhite: [255, 222, 173, 1],
		navy: [0, 0, 128, 1],
		oldlace: [253, 245, 230, 1],
		olive: [128, 128, 0, 1],
		olivedrab: [107, 142, 35, 1],
		orange: [255, 165, 0, 1],
		orangered: [255, 69, 0, 1],
		orchid: [218, 112, 214, 1],
		palegoldenrod: [238, 232, 170, 1],
		palegreen: [152, 251, 152, 1],
		paleturquoise: [175, 238, 238, 1],
		palevioletred: [219, 112, 147, 1],
		papayawhip: [255, 239, 213, 1],
		peachpuff: [255, 218, 185, 1],
		peru: [205, 133, 63, 1],
		pink: [255, 192, 203, 1],
		plum: [221, 160, 221, 1],
		powderblue: [176, 224, 230, 1],
		purple: [128, 0, 128, 1],
		red: [255, 0, 0, 1],
		rosybrown: [188, 143, 143, 1],
		royalblue: [65, 105, 225, 1],
		saddlebrown: [139, 69, 19, 1],
		salmon: [250, 128, 114, 1],
		sandybrown: [244, 164, 96, 1],
		seagreen: [46, 139, 87, 1],
		seashell: [255, 245, 238, 1],
		sienna: [160, 82, 45, 1],
		silver: [192, 192, 192, 1],
		skyblue: [135, 206, 235, 1],
		slateblue: [106, 90, 205, 1],
		slategray: [112, 128, 144, 1],
		slategrey: [112, 128, 144, 1],
		snow: [255, 250, 250, 1],
		springgreen: [0, 255, 127, 1],
		steelblue: [70, 130, 180, 1],
		tan: [210, 180, 140, 1],
		teal: [0, 128, 128, 1],
		thistle: [216, 191, 216, 1],
		tomato: [255, 99, 71, 1],
		turquoise: [64, 224, 208, 1],
		violet: [238, 130, 238, 1],
		wheat: [245, 222, 179, 1],
		white: [255, 255, 255, 1],
		whitesmoke: [245, 245, 245, 1],
		yellow: [255, 255, 0, 1],
		yellowgreen: [154, 205, 50, 1]
	};

	function ri(t) {
		return (t = Math.round(t)) < 0 ? 0 : 255 < t ? 255 : t
	}

	function oi(t) {
		return t < 0 ? 0 : 1 < t ? 1 : t
	}

	function ai(t) {
		return t.length && "%" === t.charAt(t.length - 1) ? ri(parseFloat(t) / 100 * 255) : ri(parseInt(t, 10))
	}

	function si(t) {
		return t.length && "%" === t.charAt(t.length - 1) ? oi(parseFloat(t) / 100) : oi(parseFloat(t))
	}

	function li(t, e, n) {
		return n < 0 ? n += 1 : 1 < n && --n, 6 * n < 1 ? t + (e - t) * n * 6 : 2 * n < 1 ? e : 3 * n < 2 ? t + (e -
			t) * (2 / 3 - n) * 6 : t
	}

	function ui(t, e, n) {
		return t + (e - t) * n
	}

	function hi(t, e, n, i, r) {
		return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t
	}

	function ci(t, e) {
		return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
	}
	var pi = new ei(20),
		di = null;

	function fi(t, e) {
		di && ci(di, e), di = pi.put(t, di || e.slice())
	}

	function gi(t, e) {
		if (t) {
			e = e || [];
			var n = pi.get(t);
			if (n) return ci(e, n);
			n = (t += "").replace(/ /g, "").toLowerCase();
			if (n in ii) return ci(e, ii[n]), fi(t, e), e;
			var i = n.length;
			if ("#" === n.charAt(0)) return 4 === i || 5 === i ? 0 <= (r = parseInt(n.slice(1, 4), 16)) && r <=
				4095 ? (hi(e, (3840 & r) >> 4 | (3840 & r) >> 8, 240 & r | (240 & r) >> 4, 15 & r | (15 & r) <<
					4, 5 === i ? parseInt(n.slice(4), 16) / 15 : 1), fi(t, e), e) : void hi(e, 0, 0, 0, 1) :
				7 === i || 9 === i ? 0 <= (r = parseInt(n.slice(1, 7), 16)) && r <= 16777215 ? (hi(e, (
						16711680 & r) >> 16, (65280 & r) >> 8, 255 & r, 9 === i ? parseInt(n.slice(7), 16) /
					255 : 1), fi(t, e), e) : void hi(e, 0, 0, 0, 1) : void 0;
			var r = n.indexOf("("),
				o = n.indexOf(")");
			if (-1 !== r && o + 1 === i) {
				var i = n.substr(0, r),
					a = n.substr(r + 1, o - (r + 1)).split(","),
					s = 1;
				switch (i) {
					case "rgba":
						if (4 !== a.length) return 3 === a.length ? hi(e, +a[0], +a[1], +a[2], 1) : hi(e, 0, 0, 0,
							1);
						s = si(a.pop());
					case "rgb":
						return 3 <= a.length ? (hi(e, ai(a[0]), ai(a[1]), ai(a[2]), 3 === a.length ? s : si(a[3])),
							fi(t, e), e) : void hi(e, 0, 0, 0, 1);
					case "hsla":
						return 4 !== a.length ? void hi(e, 0, 0, 0, 1) : (a[3] = si(a[3]), yi(a, e), fi(t, e), e);
					case "hsl":
						return 3 !== a.length ? void hi(e, 0, 0, 0, 1) : (yi(a, e), fi(t, e), e);
					default:
						return
				}
			}
			hi(e, 0, 0, 0, 1)
		}
	}

	function yi(t, e) {
		var n = (parseFloat(t[0]) % 360 + 360) % 360 / 360,
			i = si(t[1]),
			r = si(t[2]),
			i = r <= .5 ? r * (i + 1) : r + i - r * i,
			r = 2 * r - i;
		return hi(e = e || [], ri(255 * li(r, i, n + 1 / 3)), ri(255 * li(r, i, n)), ri(255 * li(r, i, n - 1 / 3)),
			1), 4 === t.length && (e[3] = t[3]), e
	}

	function mi(t, e) {
		var n = gi(t);
		if (n) {
			for (var i = 0; i < 3; i++) n[i] = e < 0 ? n[i] * (1 - e) | 0 : (255 - n[i]) * e + n[i] | 0, 255 < n[
				i] ? n[i] = 255 : n[i] < 0 && (n[i] = 0);
			return xi(n, 4 === n.length ? "rgba" : "rgb")
		}
	}

	function vi(t, e, n) {
		var i, r, o;
		if (e && e.length && 0 <= t && t <= 1) return n = n || [], t = t * (e.length - 1), i = Math.floor(t), o =
			Math.ceil(t), r = e[i], e = e[o], n[0] = ri(ui(r[0], e[0], o = t - i)), n[1] = ri(ui(r[1], e[1],
				o)), n[2] = ri(ui(r[2], e[2], o)), n[3] = oi(ui(r[3], e[3], o)), n
	}

	function _i(t, e, n) {
		var i, r, o, a;
		if (e && e.length && 0 <= t && t <= 1) return t = t * (e.length - 1), i = Math.floor(t), r = Math.ceil(t),
			a = gi(e[i]), e = gi(e[r]), a = xi([ri(ui(a[0], e[0], o = t - i)), ri(ui(a[1], e[1], o)), ri(ui(a[
				2], e[2], o)), oi(ui(a[3], e[3], o))], "rgba"), n ? {
				color: a,
				leftIndex: i,
				rightIndex: r,
				value: t
			} : a
	}

	function xi(t, e) {
		var n;
		if (t && t.length) return n = t[0] + "," + t[1] + "," + t[2], "rgba" !== e && "hsva" !== e && "hsla" !==
			e || (n += "," + t[3]), e + "(" + n + ")"
	}

	function wi(t, e) {
		t = gi(t);
		return t ? (.299 * t[0] + .587 * t[1] + .114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0
	}
	var bi = Object.freeze({
			__proto__: null,
			fastLerp: vi,
			fastMapToColor: vi,
			lerp: _i,
			lift: mi,
			lum: wi,
			mapToColor: _i,
			modifyAlpha: function(t, e) {
				if ((t = gi(t)) && null != e) return t[3] = oi(e), xi(t, "rgba")
			},
			modifyHSL: function(t, e, n, i) {
				var r = gi(t);
				if (t) return r = function(t) {
					var e, n, i, r, o, a, s, l, u, h;
					if (t) return h = t[0] / 255, n = t[1] / 255, i = t[2] / 255, s = Math.min(h, n,
							i), o = ((r = Math.max(h, n, i)) + s) / 2, 0 == (u = r - s) ? a =
						e = 0 : (a = o < .5 ? u / (r + s) : u / (2 - r - s), s = ((r - h) / 6 +
								u / 2) / u, l = ((r - n) / 6 + u / 2) / u, u = ((r - i) / 6 +
								u / 2) / u, h === r ? e = u - l : n === r ? e = 1 / 3 + s - u :
							i === r && (e = 2 / 3 + l - s), e < 0 && (e += 1), 1 < e && --e),
						h = [360 * e, a, o], null != t[3] && h.push(t[3]), h
				}(r), null != e && (r[0] = (t = e, (t = Math.round(t)) < 0 ? 0 : 360 < t ? 360 :
					t)), null != n && (r[1] = si(n)), null != i && (r[2] = si(i)), xi(yi(r), "rgba")
			},
			parse: gi,
			random: function() {
				return xi([Math.round(255 * Math.random()), Math.round(255 * Math.random()), Math.round(
					255 * Math.random())], "rgb")
			},
			stringify: xi,
			toHex: function(t) {
				if (t = gi(t)) return ((1 << 24) + (t[0] << 16) + (t[1] << 8) + +t[2]).toString(16).slice(1)
			}
		}),
		Si = Math.round;

	function Mi(t) {
		var e, n;
		return t && "transparent" !== t ? "string" == typeof t && -1 < t.indexOf("rgba") && (n = gi(t)) && (t =
			"rgb(" + n[0] + "," + n[1] + "," + n[2] + ")", e = n[3]) : t = "none", {
			color: t,
			opacity: null == e ? 1 : e
		}
	}

	function Ti(t) {
		return t < 1e-4 && -1e-4 < t
	}

	function Ci(t) {
		return Si(1e3 * t) / 1e3
	}

	function Ii(t) {
		return Si(1e4 * t) / 1e4
	}
	var ki = {
		left: "start",
		right: "end",
		center: "middle",
		middle: "middle"
	};

	function Di(t) {
		return t && !!t.image
	}

	function Ai(t) {
		return Di(t) || (t = t) && !!t.svgElement
	}

	function Pi(t) {
		return "linear" === t.type
	}

	function Li(t) {
		return "radial" === t.type
	}

	function Oi(t) {
		return t && ("linear" === t.type || "radial" === t.type)
	}

	function Ri(t) {
		return "url(#" + t + ")"
	}

	function Ni(t) {
		t = t.getGlobalScale(), t = Math.max(t[0], t[1]);
		return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1)
	}

	function Ei(t) {
		var e = t.x || 0,
			n = t.y || 0,
			i = (t.rotation || 0) * Ht,
			r = N(t.scaleX, 1),
			o = N(t.scaleY, 1),
			a = t.skewX || 0,
			t = t.skewY || 0,
			s = [];
		return (e || n) && s.push("translate(" + e + "px," + n + "px)"), i && s.push("rotate(" + i + ")"), 1 ===
			r && 1 === o || s.push("scale(" + r + "," + o + ")"), (a || t) && s.push("skew(" + Si(a * Ht) +
				"deg, " + Si(t * Ht) + "deg)"), s.join(" ")
	}
	var zi = b.hasGlobalWindow && S(window.btoa) ? function(t) {
			return window.btoa(unescape(encodeURIComponent(t)))
		} : "undefined" != typeof Buffer ? function(t) {
			return Buffer.from(t).toString("base64")
		} : function(t) {
			return null
		},
		Bi = Array.prototype.slice;

	function Fi(t, e, n) {
		return (e - t) * n + t
	}

	function Vi(t, e, n, i) {
		for (var r = e.length, o = 0; o < r; o++) t[o] = Fi(e[o], n[o], i);
		return t
	}

	function Hi(t, e, n, i) {
		for (var r = e.length, o = 0; o < r; o++) t[o] = e[o] + n[o] * i;
		return t
	}

	function Gi(t, e, n, i) {
		for (var r = e.length, o = r && e[0].length, a = 0; a < r; a++) {
			t[a] || (t[a] = []);
			for (var s = 0; s < o; s++) t[a][s] = e[a][s] + n[a][s] * i
		}
		return t
	}

	function Wi(t) {
		if (ut(t)) {
			var e = t.length;
			if (ut(t[0])) {
				for (var n = [], i = 0; i < e; i++) n.push(Bi.call(t[i]));
				return n
			}
			return Bi.call(t)
		}
		return t
	}

	function Ui(t) {
		return t[0] = Math.floor(t[0]) || 0, t[1] = Math.floor(t[1]) || 0, t[2] = Math.floor(t[2]) || 0, t[3] =
			null == t[3] ? 1 : t[3], "rgba(" + t.join(",") + ")"
	}

	function Xi(t) {
		return 4 === t || 5 === t
	}

	function Yi(t) {
		return 1 === t || 2 === t
	}
	var qi = [0, 0, 0, 0],
		ji = ($i.prototype.isFinished = function() {
			return this._finished
		}, $i.prototype.setFinished = function() {
			this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished()
		}, $i.prototype.needsAnimate = function() {
			return 1 <= this.keyframes.length
		}, $i.prototype.getAdditiveTrack = function() {
			return this._additiveTrack
		}, $i.prototype.addKeyframe = function(t, e, n) {
			this._needsSort = !0;
			var i, r = this.keyframes,
				o = r.length,
				a = !1,
				s = 6,
				l = e,
				u = (ut(e) ? (1 == (s = i = ut((i = e) && i[0]) ? 2 : 1) && !G(e[0]) || 2 == i && !G(e[0][
						0
					])) && (a = !0) : G(e) && !wt(e) ? s = 0 : H(e) ? isNaN(+e) ? (i = gi(e)) && (l = i, s =
						3) : s = 0 : vt(e) && ((u = O({}, l)).colorStops = F(e.colorStops, function(t) {
						return {
							offset: t.offset,
							color: gi(t.color)
						}
					}), Pi(e) ? s = 4 : Li(e) && (s = 5), l = u), 0 === o ? this.valType = s : s === this
					.valType && 6 !== s || (a = !0), this.discrete = this.discrete || a, {
						time: t,
						value: l,
						rawValue: e,
						percent: 0
					});
			return n && (u.easing = n, u.easingFunc = S(n) ? n : Cn[n] || Zn(n)), r.push(u), u
		}, $i.prototype.prepare = function(t, e) {
			var n = this.keyframes;
			this._needsSort && n.sort(function(t, e) {
				return t.time - e.time
			});
			for (var i = this.valType, r = n.length, o = n[r - 1], a = this.discrete, s = Yi(i), l = Xi(i), u =
					0; u < r; u++) {
				var h = n[u],
					c = h.value,
					p = o.value;
				if (h.percent = h.time / t, !a)
					if (s && u !== r - 1) {
						h = void 0;
						d = void 0;
						f = void 0;
						g = void 0;
						y = void 0;
						m = void 0;
						v = void 0;
						_ = void 0;
						x = void 0;
						h = c;
						var d = p;
						var f = i;
						var g = h,
							y = d;
						if (g.push && y.push) {
							var h = g.length,
								m = y.length;
							if (h !== m)
								if (m < h) g.length = m;
								else
									for (var v = h; v < m; v++) g.push(1 === f ? y[v] : Bi.call(y[v]));
							for (var _ = g[0] && g[0].length, v = 0; v < g.length; v++)
								if (1 === f) isNaN(g[v]) && (g[v] = y[v]);
								else
									for (var x = 0; x < _; x++) isNaN(g[v][x]) && (g[v][x] = y[v][x])
						}
					} else if (l) {
					d = void 0;
					h = void 0;
					w = void 0;
					b = void 0;
					S = void 0;
					M = void 0;
					T = void 0;
					d = c.colorStops;
					h = p.colorStops;
					for (var w = d.length, b = h.length, S = b < w ? h : d, h = Math.min(w, b), M = S[h - 1] ||
						{
							color: [0, 0, 0, 0],
							offset: 0
						}, T = h; T < Math.max(w, b); T++) S.push({
						offset: M.offset,
						color: M.color.slice()
					})
				}
			}
			if (!a && 5 !== i && e && this.needsAnimate() && e.needsAnimate() && i === e.valType && !e
				._finished) {
				this._additiveTrack = e;
				for (var C = n[0].value, u = 0; u < r; u++) 0 === i ? n[u].additiveValue = n[u].value - C :
					3 === i ? n[u].additiveValue = Hi([], n[u].value, C, -1) : Yi(i) && (n[u].additiveValue = (
						1 === i ? Hi : Gi)([], n[u].value, C, -1))
			}
		}, $i.prototype.step = function(t, e) {
			if (!this._finished) {
				this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
				var n, i, r, o, a, s = null != this._additiveTrack,
					l = s ? "additiveValue" : "value",
					u = this.valType,
					h = this.keyframes,
					c = h.length,
					p = this.propName,
					d = 3 === u,
					f = this._lastFr,
					g = Math.min;
				if (1 === c) i = r = h[0];
				else {
					if (e < 0) n = 0;
					else if (e < this._lastFrP) {
						for (n = g(f + 1, c - 1); 0 <= n && !(h[n].percent <= e); n--);
						n = g(n, c - 2)
					} else {
						for (n = f; n < c && !(h[n].percent > e); n++);
						n = g(n - 1, c - 2)
					}
					r = h[n + 1], i = h[n]
				}
				i && r && (this._lastFr = n, this._lastFrP = e, f = r.percent - i.percent, o = 0 == f ? 1 : g((
						e - i.percent) / f, 1), r.easingFunc && (o = r.easingFunc(o)), g = s ? this
					._additiveValue : d ? qi : t[p], (Yi(u) || d) && (g = g || (this._additiveValue = [])),
					this.discrete ? t[p] = (o < 1 ? i : r).rawValue : Yi(u) ? (1 === u ? Vi : function(t, e,
						n, i) {
						for (var r = e.length, o = r && e[0].length, a = 0; a < r; a++) {
							t[a] || (t[a] = []);
							for (var s = 0; s < o; s++) t[a][s] = Fi(e[a][s], n[a][s], i)
						}
					})(g, i[l], r[l], o) : Xi(u) ? (f = i[l], a = r[l], t[p] = {
						type: (u = 4 === u) ? "linear" : "radial",
						x: Fi(f.x, a.x, o),
						y: Fi(f.y, a.y, o),
						colorStops: F(f.colorStops, function(t, e) {
							e = a.colorStops[e];
							return {
								offset: Fi(t.offset, e.offset, o),
								color: Ui(Vi([], t.color, e.color, o))
							}
						}),
						global: a.global
					}, u ? (t[p].x2 = Fi(f.x2, a.x2, o), t[p].y2 = Fi(f.y2, a.y2, o)) : t[p].r = Fi(f.r,
						a.r, o)) : d ? (Vi(g, i[l], r[l], o), s || (t[p] = Ui(g))) : (u = Fi(i[l], r[l], o),
						s ? this._additiveValue = u : t[p] = u), s) && this._addToTarget(t)
			}
		}, $i.prototype._addToTarget = function(t) {
			var e = this.valType,
				n = this.propName,
				i = this._additiveValue;
			0 === e ? t[n] = t[n] + i : 3 === e ? (gi(t[n], qi), Hi(qi, qi, i, 1), t[n] = Ui(qi)) : 1 === e ?
				Hi(t[n], t[n], i, 1) : 2 === e && Gi(t[n], t[n], i, 1)
		}, $i),
		Zi = (Ki.prototype.getMaxTime = function() {
			return this._maxTime
		}, Ki.prototype.getDelay = function() {
			return this._delay
		}, Ki.prototype.getLoop = function() {
			return this._loop
		}, Ki.prototype.getTarget = function() {
			return this._target
		}, Ki.prototype.changeTarget = function(t) {
			this._target = t
		}, Ki.prototype.when = function(t, e, n) {
			return this.whenWithKeys(t, e, R(e), n)
		}, Ki.prototype.whenWithKeys = function(t, e, n, i) {
			for (var r = this._tracks, o = 0; o < n.length; o++) {
				var a = n[o];
				if (!(l = r[a])) {
					var s, l = r[a] = new ji(a),
						u = void 0,
						h = this._getAdditiveTrack(a);
					if (h ? (u = (s = (s = h.keyframes)[s.length - 1]) && s.value, 3 === h.valType && (u = u &&
							Ui(u))) : u = this._target[a], null == u) continue;
					0 < t && l.addKeyframe(0, Wi(u), i), this._trackKeys.push(a)
				}
				l.addKeyframe(t, Wi(e[a]), i)
			}
			return this._maxTime = Math.max(this._maxTime, t), this
		}, Ki.prototype.pause = function() {
			this._clip.pause(), this._paused = !0
		}, Ki.prototype.resume = function() {
			this._clip.resume(), this._paused = !1
		}, Ki.prototype.isPaused = function() {
			return !!this._paused
		}, Ki.prototype.duration = function(t) {
			return this._maxTime = t, this._force = !0, this
		}, Ki.prototype._doneCallback = function() {
			this._setTracksFinished(), this._clip = null;
			var t = this._doneCbs;
			if (t)
				for (var e = t.length, n = 0; n < e; n++) t[n].call(this)
		}, Ki.prototype._abortedCallback = function() {
			this._setTracksFinished();
			var t = this.animation,
				e = this._abortedCbs;
			if (t && t.removeClip(this._clip), this._clip = null, e)
				for (var n = 0; n < e.length; n++) e[n].call(this)
		}, Ki.prototype._setTracksFinished = function() {
			for (var t = this._tracks, e = this._trackKeys, n = 0; n < e.length; n++) t[e[n]].setFinished()
		}, Ki.prototype._getAdditiveTrack = function(t) {
			var e, n = this._additiveAnimators;
			if (n)
				for (var i = 0; i < n.length; i++) {
					var r = n[i].getTrack(t);
					r && (e = r)
				}
			return e
		}, Ki.prototype.start = function(t) {
			if (!(0 < this._started)) {
				this._started = 1;
				for (var e, o = this, a = [], n = this._maxTime || 0, i = 0; i < this._trackKeys.length; i++) {
					var r = this._trackKeys[i],
						s = this._tracks[r],
						r = this._getAdditiveTrack(r),
						l = s.keyframes,
						u = l.length;
					s.prepare(n, r), s.needsAnimate() && (!this._allowDiscrete && s.discrete ? ((r = l[u -
						1]) && (o._target[s.propName] = r.rawValue), s.setFinished()) : a.push(s))
				}
				return a.length || this._force ? (e = new Kn({
						life: n,
						loop: this._loop,
						delay: this._delay || 0,
						onframe: function(t) {
							o._started = 2;
							var e = o._additiveAnimators;
							if (e) {
								for (var n = !1, i = 0; i < e.length; i++)
									if (e[i]._clip) {
										n = !0;
										break
									} n || (o._additiveAnimators = null)
							}
							for (i = 0; i < a.length; i++) a[i].step(o._target, t);
							var r = o._onframeCbs;
							if (r)
								for (i = 0; i < r.length; i++) r[i](o._target, t)
						},
						ondestroy: function() {
							o._doneCallback()
						}
					}), this._clip = e, this.animation && this.animation.addClip(e), t && e.setEasing(t)) : this
					._doneCallback(), this
			}
		}, Ki.prototype.stop = function(t) {
			var e;
			this._clip && (e = this._clip, t && e.onframe(1), this._abortedCallback())
		}, Ki.prototype.delay = function(t) {
			return this._delay = t, this
		}, Ki.prototype.during = function(t) {
			return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this
		}, Ki.prototype.done = function(t) {
			return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this
		}, Ki.prototype.aborted = function(t) {
			return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this
		}, Ki.prototype.getClip = function() {
			return this._clip
		}, Ki.prototype.getTrack = function(t) {
			return this._tracks[t]
		}, Ki.prototype.getTracks = function() {
			var e = this;
			return F(this._trackKeys, function(t) {
				return e._tracks[t]
			})
		}, Ki.prototype.stopTracks = function(t, e) {
			if (!t.length || !this._clip) return !0;
			for (var n = this._tracks, i = this._trackKeys, r = 0; r < t.length; r++) {
				var o = n[t[r]];
				o && !o.isFinished() && (e ? o.step(this._target, 1) : 1 === this._started && o.step(this
					._target, 0), o.setFinished())
			}
			for (var a = !0, r = 0; r < i.length; r++)
				if (!n[i[r]].isFinished()) {
					a = !1;
					break
				} return a && this._abortedCallback(), a
		}, Ki.prototype.saveTo = function(t, e, n) {
			if (t) {
				e = e || this._trackKeys;
				for (var i = 0; i < e.length; i++) {
					var r = e[i],
						o = this._tracks[r];
					o && !o.isFinished() && (o = (o = o.keyframes)[n ? 0 : o.length - 1]) && (t[r] = Wi(o
						.rawValue))
				}
			}
		}, Ki.prototype.__changeFinalValue = function(t, e) {
			e = e || R(t);
			for (var n = 0; n < e.length; n++) {
				var i, r = e[n],
					o = this._tracks[r];
				o && 1 < (i = o.keyframes).length && (i = i.pop(), o.addKeyframe(i.time, t[r]), o.prepare(this
					._maxTime, o.getAdditiveTrack()))
			}
		}, Ki);

	function Ki(t, e, n, i) {
		this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this
			._target = t, (this._loop = e) && i ? ot("Can' use additive animation on looped animation.") : (this
				._additiveAnimators = i, this._allowDiscrete = n)
	}

	function $i(t) {
		this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this
			._lastFrP = 0, this.propName = t
	}

	function Qi() {
		return (new Date).getTime()
	}
	u(er, Ji = ue), er.prototype.addClip = function(t) {
		t.animation && this.removeClip(t), this._head ? ((this._tail.next = t).prev = this._tail, t.next = null,
			this._tail = t) : this._head = this._tail = t, t.animation = this
	}, er.prototype.addAnimator = function(t) {
		t.animation = this;
		t = t.getClip();
		t && this.addClip(t)
	}, er.prototype.removeClip = function(t) {
		var e, n;
		t.animation && (e = t.prev, n = t.next, e ? e.next = n : this._head = n, n ? n.prev = e : this._tail =
			e, t.next = t.prev = t.animation = null)
	}, er.prototype.removeAnimator = function(t) {
		var e = t.getClip();
		e && this.removeClip(e), t.animation = null
	}, er.prototype.update = function(t) {
		for (var e = Qi() - this._pausedTime, n = e - this._time, i = this._head; i;) var r = i.next,
			i = (i.step(e, n) && (i.ondestroy(), this.removeClip(i)), r);
		this._time = e, t || (this.trigger("frame", n), this.stage.update && this.stage.update())
	}, er.prototype._startLoop = function() {
		var e = this;
		this._running = !0, Tn(function t() {
			e._running && (Tn(t), !e._paused) && e.update()
		})
	}, er.prototype.start = function() {
		this._running || (this._time = Qi(), this._pausedTime = 0, this._startLoop())
	}, er.prototype.stop = function() {
		this._running = !1
	}, er.prototype.pause = function() {
		this._paused || (this._pauseStart = Qi(), this._paused = !0)
	}, er.prototype.resume = function() {
		this._paused && (this._pausedTime += Qi() - this._pauseStart, this._paused = !1)
	}, er.prototype.clear = function() {
		for (var t = this._head; t;) {
			var e = t.next;
			t.prev = t.next = t.animation = null, t = e
		}
		this._head = this._tail = null
	}, er.prototype.isFinished = function() {
		return null == this._head
	}, er.prototype.animate = function(t, e) {
		e = e || {}, this.start();
		t = new Zi(t, e.loop);
		return this.addAnimator(t), t
	};
	var Ji, tr = er;

	function er(t) {
		var e = Ji.call(this) || this;
		return e._running = !1, e._time = 0, e._pausedTime = 0, e._pauseStart = 0, e._paused = !1, e.stage = (t =
			t || {}).stage || {}, e
	}
	var nr, ir = b.domSupported,
		rr = (nr = {
			pointerdown: 1,
			pointerup: 1,
			pointermove: 1,
			pointerout: 1
		}, {
			mouse: n = ["click", "dblclick", "mousewheel", "wheel", "mouseout", "mouseup", "mousedown",
				"mousemove", "contextmenu"
			],
			touch: ["touchstart", "touchend", "touchmove"],
			pointer: F(n, function(t) {
				var e = t.replace("mouse", "pointer");
				return nr.hasOwnProperty(e) ? e : t
			})
		}),
		or = ["mousemove", "mouseup"],
		ar = ["pointermove", "pointerup"],
		sr = !1;

	function lr(t) {
		t = t.pointerType;
		return "pen" === t || "touch" === t
	}

	function ur(t) {
		t && (t.zrByTouch = !0)
	}

	function hr(t, e) {
		for (var n = e, i = !1; n && 9 !== n.nodeType && !(i = n.domBelongToZr || n !== e && n === t.painterRoot);)
			n = n.parentNode;
		return i
	}
	var cr = function(t, e) {
			this.stopPropagation = Vt, this.stopImmediatePropagation = Vt, this.preventDefault = Vt, this.type = e
				.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e
				.clientX, this.clientY = e.clientY
		},
		pr = {
			mousedown: function(t) {
				t = Ie(this.dom, t), this.__mayPointerCapture = [t.zrX, t.zrY], this.trigger("mousedown", t)
			},
			mousemove: function(t) {
				t = Ie(this.dom, t);
				var e = this.__mayPointerCapture;
				!e || t.zrX === e[0] && t.zrY === e[1] || this.__togglePointerCapture(!0), this.trigger(
					"mousemove", t)
			},
			mouseup: function(t) {
				t = Ie(this.dom, t), this.__togglePointerCapture(!1), this.trigger("mouseup", t)
			},
			mouseout: function(t) {
				hr(this, (t = Ie(this.dom, t)).toElement || t.relatedTarget) || (this.__pointerCapturing && (t
					.zrEventControl = "no_globalout"), this.trigger("mouseout", t))
			},
			wheel: function(t) {
				sr = !0, t = Ie(this.dom, t), this.trigger("mousewheel", t)
			},
			mousewheel: function(t) {
				sr || (t = Ie(this.dom, t), this.trigger("mousewheel", t))
			},
			touchstart: function(t) {
				ur(t = Ie(this.dom, t)), this.__lastTouchMoment = new Date, this.handler.processGesture(t,
					"start"), pr.mousemove.call(this, t), pr.mousedown.call(this, t)
			},
			touchmove: function(t) {
				ur(t = Ie(this.dom, t)), this.handler.processGesture(t, "change"), pr.mousemove.call(this, t)
			},
			touchend: function(t) {
				ur(t = Ie(this.dom, t)), this.handler.processGesture(t, "end"), pr.mouseup.call(this, t), +
					new Date - +this.__lastTouchMoment < 300 && pr.click.call(this, t)
			},
			pointerdown: function(t) {
				pr.mousedown.call(this, t)
			},
			pointermove: function(t) {
				lr(t) || pr.mousemove.call(this, t)
			},
			pointerup: function(t) {
				pr.mouseup.call(this, t)
			},
			pointerout: function(t) {
				lr(t) || pr.mouseout.call(this, t)
			}
		},
		dr = (E(["click", "dblclick", "contextmenu"], function(e) {
			pr[e] = function(t) {
				t = Ie(this.dom, t), this.trigger(e, t)
			}
		}), {
			pointermove: function(t) {
				lr(t) || dr.mousemove.call(this, t)
			},
			pointerup: function(t) {
				dr.mouseup.call(this, t)
			},
			mousemove: function(t) {
				this.trigger("mousemove", t)
			},
			mouseup: function(t) {
				var e = this.__pointerCapturing;
				this.__togglePointerCapture(!1), this.trigger("mouseup", t), e && (t.zrEventControl =
					"only_globalout", this.trigger("mouseout", t))
			}
		});

	function fr(i, r) {
		var o = r.domHandlers;
		b.pointerEventsSupported ? E(rr.pointer, function(e) {
			yr(r, e, function(t) {
				o[e].call(i, t)
			})
		}) : (b.touchEventsSupported && E(rr.touch, function(n) {
			yr(r, n, function(t) {
				var e;
				o[n].call(i, t), (e = r).touching = !0, null != e.touchTimer && (clearTimeout(e
					.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(
					function() {
						e.touching = !1, e.touchTimer = null
					}, 700)
			})
		}), E(rr.mouse, function(e) {
			yr(r, e, function(t) {
				t = Ce(t), r.touching || o[e].call(i, t)
			})
		}))
	}

	function gr(i, r) {
		function t(n) {
			yr(r, n, function(t) {
				var e;
				t = Ce(t), hr(i, t.target) || (e = t, t = Ie(i.dom, new cr(i, e), !0), r.domHandlers[n]
					.call(i, t))
			}, {
				capture: !0
			})
		}
		b.pointerEventsSupported ? E(ar, t) : b.touchEventsSupported || E(or, t)
	}

	function yr(t, e, n, i) {
		t.mounted[e] = n, t.listenerOpts[e] = i, t.domTarget.addEventListener(e, n, i)
	}

	function mr(t) {
		var e, n, i, r, o, a = t.mounted;
		for (e in a) a.hasOwnProperty(e) && (n = t.domTarget, i = e, r = a[e], o = t.listenerOpts[e], n
			.removeEventListener(i, r, o));
		t.mounted = {}
	}

	function vr(t, e) {
		this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = e
	}
	u(wr, _r = ue), wr.prototype.dispose = function() {
		mr(this._localHandlerScope), ir && mr(this._globalHandlerScope)
	}, wr.prototype.setCursor = function(t) {
		this.dom.style && (this.dom.style.cursor = t || "default")
	}, wr.prototype.__togglePointerCapture = function(t) {
		var e;
		this.__mayPointerCapture = null, ir && +this.__pointerCapturing ^ +t && (this.__pointerCapturing = t,
			e = this._globalHandlerScope, t ? gr(this, e) : mr(e))
	};
	var _r, xr = wr;

	function wr(t, e) {
		var n = _r.call(this) || this;
		return n.__pointerCapturing = !1, n.dom = t, n.painterRoot = e, n._localHandlerScope = new vr(t, pr), ir &&
			(n._globalHandlerScope = new vr(document, dr)), fr(n, n._localHandlerScope), n
	}
	var n = 1,
		br = n = b.hasGlobalWindow ? Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI /
			window.screen.logicalXDPI || 1, 1) : n,
		Sr = "#333",
		Mr = "#ccc",
		Tr = Re;

	function Cr(t) {
		return 5e-5 < t || t < -5e-5
	}
	var Ir = [],
		kr = [],
		Dr = Oe(),
		Ar = Math.abs,
		Pr = (Lr.prototype.getLocalTransform = function(t) {
			return Lr.getLocalTransform(this, t)
		}, Lr.prototype.setPosition = function(t) {
			this.x = t[0], this.y = t[1]
		}, Lr.prototype.setScale = function(t) {
			this.scaleX = t[0], this.scaleY = t[1]
		}, Lr.prototype.setSkew = function(t) {
			this.skewX = t[0], this.skewY = t[1]
		}, Lr.prototype.setOrigin = function(t) {
			this.originX = t[0], this.originY = t[1]
		}, Lr.prototype.needLocalTransform = function() {
			return Cr(this.rotation) || Cr(this.x) || Cr(this.y) || Cr(this.scaleX - 1) || Cr(this.scaleY -
				1) || Cr(this.skewX) || Cr(this.skewY)
		}, Lr.prototype.updateTransform = function() {
			var t = this.parent && this.parent.transform,
				e = this.needLocalTransform(),
				n = this.transform;
			e || t ? (n = n || Oe(), e ? this.getLocalTransform(n) : Tr(n), t && (e ? Ee(n, t, n) : Ne(n, t)),
				this.transform = n, this._resolveGlobalScaleRatio(n)) : n && (Tr(n), this.invTransform =
				null)
		}, Lr.prototype._resolveGlobalScaleRatio = function(t) {
			var e, n, i = this.globalScaleRatio;
			null != i && 1 !== i && (this.getGlobalScale(Ir), n = ((Ir[1] - (n = Ir[1] < 0 ? -1 : 1)) * i + n) /
				Ir[1] || 0, t[0] *= i = ((Ir[0] - (e = Ir[0] < 0 ? -1 : 1)) * i + e) / Ir[0] || 0, t[1] *=
				i, t[2] *= n, t[3] *= n), this.invTransform = this.invTransform || Oe(), Ve(this
				.invTransform, t)
		}, Lr.prototype.getComputedTransform = function() {
			for (var t = this, e = []; t;) e.push(t), t = t.parent;
			for (; t = e.pop();) t.updateTransform();
			return this.transform
		}, Lr.prototype.setLocalTransform = function(t) {
			var e, n, i, r;
			t && (r = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], e = Math.atan2(t[1], t[0]), n =
				Math.PI / 2 + e - Math.atan2(t[3], t[2]), i = Math.sqrt(i) * Math.cos(n), r = Math.sqrt(r),
				this.skewX = n, this.skewY = 0, this.rotation = -e, this.x = +t[4], this.y = +t[5], this
				.scaleX = r, this.scaleY = i, this.originX = 0, this.originY = 0)
		}, Lr.prototype.decomposeTransform = function() {
			var t, e, n;
			this.transform && (e = this.parent, t = this.transform, e && e.transform && (Ee(kr, e.invTransform,
				t), t = kr), e = this.originX, n = this.originY, (e || n) && (Dr[4] = e, Dr[5] = n, Ee(
				kr, t, Dr), kr[4] -= e, kr[5] -= n, t = kr), this.setLocalTransform(t))
		}, Lr.prototype.getGlobalScale = function(t) {
			var e = this.transform;
			return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] +
				e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1])) : (t[0] = 1, t[1] =
				1), t
		}, Lr.prototype.transformCoordToLocal = function(t, e) {
			t = [t, e], e = this.invTransform;
			return e && ne(t, t, e), t
		}, Lr.prototype.transformCoordToGlobal = function(t, e) {
			t = [t, e], e = this.transform;
			return e && ne(t, t, e), t
		}, Lr.prototype.getLineScale = function() {
			var t = this.transform;
			return t && 1e-10 < Ar(t[0] - 1) && 1e-10 < Ar(t[3] - 1) ? Math.sqrt(Ar(t[0] * t[3] - t[2] * t[
				1])) : 1
		}, Lr.prototype.copyTransform = function(t) {
			Rr(this, t)
		}, Lr.getLocalTransform = function(t, e) {
			e = e || [];
			var n = t.originX || 0,
				i = t.originY || 0,
				r = t.scaleX,
				o = t.scaleY,
				a = t.anchorX,
				s = t.anchorY,
				l = t.rotation || 0,
				u = t.x,
				h = t.y,
				c = t.skewX ? Math.tan(t.skewX) : 0,
				t = t.skewY ? Math.tan(-t.skewY) : 0;
			return n || i || a || s ? (e[4] = -(a = n + a) * r - c * (s = i + s) * o, e[5] = -s * o - t * a *
					r) : e[4] = e[5] = 0, e[0] = r, e[3] = o, e[1] = t * r, e[2] = c * o, l && Be(e, e, l), e[
					4] +=
				n + u, e[5] += i + h, e
		}, Lr.initDefaultProps = ((n = Lr.prototype).scaleX = n.scaleY = n.globalScaleRatio = 1, void(n.x = n
			.y = n.originX = n.originY = n.skewX = n.skewY = n.rotation = n.anchorX = n.anchorY = 0)), Lr);

	function Lr() {}
	var Or = ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX",
		"skewY"
	];

	function Rr(t, e) {
		for (var n = 0; n < Or.length; n++) {
			var i = Or[n];
			t[i] = e[i]
		}
	}
	var Nr = {};

	function Er(t, e) {
		var n = Nr[e = e || K],
			i = (n = n || (Nr[e] = new ei(500))).get(t);
		return null == i && (i = X.measureText(t, e).width, n.put(t, i)), i
	}

	function zr(t, e, n, i) {
		t = Er(t, e), e = Hr(e), n = Fr(0, t, n), i = Vr(0, e, i);
		return new U(n, i, t, e)
	}

	function Br(t, e, n, i) {
		var r = ((t || "") + "").split("\n");
		if (1 === r.length) return zr(r[0], e, n, i);
		for (var o = new U(0, 0, 0, 0), a = 0; a < r.length; a++) {
			var s = zr(r[a], e, n, i);
			0 === a ? o.copy(s) : o.union(s)
		}
		return o
	}

	function Fr(t, e, n) {
		return "right" === n ? t -= e : "center" === n && (t -= e / 2), t
	}

	function Vr(t, e, n) {
		return "middle" === n ? t -= e / 2 : "bottom" === n && (t -= e), t
	}

	function Hr(t) {
		return Er("", t)
	}

	function Gr(t, e) {
		return "string" == typeof t ? 0 <= t.lastIndexOf("%") ? parseFloat(t) / 100 * e : parseFloat(t) : t
	}

	function Wr(t, e, n) {
		var i = e.position || "inside",
			r = null != e.distance ? e.distance : 5,
			o = n.height,
			a = n.width,
			s = o / 2,
			l = n.x,
			u = n.y,
			h = "left",
			c = "top";
		if (i instanceof Array) l += Gr(i[0], n.width), u += Gr(i[1], n.height), c = h = null;
		else switch (i) {
			case "left":
				l -= r, u += s, h = "right", c = "middle";
				break;
			case "right":
				l += r + a, u += s, c = "middle";
				break;
			case "top":
				l += a / 2, u -= r, h = "center", c = "bottom";
				break;
			case "bottom":
				l += a / 2, u += o + r, h = "center";
				break;
			case "inside":
				l += a / 2, u += s, h = "center", c = "middle";
				break;
			case "insideLeft":
				l += r, u += s, c = "middle";
				break;
			case "insideRight":
				l += a - r, u += s, h = "right", c = "middle";
				break;
			case "insideTop":
				l += a / 2, u += r, h = "center";
				break;
			case "insideBottom":
				l += a / 2, u += o - r, h = "center", c = "bottom";
				break;
			case "insideTopLeft":
				l += r, u += r;
				break;
			case "insideTopRight":
				l += a - r, u += r, h = "right";
				break;
			case "insideBottomLeft":
				l += r, u += o - r, c = "bottom";
				break;
			case "insideBottomRight":
				l += a - r, u += o - r, h = "right", c = "bottom"
		}
		return (t = t || {}).x = l, t.y = u, t.align = h, t.verticalAlign = c, t
	}
	var Ur, Xr = "__zr_normal__",
		Yr = Or.concat(["ignore"]),
		qr = ht(Or, function(t, e) {
			return t[e] = !0, t
		}, {
			ignore: !1
		}),
		jr = {},
		Zr = new U(0, 0, 0, 0),
		n = (i.prototype._init = function(t) {
				this.attr(t)
			}, i.prototype.drift = function(t, e, n) {
				switch (this.draggable) {
					case "horizontal":
						e = 0;
						break;
					case "vertical":
						t = 0
				}
				var i = this.transform;
				(i = i || (this.transform = [1, 0, 0, 1, 0, 0]))[4] += t, i[5] += e, this.decomposeTransform(), this
					.markRedraw()
			}, i.prototype.beforeUpdate = function() {}, i.prototype.afterUpdate = function() {}, i.prototype
			.update = function() {
				this.updateTransform(), this.__dirty && this.updateInnerText()
			}, i.prototype.updateInnerText = function(t) {
				var e, n, i, r, o, a, s, l, u, h, c = this._textContent;
				!c || c.ignore && !t || (this.textConfig || (this.textConfig = {}), l = (t = this.textConfig).local,
					i = n = void 0, r = !1, (e = c.innerTransformable).parent = l ? this : null, h = !1, e
					.copyTransform(c), null != t.position && (u = Zr, t.layoutRect ? u.copy(t.layoutRect) : u
						.copy(this.getBoundingRect()), l || u.applyTransform(this.transform), this
						.calculateTextPosition ? this.calculateTextPosition(jr, t, u) : Wr(jr, t, u), e.x = jr
						.x, e.y = jr.y, n = jr.align, i = jr.verticalAlign, o = t.origin) && null != t
					.rotation && (s = a = void 0, s = "center" === o ? (a = .5 * u.width, .5 * u.height) : (a =
						Gr(o[0], u.width), Gr(o[1], u.height)), h = !0, e.originX = -e.x + a + (l ? 0 : u
						.x), e.originY = -e.y + s + (l ? 0 : u.y)), null != t.rotation && (e.rotation = t
						.rotation), (o = t.offset) && (e.x += o[0], e.y += o[1], h || (e.originX = -o[0], e
						.originY = -o[1])), a = null == t.inside ? "string" == typeof t.position && 0 <= t
					.position.indexOf("inside") : t.inside, s = this._innerTextDefaultStyle || (this
						._innerTextDefaultStyle = {}), h = u = l = void 0, a && this.canBeInsideText() ? (l = t
						.insideFill, u = t.insideStroke, null != l && "auto" !== l || (l = this
							.getInsideTextFill()), null != u && "auto" !== u || (u = this.getInsideTextStroke(
							l), h = !0)) : (l = t.outsideFill, u = t.outsideStroke, null != l && "auto" !== l ||
						(l = this.getOutsideFill()), null != u && "auto" !== u || (u = this.getOutsideStroke(l),
							h = !0)), (l = l || "#000") === s.fill && u === s.stroke && h === s.autoStroke &&
					n === s.align && i === s.verticalAlign || (r = !0, s.fill = l, s.stroke = u, s.autoStroke =
						h, s.align = n, s.verticalAlign = i, c.setDefaultTextStyle(s)), c.__dirty |= vn, r && c
					.dirtyStyle(!0))
			}, i.prototype.canBeInsideText = function() {
				return !0
			}, i.prototype.getInsideTextFill = function() {
				return "#fff"
			}, i.prototype.getInsideTextStroke = function(t) {
				return "#000"
			}, i.prototype.getOutsideFill = function() {
				return this.__zr && this.__zr.isDarkMode() ? Mr : Sr
			}, i.prototype.getOutsideStroke = function(t) {
				for (var e = this.__zr && this.__zr.getBackgroundColor(), n = "string" == typeof e && gi(e), i = (
						n = n || [255, 255, 255, 1])[3], r = this.__zr.isDarkMode(), o = 0; o < 3; o++) n[o] = n[
					o] * i + (r ? 0 : 255) * (1 - i);
				return n[3] = 1, xi(n, "rgba")
			}, i.prototype.traverse = function(t, e) {}, i.prototype.attrKV = function(t, e) {
				"textConfig" === t ? this.setTextConfig(e) : "textContent" === t ? this.setTextContent(e) :
					"clipPath" === t ? this.setClipPath(e) : "extra" === t ? (this.extra = this.extra || {}, O(this
						.extra, e)) : this[t] = e
			}, i.prototype.hide = function() {
				this.ignore = !0, this.markRedraw()
			}, i.prototype.show = function() {
				this.ignore = !1, this.markRedraw()
			}, i.prototype.attr = function(t, e) {
				if ("string" == typeof t) this.attrKV(t, e);
				else if (L(t))
					for (var n = R(t), i = 0; i < n.length; i++) {
						var r = n[i];
						this.attrKV(r, t[r])
					}
				return this.markRedraw(), this
			}, i.prototype.saveCurrentToNormalState = function(t) {
				this._innerSaveToNormal(t);
				for (var e = this._normalState, n = 0; n < this.animators.length; n++) {
					var i = this.animators[n],
						r = i.__fromStateTransition;
					i.getLoop() || r && r !== Xr || (r = (r = i.targetName) ? e[r] : e, i.saveTo(r))
				}
			}, i.prototype._innerSaveToNormal = function(t) {
				var e = (e = this._normalState) || (this._normalState = {});
				t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e,
					Yr)
			}, i.prototype._savePrimaryToNormal = function(t, e, n) {
				for (var i = 0; i < n.length; i++) {
					var r = n[i];
					null == t[r] || r in e || (e[r] = this[r])
				}
			}, i.prototype.hasState = function() {
				return 0 < this.currentStates.length
			}, i.prototype.getState = function(t) {
				return this.states[t]
			}, i.prototype.ensureState = function(t) {
				var e = this.states;
				return e[t] || (e[t] = {}), e[t]
			}, i.prototype.clearStates = function(t) {
				this.useState(Xr, !1, t)
			}, i.prototype.useState = function(t, e, n, i) {
				var r = t === Xr;
				if (this.hasState() || !r) {
					var o, a = this.currentStates,
						s = this.stateTransition;
					if (!(0 <= I(a, t)) || !e && 1 !== a.length) {
						if ((o = (o = this.stateProxy && !r ? this.stateProxy(t) : o) || this.states && this.states[
								t]) || r) return r || this.saveCurrentToNormalState(o), (a = !!(o && o.hoverLayer ||
								i)) && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, o, this
								._normalState, e, !n && !this.__inHover && s && 0 < s.duration, s), i = this
							._textContent, s = this._textGuide, i && i.useState(t, e, n, a), s && s.useState(t,
								e, n, a), r ? (this.currentStates = [], this._normalState = {}) : e ? this
							.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(),
							this.markRedraw(), !a && this.__inHover && (this._toggleHoverLayerFlag(!1), this
								.__dirty &= ~vn), o;
						ot("State " + t + " not exists.")
					}
				}
			}, i.prototype.useStates = function(t, e, n) {
				if (t.length) {
					var i = [],
						r = this.currentStates,
						o = t.length,
						a = o === r.length;
					if (a)
						for (var s = 0; s < o; s++)
							if (t[s] !== r[s]) {
								a = !1;
								break
							} if (!a) {
						for (s = 0; s < o; s++) {
							var l = t[s],
								u = void 0;
							(u = (u = this.stateProxy ? this.stateProxy(l, t) : u) || this.states[l]) && i.push(u)
						}
						var h = i[o - 1],
							h = !!(h && h.hoverLayer || n),
							n = (h && this._toggleHoverLayerFlag(!0), this._mergeStates(i)),
							c = this.stateTransition,
							n = (this.saveCurrentToNormalState(n), this._applyStateObj(t.join(","), n, this
									._normalState, !1, !e && !this.__inHover && c && 0 < c.duration, c), this
								._textContent),
							c = this._textGuide;
						n && n.useStates(t, e, h), c && c.useStates(t, e, h), this._updateAnimationTargets(), this
							.currentStates = t.slice(), this.markRedraw(), !h && this.__inHover && (this
								._toggleHoverLayerFlag(!1), this.__dirty &= ~vn)
					}
				} else this.clearStates()
			}, i.prototype._updateAnimationTargets = function() {
				for (var t = 0; t < this.animators.length; t++) {
					var e = this.animators[t];
					e.targetName && e.changeTarget(this[e.targetName])
				}
			}, i.prototype.removeState = function(t) {
				var e, t = I(this.currentStates, t);
				0 <= t && ((e = this.currentStates.slice()).splice(t, 1), this.useStates(e))
			}, i.prototype.replaceState = function(t, e, n) {
				var i = this.currentStates.slice(),
					t = I(i, t),
					r = 0 <= I(i, e);
				0 <= t ? r ? i.splice(t, 1) : i[t] = e : n && !r && i.push(e), this.useStates(i)
			}, i.prototype.toggleState = function(t, e) {
				e ? this.useState(t, !0) : this.removeState(t)
			}, i.prototype._mergeStates = function(t) {
				for (var e, n = {}, i = 0; i < t.length; i++) {
					var r = t[i];
					O(n, r), r.textConfig && O(e = e || {}, r.textConfig)
				}
				return e && (n.textConfig = e), n
			}, i.prototype._applyStateObj = function(t, e, n, i, r, o) {
				var a = !(e && i);
				e && e.textConfig ? (this.textConfig = O({}, (i ? this : n).textConfig), O(this.textConfig, e
					.textConfig)) : a && n.textConfig && (this.textConfig = n.textConfig);
				for (var s = {}, l = !1, u = 0; u < Yr.length; u++) {
					var h = Yr[u],
						c = r && qr[h];
					e && null != e[h] ? c ? (l = !0, s[h] = e[h]) : this[h] = e[h] : a && null != n[h] && (c ? (
						l = !0, s[h] = n[h]) : this[h] = n[h])
				}
				if (!r)
					for (u = 0; u < this.animators.length; u++) {
						var p = this.animators[u],
							d = p.targetName;
						p.getLoop() || p.__changeFinalValue(d ? (e || n)[d] : e || n)
					}
				l && this._transitionState(t, s, o)
			}, i.prototype._attachComponent = function(t) {
				var e;
				t.__zr && !t.__hostTarget || t !== this && ((e = this.__zr) && t.addSelfToZr(e), t.__zr = e, t
					.__hostTarget = this)
			}, i.prototype._detachComponent = function(t) {
				t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null
			}, i.prototype.getClipPath = function() {
				return this._clipPath
			}, i.prototype.setClipPath = function(t) {
				this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this
					._clipPath = t, this.markRedraw()
			}, i.prototype.removeClipPath = function() {
				var t = this._clipPath;
				t && (this._detachComponent(t), this._clipPath = null, this.markRedraw())
			}, i.prototype.getTextContent = function() {
				return this._textContent
			}, i.prototype.setTextContent = function(t) {
				var e = this._textContent;
				e !== t && (e && e !== t && this.removeTextContent(), t.innerTransformable = new Pr, this
					._attachComponent(t), this._textContent = t, this.markRedraw())
			}, i.prototype.setTextConfig = function(t) {
				this.textConfig || (this.textConfig = {}), O(this.textConfig, t), this.markRedraw()
			}, i.prototype.removeTextConfig = function() {
				this.textConfig = null, this.markRedraw()
			}, i.prototype.removeTextContent = function() {
				var t = this._textContent;
				t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this
					._innerTextDefaultStyle = null, this.markRedraw())
			}, i.prototype.getTextGuideLine = function() {
				return this._textGuide
			}, i.prototype.setTextGuideLine = function(t) {
				this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t),
					this._textGuide = t, this.markRedraw()
			}, i.prototype.removeTextGuideLine = function() {
				var t = this._textGuide;
				t && (this._detachComponent(t), this._textGuide = null, this.markRedraw())
			}, i.prototype.markRedraw = function() {
				this.__dirty |= vn;
				var t = this.__zr;
				t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget
					.markRedraw()
			}, i.prototype.dirty = function() {
				this.markRedraw()
			}, i.prototype._toggleHoverLayerFlag = function(t) {
				this.__inHover = t;
				var e = this._textContent,
					n = this._textGuide;
				e && (e.__inHover = t), n && (n.__inHover = t)
			}, i.prototype.addSelfToZr = function(t) {
				if (this.__zr !== t) {
					this.__zr = t;
					var e = this.animators;
					if (e)
						for (var n = 0; n < e.length; n++) t.animation.addAnimator(e[n]);
					this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent
						.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t)
				}
			}, i.prototype.removeSelfFromZr = function(t) {
				if (this.__zr) {
					this.__zr = null;
					var e = this.animators;
					if (e)
						for (var n = 0; n < e.length; n++) t.animation.removeAnimator(e[n]);
					this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent
						.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t)
				}
			}, i.prototype.animate = function(t, e, n) {
				var i = t ? this[t] : this,
					i = new Zi(i, e, n);
				return t && (i.targetName = t), this.addAnimator(i, t), i
			}, i.prototype.addAnimator = function(n, t) {
				var e = this.__zr,
					i = this;
				n.during(function() {
					i.updateDuringAnimation(t)
				}).done(function() {
					var t = i.animators,
						e = I(t, n);
					0 <= e && t.splice(e, 1)
				}), this.animators.push(n), e && e.animation.addAnimator(n), e && e.wakeUp()
			}, i.prototype.updateDuringAnimation = function(t) {
				this.markRedraw()
			}, i.prototype.stopAnimation = function(t, e) {
				for (var n = this.animators, i = n.length, r = [], o = 0; o < i; o++) {
					var a = n[o];
					t && t !== a.scope ? r.push(a) : a.stop(e)
				}
				return this.animators = r, this
			}, i.prototype.animateTo = function(t, e, n) {
				$r(this, t, e, n)
			}, i.prototype.animateFrom = function(t, e, n) {
				$r(this, t, e, n, !0)
			}, i.prototype._transitionState = function(t, e, n, i) {
				for (var r = $r(this, e, n, i), o = 0; o < r.length; o++) r[o].__fromStateTransition = t
			}, i.prototype.getBoundingRect = function() {
				return null
			}, i.prototype.getPaintRect = function() {
				return null
			}, i.initDefaultProps = ((Ur = i.prototype).type = "element", Ur.name = "", Ur.ignore = Ur.silent = Ur
				.isGroup = Ur.draggable = Ur.dragging = Ur.ignoreClip = Ur.__inHover = !1, Ur.__dirty = vn, void(
					Object.defineProperty && (Kr("position", "_legacyPos", "x", "y"), Kr("scale", "_legacyScale",
						"scaleX", "scaleY"), Kr("origin", "_legacyOrigin", "originX", "originY")))), i);

	function i(t) {
		this.id = it++, this.animators = [], this.currentStates = [], this.states = {}, this._init(t)
	}

	function Kr(t, e, n, i) {
		function r(e, t) {
			Object.defineProperty(t, 0, {
				get: function() {
					return e[n]
				},
				set: function(t) {
					e[n] = t
				}
			}), Object.defineProperty(t, 1, {
				get: function() {
					return e[i]
				},
				set: function(t) {
					e[i] = t
				}
			})
		}
		Object.defineProperty(Ur, t, {
			get: function() {
				return this[e] || r(this, this[e] = []), this[e]
			},
			set: function(t) {
				this[n] = t[0], this[i] = t[1], this[e] = t, r(this, t)
			}
		})
	}

	function $r(t, e, n, i, r) {
		function o() {
			u = !0, --l <= 0 && (u ? h && h() : c && c())
		}

		function a() {
			--l <= 0 && (u ? h && h() : c && c())
		}
		var s = [],
			l = (! function t(e, n, i, r, o, a, s, l) {
				for (var u = R(r), h = o.duration, c = o.delay, p = o.additive, d = o.setToFinal, f = !L(a), g =
						e.animators, y = [], m = 0; m < u.length; m++) {
					var v = u[m],
						_ = r[v];
					null != _ && null != i[v] && (f || a[v]) ? !L(_) || ut(_) || vt(_) ? y.push(v) : n ? l || (
							i[v] = _, e.updateDuringAnimation(n)) : t(e, v, i[v], _, o, a && a[v], s, l) : l ||
						(i[v] = _, e.updateDuringAnimation(n), y.push(v))
				}
				var x = y.length;
				if (!p && x)
					for (var w = 0; w < g.length; w++) {
						var b;
						(S = g[w]).targetName === n && S.stopTracks(y) && (b = I(g, S), g.splice(b, 1))
					}
				if (o.force || (x = (y = ct(y, function(t) {
						return !to(r[t], i[t])
					})).length), 0 < x || o.force && !s.length) {
					var S, M = void 0,
						T = void 0,
						C = void 0;
					if (l)
						for (T = {}, d && (M = {}), w = 0; w < x; w++) T[v = y[w]] = i[v], d ? M[v] = r[v] : i[
							v] = r[v];
					else if (d)
						for (C = {}, w = 0; w < x; w++) C[v = y[w]] = Wi(i[v]), Jr(i, r, v);
					(S = new Zi(i, !1, !1, p ? ct(g, function(t) {
						return t.targetName === n
					}) : null)).targetName = n, o.scope && (S.scope = o.scope), d && M && S.whenWithKeys(0, M,
							y), C && S.whenWithKeys(0, C, y), S.whenWithKeys(null == h ? 500 : h, l ? T : r, y)
						.delay(c || 0), e.addAnimator(S, n), s.push(S)
				}
			}(t, "", t, e, n = n || {}, i, s, r), s.length),
			u = !1,
			h = n.done,
			c = n.aborted;
		l || h && h(), 0 < s.length && n.during && s[0].during(function(t, e) {
			n.during(e)
		});
		for (var p = 0; p < s.length; p++) {
			var d = s[p];
			d.done(o), d.aborted(a), n.force && d.duration(n.duration), d.start(n.easing)
		}
		return s
	}

	function Qr(t, e, n) {
		for (var i = 0; i < n; i++) t[i] = e[i]
	}

	function Jr(t, e, n) {
		if (ut(e[n]))
			if (ut(t[n]) || (t[n] = []), yt(e[n])) {
				var i = e[n].length;
				t[n].length !== i && (t[n] = new e[n].constructor(i), Qr(t[n], e[n], i))
			} else {
				var r = e[n],
					o = t[n],
					a = r.length;
				if (ut(r[0]))
					for (var s = r[0].length, l = 0; l < a; l++) o[l] ? Qr(o[l], r[l], s) : o[l] = Array.prototype
						.slice.call(r[l]);
				else Qr(o, r, a);
				o.length = r.length
			}
		else t[n] = e[n]
	}

	function to(t, e) {
		return t === e || ut(t) && ut(e) && function(t, e) {
			var n = t.length;
			if (n !== e.length) return !1;
			for (var i = 0; i < n; i++)
				if (t[i] !== e[i]) return !1;
			return !0
		}(t, e)
	}
	lt(n, ue), lt(n, Pr);
	u(io, eo = n), io.prototype.childrenRef = function() {
		return this._children
	}, io.prototype.children = function() {
		return this._children.slice()
	}, io.prototype.childAt = function(t) {
		return this._children[t]
	}, io.prototype.childOfName = function(t) {
		for (var e = this._children, n = 0; n < e.length; n++)
			if (e[n].name === t) return e[n]
	}, io.prototype.childCount = function() {
		return this._children.length
	}, io.prototype.add = function(t) {
		return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
	}, io.prototype.addBefore = function(t, e) {
		var n;
		return t && t !== this && t.parent !== this && e && e.parent === this && 0 <= (e = (n = this._children)
			.indexOf(e)) && (n.splice(e, 0, t), this._doAdd(t)), this
	}, io.prototype.replace = function(t, e) {
		t = I(this._children, t);
		return 0 <= t && this.replaceAt(e, t), this
	}, io.prototype.replaceAt = function(t, e) {
		var n = this._children,
			i = n[e];
		return t && t !== this && t.parent !== this && t !== i && (n[e] = t, i.parent = null, (n = this.__zr) &&
			i.removeSelfFromZr(n), this._doAdd(t)), this
	}, io.prototype._doAdd = function(t) {
		t.parent && t.parent.remove(t);
		var e = (t.parent = this).__zr;
		e && e !== t.__zr && t.addSelfToZr(e), e && e.refresh()
	}, io.prototype.remove = function(t) {
		var e = this.__zr,
			n = this._children,
			i = I(n, t);
		return i < 0 || (n.splice(i, 1), t.parent = null, e && t.removeSelfFromZr(e), e && e.refresh()), this
	}, io.prototype.removeAll = function() {
		for (var t = this._children, e = this.__zr, n = 0; n < t.length; n++) {
			var i = t[n];
			e && i.removeSelfFromZr(e), i.parent = null
		}
		return t.length = 0, this
	}, io.prototype.eachChild = function(t, e) {
		for (var n = this._children, i = 0; i < n.length; i++) {
			var r = n[i];
			t.call(e, r, i)
		}
		return this
	}, io.prototype.traverse = function(t, e) {
		for (var n = 0; n < this._children.length; n++) {
			var i = this._children[n],
				r = t.call(e, i);
			i.isGroup && !r && i.traverse(t, e)
		}
		return this
	}, io.prototype.addSelfToZr = function(t) {
		eo.prototype.addSelfToZr.call(this, t);
		for (var e = 0; e < this._children.length; e++) this._children[e].addSelfToZr(t)
	}, io.prototype.removeSelfFromZr = function(t) {
		eo.prototype.removeSelfFromZr.call(this, t);
		for (var e = 0; e < this._children.length; e++) this._children[e].removeSelfFromZr(t)
	}, io.prototype.getBoundingRect = function(t) {
		for (var e = new U(0, 0, 0, 0), n = t || this._children, i = [], r = null, o = 0; o < n.length; o++) {
			var a, s = n[o];
			s.ignore || s.invisible || (a = s.getBoundingRect(), (s = s.getLocalTransform(i)) ? (U
				.applyTransform(e, a, s), (r = r || e.clone()).union(e)) : (r = r || a.clone()).union(
				a))
		}
		return r || e
	};
	var eo, no = io;

	function io(t) {
		var e = eo.call(this) || this;
		return e.isGroup = !0, e._children = [], e.attr(t), e
	}
	no.prototype.type = "group";
	var ro = {},
		oo = {};
	so.prototype.add = function(t) {
		t && (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh())
	}, so.prototype.remove = function(t) {
		t && (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh())
	}, so.prototype.configLayer = function(t, e) {
		this.painter.configLayer && this.painter.configLayer(t, e), this.refresh()
	}, so.prototype.setBackgroundColor = function(t) {
		this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this
			._backgroundColor = t, this._darkMode = function(t) {
				if (t) {
					if ("string" == typeof t) return wi(t, 1) < .4;
					if (t.colorStops) {
						for (var e = t.colorStops, n = 0, i = e.length, r = 0; r < i; r++) n += wi(e[r].color,
							1);
						return (n /= i) < .4
					}
				}
				return !1
			}(t)
	}, so.prototype.getBackgroundColor = function() {
		return this._backgroundColor
	}, so.prototype.setDarkMode = function(t) {
		this._darkMode = t
	}, so.prototype.isDarkMode = function() {
		return this._darkMode
	}, so.prototype.refreshImmediately = function(t) {
		t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
	}, so.prototype.refresh = function() {
		this._needsRefresh = !0, this.animation.start()
	}, so.prototype.flush = function() {
		this._flush(!1)
	}, so.prototype._flush = function(t) {
		var e, n = Qi(),
			t = (this._needsRefresh && (e = !0, this.refreshImmediately(t)), this._needsRefreshHover && (e = !0,
				this.refreshHoverImmediately()), Qi());
		e ? (this._stillFrameAccum = 0, this.trigger("rendered", {
			elapsedTime: t - n
		})) : 0 < this._sleepAfterStill && (this._stillFrameAccum++, this._stillFrameAccum > this
			._sleepAfterStill) && this.animation.stop()
	}, so.prototype.setSleepAfterStill = function(t) {
		this._sleepAfterStill = t
	}, so.prototype.wakeUp = function() {
		this.animation.start(), this._stillFrameAccum = 0
	}, so.prototype.refreshHover = function() {
		this._needsRefreshHover = !0
	}, so.prototype.refreshHoverImmediately = function() {
		this._needsRefreshHover = !1, this.painter.refreshHover && "canvas" === this.painter.getType() && this
			.painter.refreshHover()
	}, so.prototype.resize = function(t) {
		this.painter.resize((t = t || {}).width, t.height), this.handler.resize()
	}, so.prototype.clearAnimation = function() {
		this.animation.clear()
	}, so.prototype.getWidth = function() {
		return this.painter.getWidth()
	}, so.prototype.getHeight = function() {
		return this.painter.getHeight()
	}, so.prototype.setCursorStyle = function(t) {
		this.handler.setCursorStyle(t)
	}, so.prototype.findHover = function(t, e) {
		return this.handler.findHover(t, e)
	}, so.prototype.on = function(t, e, n) {
		return this.handler.on(t, e, n), this
	}, so.prototype.off = function(t, e) {
		this.handler.off(t, e)
	}, so.prototype.trigger = function(t, e) {
		this.handler.trigger(t, e)
	}, so.prototype.clear = function() {
		for (var t = this.storage.getRoots(), e = 0; e < t.length; e++) t[e] instanceof no && t[e]
			.removeSelfFromZr(this);
		this.storage.delAllRoots(), this.painter.clear()
	}, so.prototype.dispose = function() {
		var t;
		this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler
			.dispose(), this.animation = this.storage = this.painter = this.handler = null, t = this.id,
			delete oo[t]
	};
	var ao = so;

	function so(t, e, n) {
		var i = this,
			r = (this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this
				._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = e, this.id = t, new Sn),
			o = n.renderer || "canvas",
			o = (ro[o] || (o = R(ro)[0]), n.useDirtyRect = null != n.useDirtyRect && n.useDirtyRect, new ro[o](e, r,
				n, t)),
			e = n.ssr || o.ssrOnly;
		this.storage = r, this.painter = o;
		var a, t = b.node || b.worker || e ? null : new xr(o.getViewportRoot(), o.root),
			s = n.useCoarsePointer;
		(null == s || "auto" === s ? b.touchEventsSupported : s) && (a = N(n.pointerSize, 44)), this.handler =
			new an(r, o, t, o.root, a), this.animation = new tr({
				stage: {
					update: e ? null : function() {
						return i._flush(!0)
					}
				}
			}), e || this.animation.start()
	}

	function lo(t, e) {
		t = new ao(it++, t, e);
		return oo[t.id] = t
	}

	function uo(t, e) {
		ro[t] = e
	}
	var ho = Object.freeze({
			__proto__: null,
			dispose: function(t) {
				t.dispose()
			},
			disposeAll: function() {
				for (var t in oo) oo.hasOwnProperty(t) && oo[t].dispose();
				oo = {}
			},
			getInstance: function(t) {
				return oo[t]
			},
			init: lo,
			registerPainter: uo,
			version: "5.4.4"
		}),
		co = 20;

	function po(t, e, n, i) {
		var r = e[0],
			e = e[1],
			o = n[0],
			n = n[1],
			a = e - r,
			s = n - o;
		if (0 == a) return 0 == s ? o : (o + n) / 2;
		if (i)
			if (0 < a) {
				if (t <= r) return o;
				if (e <= t) return n
			} else {
				if (r <= t) return o;
				if (t <= e) return n
			}
		else {
			if (t === r) return o;
			if (t === e) return n
		}
		return (t - r) / a * s + o
	}

	function fo(t, e) {
		switch (t) {
			case "center":
			case "middle":
				t = "50%";
				break;
			case "left":
			case "top":
				t = "0%";
				break;
			case "right":
			case "bottom":
				t = "100%"
		}
		return H(t) ? t.replace(/^\s+|\s+$/g, "").match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null ==
			t ? NaN : +t
	}

	function go(t, e, n) {
		return null == e && (e = 10), e = Math.min(Math.max(0, e), co), t = (+t).toFixed(e), n ? t : +t
	}

	function yo(t) {
		if (t = +t, isNaN(t)) return 0;
		if (1e-14 < t)
			for (var e = 1, n = 0; n < 15; n++, e *= 10)
				if (Math.round(t * e) / e === t) return n;
		return mo(t)
	}

	function mo(t) {
		var t = t.toString().toLowerCase(),
			e = t.indexOf("e"),
			n = 0 < e ? +t.slice(e + 1) : 0,
			e = 0 < e ? e : t.length,
			t = t.indexOf(".");
		return Math.max(0, (t < 0 ? 0 : e - 1 - t) - n)
	}

	function vo(t, e) {
		var n = Math.log,
			i = Math.LN10,
			t = Math.floor(n(t[1] - t[0]) / i),
			n = Math.round(n(Math.abs(e[1] - e[0])) / i),
			e = Math.min(Math.max(-t + n, 0), 20);
		return isFinite(e) ? e : 20
	}

	function _o(t, e) {
		var n = ht(t, function(t, e) {
			return t + (isNaN(e) ? 0 : e)
		}, 0);
		if (0 === n) return [];
		for (var i = Math.pow(10, e), e = F(t, function(t) {
				return (isNaN(t) ? 0 : t) / n * i * 100
			}), r = 100 * i, o = F(e, function(t) {
				return Math.floor(t)
			}), a = ht(o, function(t, e) {
				return t + e
			}, 0), s = F(e, function(t, e) {
				return t - o[e]
			}); a < r;) {
			for (var l = Number.NEGATIVE_INFINITY, u = null, h = 0, c = s.length; h < c; ++h) s[h] > l && (l = s[h],
				u = h);
			++o[u], s[u] = 0, ++a
		}
		return F(o, function(t) {
			return t / i
		})
	}

	function xo(t) {
		var e = 2 * Math.PI;
		return (t % e + e) % e
	}

	function wo(t) {
		return -1e-4 < t && t < 1e-4
	}
	var bo =
		/^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;

	function So(t) {
		var e, n;
		return t instanceof Date ? t : H(t) ? (e = bo.exec(t)) ? e[8] ? (n = +e[4] || 0, "Z" !== e[8]
			.toUpperCase() && (n -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1,
				n, +(
					e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0))) : new Date(+e[1], +(e[2] || 1) -
			1,
			+e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0) : new Date(
			NaN) : null == t ? new Date(NaN) : new Date(Math.round(t))
	}

	function Mo(t) {
		return Math.pow(10, To(t))
	}

	function To(t) {
		var e;
		return 0 === t ? 0 : (e = Math.floor(Math.log(t) / Math.LN10), 10 <= t / Math.pow(10, e) && e++, e)
	}

	function Co(t, e) {
		var n = To(t),
			i = Math.pow(10, n),
			r = t / i;
		return t = (e ? r < 1.5 ? 1 : r < 2.5 ? 2 : r < 4 ? 3 : r < 7 ? 5 : 10 : r < 1 ? 1 : r < 2 ? 2 : r < 3 ? 3 :
			r < 5 ? 5 : 10) * i, -20 <= n ? +t.toFixed(n < 0 ? -n : 0) : t
	}

	function Io(t) {
		var e = parseFloat(t);
		return e == t && (0 !== e || !H(t) || t.indexOf("x") <= 0) ? e : NaN
	}

	function ko(t) {
		return !isNaN(Io(t))
	}

	function Do() {
		return Math.round(9 * Math.random())
	}

	function Ao(t, e) {
		return null == t ? e : null == e ? t : t * e / function t(e, n) {
			return 0 === n ? e : t(n, e % n)
		}(t, e)
	}

	function f(t) {
		throw new Error(t)
	}

	function Po(t, e, n) {
		return (e - t) * n + t
	}
	var Lo = "series\0",
		Oo = "\0_ec_\0";

	function Ro(t) {
		return t instanceof Array ? t : null == t ? [] : [t]
	}

	function No(t, e, n) {
		if (t) {
			t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {};
			for (var i = 0, r = n.length; i < r; i++) {
				var o = n[i];
				!t.emphasis[e].hasOwnProperty(o) && t[e].hasOwnProperty(o) && (t.emphasis[e][o] = t[e][o])
			}
		}
	}
	var Eo = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor",
		"textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor",
		"shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur",
		"textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth",
		"borderRadius", "padding"
	];

	function zo(t) {
		return !L(t) || V(t) || t instanceof Date ? t : t.value
	}

	function Bo(t, n, e) {
		var a, i, r, o, s, l, u, h, c, p, d = "normalMerge" === e,
			f = "replaceMerge" === e,
			g = "replaceAll" === e,
			y = (t = t || [], n = (n || []).slice(), z()),
			e = (E(n, function(t, e) {
				L(t) || (n[e] = null)
			}), function(t, e, n) {
				var i = [];
				if ("replaceAll" !== n)
					for (var r = 0; r < t.length; r++) {
						var o = t[r];
						o && null != o.id && e.set(o.id, r), i.push({
							existing: "replaceMerge" === n || Wo(o) ? null : o,
							newOption: null,
							keyInfo: null,
							brandNew: null
						})
					}
				return i
			}(t, y, e));
		return (d || f) && (u = e, h = t, c = y, E(p = n, function(t, e) {
			var n, i, r;
			t && null != t.id && (n = Vo(t.id), null != (i = c.get(n))) && (Ct(!(r = u[i]).newOption,
				'Duplicated option on id "' + n + '".'), r.newOption = t, r.existing = h[i], p[
				e] = null)
		})), d && (s = e, E(l = n, function(t, e) {
			if (t && null != t.name)
				for (var n = 0; n < s.length; n++) {
					var i = s[n].existing;
					if (!s[n].newOption && i && (null == i.id || null == t.id) && !Wo(t) && !Wo(i) &&
						Fo("name", i, t)) return s[n].newOption = t, void(l[e] = null)
				}
		})), d || f ? (r = e, o = f, E(n, function(t) {
			if (t) {
				for (var e, n = 0;
					(e = r[n]) && (e.newOption || Wo(e.existing) || e.existing && null != t.id && !Fo(
						"id", t, e.existing));) n++;
				e ? (e.newOption = t, e.brandNew = o) : r.push({
					newOption: t,
					brandNew: o,
					existing: null,
					keyInfo: null
				}), n++
			}
		})) : g && (i = e, E(n, function(t) {
			i.push({
				newOption: t,
				brandNew: !0,
				existing: null,
				keyInfo: null
			})
		})), t = e, a = z(), E(t, function(t) {
			var e = t.existing;
			e && a.set(e.id, t)
		}), E(t, function(t) {
			var e = t.newOption;
			Ct(!e || null == e.id || !a.get(e.id) || a.get(e.id) === t, "id duplicates: " + (e && e.id)),
				e && null != e.id && a.set(e.id, t), t.keyInfo || (t.keyInfo = {})
		}), E(t, function(t, e) {
			var n = t.existing,
				i = t.newOption,
				r = t.keyInfo;
			if (L(i)) {
				if (r.name = null != i.name ? Vo(i.name) : n ? n.name : Lo + e, n) r.id = Vo(n.id);
				else if (null != i.id) r.id = Vo(i.id);
				else
					for (var o = 0; r.id = "\0" + r.name + "\0" + o++, a.get(r.id););
				a.set(r.id, t)
			}
		}), e
	}

	function Fo(t, e, n) {
		e = Ho(e[t], null), n = Ho(n[t], null);
		return null != e && null != n && e === n
	}

	function Vo(t) {
		return Ho(t, "")
	}

	function Ho(t, e) {
		return null == t ? e : H(t) ? t : G(t) || ft(t) ? t + "" : e
	}

	function Go(t) {
		t = t.name;
		return !(!t || !t.indexOf(Lo))
	}

	function Wo(t) {
		return t && null != t.id && 0 === Vo(t.id).indexOf(Oo)
	}

	function Uo(t, r, o) {
		E(t, function(t) {
			var e, n, i = t.newOption;
			L(i) && (t.keyInfo.mainType = r, t.keyInfo.subType = (e = r, i = i, t = t.existing, n = o, i
				.type || (t ? t.subType : n.determineSubType(e, i))))
		})
	}

	function Xo(e, t) {
		return null != t.dataIndexInside ? t.dataIndexInside : null != t.dataIndex ? V(t.dataIndex) ? F(t.dataIndex,
			function(t) {
				return e.indexOfRawIndex(t)
			}) : e.indexOfRawIndex(t.dataIndex) : null != t.name ? V(t.name) ? F(t.name, function(t) {
			return e.indexOfName(t)
		}) : e.indexOfName(t.name) : void 0
	}

	function Yo() {
		var e = "__ec_inner_" + qo++;
		return function(t) {
			return t[e] || (t[e] = {})
		}
	}
	var qo = Do();

	function jo(n, t, i) {
		var t = Zo(t, i),
			e = t.mainTypeSpecified,
			r = t.queryOptionMap,
			o = t.others,
			a = i ? i.defaultMainType : null;
		return !e && a && r.set(a, {}), r.each(function(t, e) {
			t = $o(n, e, t, {
				useDefault: a === e,
				enableAll: !i || null == i.enableAll || i.enableAll,
				enableNone: !i || null == i.enableNone || i.enableNone
			});
			o[e + "Models"] = t.models, o[e + "Model"] = t.models[0]
		}), o
	}

	function Zo(t, r) {
		var e = H(t) ? ((e = {})[t + "Index"] = 0, e) : t,
			o = z(),
			a = {},
			s = !1;
		return E(e, function(t, e) {
			var n, i;
			"dataIndex" !== e && "dataIndexInside" !== e ? (n = (i = e.match(/^(\w+)(Index|Id|Name)$/) ||
				[])[1], i = (i[2] || "").toLowerCase(), !n || !i || r && r.includeMainTypes && I(r
					.includeMainTypes, n) < 0 || (s = s || !!n, (o.get(n) || o.set(n, {}))[i] = t)) : a[e] =
				t
		}), {
			mainTypeSpecified: s,
			queryOptionMap: o,
			others: a
		}
	}
	var Ko = {
		useDefault: !0,
		enableAll: !1,
		enableNone: !1
	};

	function $o(t, e, n, i) {
		i = i || Ko;
		var r = n.index,
			o = n.id,
			n = n.name,
			a = {
				models: null,
				specified: null != r || null != o || null != n
			};
		return a.specified ? "none" === r || !1 === r ? (Ct(i.enableNone,
			'`"none"` or `false` is not a valid value on index option.'), a.models = []) : ("all" === r && (Ct(i
				.enableAll, '`"all"` is not a valid value on index option.'), r = o = n = null), a.models = t
			.queryComponents({
				mainType: e,
				index: r,
				id: o,
				name: n
			})) : (r = void 0, a.models = i.useDefault && (r = t.getComponent(e)) ? [r] : []), a
	}

	function Qo(t, e, n) {
		t.setAttribute ? t.setAttribute(e, n) : t[e] = n
	}

	function Jo(t, e, n, i, r) {
		var o = null == e || "auto" === e;
		if (null == i) return i;
		if (G(i)) return go(p = Po(n || 0, i, r), o ? Math.max(yo(n || 0), yo(i)) : e);
		if (H(i)) return r < 1 ? n : i;
		for (var a = [], s = n, l = i, u = Math.max(s ? s.length : 0, l.length), h = 0; h < u; ++h) {
			var c, p, d = t.getDimensionInfo(h);
			d && "ordinal" === d.type ? a[h] = (r < 1 && s ? s : l)[h] : (p = Po(d = s && s[h] ? s[h] : 0, c = l[h],
				r), a[h] = go(p, o ? Math.max(yo(d), yo(c)) : e))
		}
		return a
	}
	var ta = ".",
		ea = "___EC__COMPONENT__CONTAINER___",
		na = "___EC__EXTENDED_CLASS___";

	function ia(t) {
		var e = {
			main: "",
			sub: ""
		};
		return t && (t = t.split(ta), e.main = t[0] || "", e.sub = t[1] || ""), e
	}

	function ra(t) {
		(t.$constructor = t).extend = function(t) {
			var e, n, i, r = this;
			return S(i = r) && /^class\s/.test(Function.prototype.toString.call(i)) ? (u(o, n = r), e = o) : st(
					e = function() {
						(t.$constructor || r).apply(this, arguments)
					}, this), O(e.prototype, t), e[na] = !0, e.extend = this.extend, e.superCall = sa, e
				.superApply = la, e.superClass = r, e;

			function o() {
				return n.apply(this, arguments) || this
			}
		}
	}

	function oa(t, e) {
		t.extend = e.extend
	}
	var aa = Math.round(10 * Math.random());

	function sa(t, e) {
		for (var n = [], i = 2; i < arguments.length; i++) n[i - 2] = arguments[i];
		return this.superClass.prototype[e].apply(t, n)
	}

	function la(t, e, n) {
		return this.superClass.prototype[e].apply(t, n)
	}

	function ua(t) {
		var r = {};
		t.registerClass = function(t) {
			var e, n = t.type || t.prototype.type;
			return n && (Ct(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e = n), 'componentType "' + e +
				'" illegal'), (e = ia(t.prototype.type = n)).sub ? e.sub !== ea && ((n = r[e.main]) &&
				n[ea] || ((n = r[e.main] = {})[ea] = !0), n[e.sub] = t) : r[e.main] = t), t
		}, t.getClass = function(t, e, n) {
			var i = r[t];
			if (i && i[ea] && (i = e ? i[e] : null), n && !i) throw new Error(e ? "Component " + t + "." + (e ||
				"") + " is used but not imported." : t + ".type should be specified.");
			return i
		}, t.getClassesByMainType = function(t) {
			var t = ia(t),
				n = [],
				t = r[t.main];
			return t && t[ea] ? E(t, function(t, e) {
				e !== ea && n.push(t)
			}) : n.push(t), n
		}, t.hasClass = function(t) {
			t = ia(t);
			return !!r[t.main]
		}, t.getAllClassMainTypes = function() {
			var n = [];
			return E(r, function(t, e) {
				n.push(e)
			}), n
		}, t.hasSubTypes = function(t) {
			t = ia(t), t = r[t.main];
			return t && t[ea]
		}
	}

	function ha(a, s) {
		for (var t = 0; t < a.length; t++) a[t][1] || (a[t][1] = a[t][0]);
		return s = s || !1,
			function(t, e, n) {
				for (var i = {}, r = 0; r < a.length; r++) {
					var o = a[r][1];
					e && 0 <= I(e, o) || n && I(n, o) < 0 || null != (o = t.getShallow(o, s)) && (i[a[r][0]] = o)
				}
				return i
			}
	}
	var ca = ha([
			["fill", "color"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["opacity"],
			["shadowColor"]
		]),
		pa = (da.prototype.getAreaStyle = function(t, e) {
			return ca(this, t, e)
		}, da);

	function da() {}
	var fa = new ei(50);

	function ga(t, e, n, i, r) {
		return t ? "string" == typeof t ? (e && e.__zrImageSrc === t || !n || (n = {
			hostEl: n,
			cb: i,
			cbPayload: r
		}, (i = fa.get(t)) ? ma(e = i.image) || i.pending.push(n) : ((e = X.loadImage(t, ya, ya))
			.__zrImageSrc = t, fa.put(t, e.__cachedImgObj = {
				image: e,
				pending: [n]
			}))), e) : t : e
	}

	function ya() {
		var t = this.__cachedImgObj;
		this.onload = this.onerror = this.__cachedImgObj = null;
		for (var e = 0; e < t.pending.length; e++) {
			var n = t.pending[e],
				i = n.cb;
			i && i(this, n.cbPayload), n.hostEl.dirty()
		}
		t.pending.length = 0
	}

	function ma(t) {
		return t && t.width && t.height
	}
	var va = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;

	function _a(t, e, n, i, r) {
		if (!e) return "";
		var o = (t + "").split("\n");
		r = xa(e, n, i, r);
		for (var a = 0, s = o.length; a < s; a++) o[a] = wa(o[a], r);
		return o.join("\n")
	}

	function xa(t, e, n, i) {
		var r = O({}, i = i || {}),
			o = (r.font = e, n = N(n, "..."), r.maxIterations = N(i.maxIterations, 2), r.minChar = N(i.minChar, 0)),
			a = (r.cnCharWidth = Er("", e), r.ascCharWidth = Er("a", e));
		r.placeholder = N(i.placeholder, "");
		for (var s = t = Math.max(0, t - 1), l = 0; l < o && a <= s; l++) s -= a;
		i = Er(n, e);
		return s < i && (n = "", i = 0), s = t - i, r.ellipsis = n, r.ellipsisWidth = i, r.contentWidth = s, r
			.containerWidth = t, r
	}

	function wa(t, e) {
		var n = e.containerWidth,
			i = e.font,
			r = e.contentWidth;
		if (!n) return "";
		var o = Er(t, i);
		if (!(o <= n)) {
			for (var a = 0;; a++) {
				if (o <= r || a >= e.maxIterations) {
					t += e.ellipsis;
					break
				}
				var s = 0 === a ? function(t, e, n, i) {
						for (var r = 0, o = 0, a = t.length; o < a && r < e; o++) {
							var s = t.charCodeAt(o);
							r += 0 <= s && s <= 127 ? n : i
						}
						return o
					}(t, r, e.ascCharWidth, e.cnCharWidth) : 0 < o ? Math.floor(t.length * r / o) : 0,
					o = Er(t = t.substr(0, s), i)
			}
			"" === t && (t = e.placeholder)
		}
		return t
	}

	function ba() {
		this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this
			.outerHeight = 0, this.lines = []
	}
	var Sa = function() {},
		Ma = function(t) {
			this.tokens = [], t && (this.tokens = t)
		};

	function Ta(t, e) {
		var n = new ba;
		if (null != t && (t += ""), t) {
			for (var i, r = e.width, o = e.height, a = e.overflow, s = "break" !== a && "breakAll" !== a || null ==
					r ? null : {
						width: r,
						accumWidth: 0,
						breakAll: "breakAll" === a
					}, l = va.lastIndex = 0; null != (i = va.exec(t));) {
				var u = i.index;
				l < u && Ca(n, t.substring(l, u), e, s), Ca(n, i[2], e, s, i[1]), l = va.lastIndex
			}
			l < t.length && Ca(n, t.substring(l, t.length), e, s);
			var h, c = [],
				p = 0,
				d = 0,
				f = e.padding,
				g = "truncate" === a,
				y = "truncate" === e.lineOverflow;
			t: for (var m = 0; m < n.lines.length; m++) {
				for (var v = n.lines[m], _ = 0, x = 0, w = 0; w < v.tokens.length; w++) {
					var b = (D = v.tokens[w]).styleName && e.rich[D.styleName] || {},
						S = D.textPadding = b.padding,
						M = S ? S[1] + S[3] : 0,
						T = D.font = b.font || e.font,
						C = (D.contentHeight = Hr(T), N(b.height, D.contentHeight));
					if (D.innerHeight = C, S && (C += S[0] + S[2]), D.height = C, D.lineHeight = St(b
							.lineHeight, e.lineHeight, C), D.align = b && b.align || e.align, D.verticalAlign =
						b && b.verticalAlign || "middle", y && null != o && p + D.lineHeight > o) {
						0 < w ? (v.tokens = v.tokens.slice(0, w), P(v, x, _), n.lines = n.lines.slice(0, m +
							1)) : n.lines = n.lines.slice(0, m);
						break t
					}
					var I, S = b.width,
						k = null == S || "auto" === S;
					"string" == typeof S && "%" === S.charAt(S.length - 1) ? (D.percentWidth = S, c.push(D), D
							.contentWidth = Er(D.text, T)) : (k && (S = (S = b.backgroundColor) && S.image) && (
							I = void 0, ma(S = "string" == typeof(h = S) ? (I = fa.get(h)) && I.image : h)
						) && (D.width = Math.max(D.width, S.width * C / S.height)), null != (I = g &&
							null != r ? r - x : null) && I < D.width ? !k || I < M ? (D.text = "", D.width =
							D.contentWidth = 0) : (D.text = _a(D.text, I - M, T, e.ellipsis, {
							minChar: e.truncateMinChar
						}), D.width = D.contentWidth = Er(D.text, T)) : D.contentWidth = Er(D.text, T)), D
						.width += M, x += D.width, b && (_ = Math.max(_, D.lineHeight))
				}
				P(v, x, _)
			}
			for (n.outerWidth = n.width = N(r, d), n.outerHeight = n.height = N(o, p), n.contentHeight = p, n
				.contentWidth = d, f && (n.outerWidth += f[1] + f[3], n.outerHeight += f[0] + f[2]), m = 0; m < c
				.length; m++) {
				var D, A = (D = c[m]).percentWidth;
				D.width = parseInt(A, 10) / 100 * n.width
			}
		}
		return n;

		function P(t, e, n) {
			t.width = e, t.lineHeight = n, p += n, d = Math.max(d, e)
		}
	}

	function Ca(t, e, n, i, r) {
		var o, a, s = "" === e,
			l = r && n.rich[r] || {},
			u = t.lines,
			h = l.font || n.font,
			c = !1;
		i ? (n = (t = l.padding) ? t[1] + t[3] : 0, null != l.width && "auto" !== l.width ? (t = Gr(l.width, i
				.width) + n, 0 < u.length && t + i.accumWidth > i.width && (o = e.split("\n"), c = !0), i
			.accumWidth = t) : (t = ka(e, h, i.width, i.breakAll, i.accumWidth), i.accumWidth = t
			.accumWidth + n, a = t.linesWidths, o = t.lines)) : o = e.split("\n");
		for (var p = 0; p < o.length; p++) {
			var d, f, g = o[p],
				y = new Sa;
			y.styleName = r, y.text = g, y.isLineHolder = !g && !s, "number" == typeof l.width ? y.width = l.width :
				y.width = a ? a[p] : Er(g, h), p || c ? u.push(new Ma([y])) : 1 === (f = (d = (u[u.length - 1] || (
					u[0] = new Ma)).tokens).length) && d[0].isLineHolder ? d[0] = y : !g && f && !s || d.push(y)
		}
	}
	var Ia = ht(",&?/;] ".split(""), function(t, e) {
		return t[e] = !0, t
	}, {});

	function ka(t, e, n, i, r) {
		for (var o, a = [], s = [], l = "", u = "", h = 0, c = 0, p = 0; p < t.length; p++) {
			var d, f, g = t.charAt(p);
			"\n" !== g ? (d = Er(g, e), f = !(i || (f = void 0, !(32 <= (f = (f = o = g).charCodeAt(0)) && f <=
					591 || 880 <= f && f <= 4351 || 4608 <= f && f <= 5119 || 7680 <= f && f <= 8303)) ||
				Ia[o]), (a.length ? n < c + d : n < r + c + d) ? c ? (l || u) && (c = f ? (l || (l = u, u =
				"", c = h = 0), a.push(l), s.push(c - h), u += g, l = "", h += d) : (u && (l += u, u =
				"", h = 0), a.push(l), s.push(c), l = g, d)) : f ? (a.push(u), s.push(h), u = g, h = d) : (a
				.push(g), s.push(d)) : (c += d, f ? (u += g, h += d) : (u && (l += u, u = "", h = 0), l +=
				g))) : (u && (l += u, c += h), a.push(l), s.push(c), u = l = "", c = h = 0)
		}
		return a.length || l || (l = t, u = "", h = 0), u && (l += u), l && (a.push(l), s.push(c)), 1 === a
			.length && (c += r), {
				accumWidth: c,
				lines: a,
				linesWidths: s
			}
	}
	var Da, Aa = "__zr_style_" + Math.round(10 * Math.random()),
		Pa = {
			shadowBlur: 0,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			shadowColor: "#000",
			opacity: 1,
			blend: "source-over"
		},
		La = {
			style: {
				shadowBlur: !0,
				shadowOffsetX: !0,
				shadowOffsetY: !0,
				shadowColor: !0,
				opacity: !0
			}
		},
		Oa = (Pa[Aa] = !0, ["z", "z2", "invisible"]),
		Ra = ["invisible"],
		n = (u(r, Da = n), r.prototype._init = function(t) {
				for (var e = R(t), n = 0; n < e.length; n++) {
					var i = e[n];
					"style" === i ? this.useStyle(t[i]) : Da.prototype.attrKV.call(this, i, t[i])
				}
				this.style || this.useStyle({})
			}, r.prototype.beforeBrush = function() {}, r.prototype.afterBrush = function() {}, r.prototype
			.innerBeforeBrush = function() {}, r.prototype.innerAfterBrush = function() {}, r.prototype
			.shouldBePainted = function(t, e, n, i) {
				var r, o = this.transform;
				if (this.ignore || this.invisible || 0 === this.style.opacity || this.culling && (r = this, t = t,
						e = e, Na.copy(r.getBoundingRect()), r.transform && Na.applyTransform(r.transform), Ea
						.width = t, Ea.height = e, !Na.intersect(Ea)) || o && !o[0] && !o[3]) return !1;
				if (n && this.__clipPaths)
					for (var a = 0; a < this.__clipPaths.length; ++a)
						if (this.__clipPaths[a].isZeroArea()) return !1;
				if (i && this.parent)
					for (var s = this.parent; s;) {
						if (s.ignore) return !1;
						s = s.parent
					}
				return !0
			}, r.prototype.contain = function(t, e) {
				return this.rectContain(t, e)
			}, r.prototype.traverse = function(t, e) {
				t.call(e, this)
			}, r.prototype.rectContain = function(t, e) {
				t = this.transformCoordToLocal(t, e);
				return this.getBoundingRect().contain(t[0], t[1])
			}, r.prototype.getPaintRect = function() {
				var t, e, n, i, r, o = this._paintRect;
				return this._paintRect && !this.__dirty || (r = this.transform, t = this.getBoundingRect(), e = (i =
						this.style).shadowBlur || 0, n = i.shadowOffsetX || 0, i = i.shadowOffsetY || 0, o =
					this._paintRect || (this._paintRect = new U(0, 0, 0, 0)), r ? U.applyTransform(o, t, r) : o
					.copy(t), (e || n || i) && (o.width += 2 * e + Math.abs(n), o.height += 2 * e + Math.abs(i),
						o.x = Math.min(o.x, o.x + n - e), o.y = Math.min(o.y, o.y + i - e)), r = this
					.dirtyRectTolerance, o.isZero()) || (o.x = Math.floor(o.x - r), o.y = Math.floor(o.y - r), o
					.width = Math.ceil(o.width + 1 + 2 * r), o.height = Math.ceil(o.height + 1 + 2 * r)), o
			}, r.prototype.setPrevPaintRect = function(t) {
				t ? (this._prevPaintRect = this._prevPaintRect || new U(0, 0, 0, 0), this._prevPaintRect.copy(t)) :
					this._prevPaintRect = null
			}, r.prototype.getPrevPaintRect = function() {
				return this._prevPaintRect
			}, r.prototype.animateStyle = function(t) {
				return this.animate("style", t)
			}, r.prototype.updateDuringAnimation = function(t) {
				"style" === t ? this.dirtyStyle() : this.markRedraw()
			}, r.prototype.attrKV = function(t, e) {
				"style" !== t ? Da.prototype.attrKV.call(this, t, e) : this.style ? this.setStyle(e) : this
					.useStyle(e)
			}, r.prototype.setStyle = function(t, e) {
				return "string" == typeof t ? this.style[t] = e : O(this.style, t), this.dirtyStyle(), this
			}, r.prototype.dirtyStyle = function(t) {
				t || this.markRedraw(), this.__dirty |= 2, this._rect && (this._rect = null)
			}, r.prototype.dirty = function() {
				this.dirtyStyle()
			}, r.prototype.styleChanged = function() {
				return !!(2 & this.__dirty)
			}, r.prototype.styleUpdated = function() {
				this.__dirty &= -3
			}, r.prototype.createStyle = function(t) {
				return zt(Pa, t)
			}, r.prototype.useStyle = function(t) {
				t[Aa] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this
					.dirtyStyle()
			}, r.prototype.isStyleObject = function(t) {
				return t[Aa]
			}, r.prototype._innerSaveToNormal = function(t) {
				Da.prototype._innerSaveToNormal.call(this, t);
				var e = this._normalState;
				t.style && !e.style && (e.style = this._mergeStyle(this.createStyle(), this.style)), this
					._savePrimaryToNormal(t, e, Oa)
			}, r.prototype._applyStateObj = function(t, e, n, i, r, o) {
				Da.prototype._applyStateObj.call(this, t, e, n, i, r, o);
				var a, s = !(e && i);
				if (e && e.style ? r ? i ? a = e.style : (a = this._mergeStyle(this.createStyle(), n.style), this
						._mergeStyle(a, e.style)) : (a = this._mergeStyle(this.createStyle(), (i ? this : n).style),
						this._mergeStyle(a, e.style)) : s && (a = n.style), a)
					if (r) {
						var l = this.style;
						if (this.style = this.createStyle(s ? {} : l), s)
							for (var u = R(l), h = 0; h < u.length; h++)(p = u[h]) in a && (a[p] = a[p], this.style[
								p] = l[p]);
						for (var c = R(a), h = 0; h < c.length; h++) {
							var p = c[h];
							this.style[p] = this.style[p]
						}
						this._transitionState(t, {
							style: a
						}, o, this.getAnimationStyleProps())
					} else this.useStyle(a);
				var d = this.__inHover ? Ra : Oa;
				for (h = 0; h < d.length; h++) p = d[h], e && null != e[p] ? this[p] = e[p] : s && null != n[p] && (
					this[p] = n[p])
			}, r.prototype._mergeStates = function(t) {
				for (var e, n = Da.prototype._mergeStates.call(this, t), i = 0; i < t.length; i++) {
					var r = t[i];
					r.style && this._mergeStyle(e = e || {}, r.style)
				}
				return e && (n.style = e), n
			}, r.prototype._mergeStyle = function(t, e) {
				return O(t, e), t
			}, r.prototype.getAnimationStyleProps = function() {
				return La
			}, r.initDefaultProps = ((n = r.prototype).type = "displayable", n.invisible = !1, n.z = 0, n.z2 = 0, n
				.zlevel = 0, n.culling = !1, n.cursor = "pointer", n.rectHover = !1, n.incremental = !1, n._rect =
				null, n.dirtyRectTolerance = 0, void(n.__dirty = 2 | vn)), r),
		Na = new U(0, 0, 0, 0),
		Ea = new U(0, 0, 0, 0);

	function r(t) {
		return Da.call(this, t) || this
	}
	var za = Math.min,
		Ba = Math.max,
		Fa = Math.sin,
		Va = Math.cos,
		Ha = 2 * Math.PI,
		Ga = Wt(),
		Wa = Wt(),
		Ua = Wt();

	function Xa(t, e, n, i, r, o) {
		r[0] = za(t, n), r[1] = za(e, i), o[0] = Ba(t, n), o[1] = Ba(e, i)
	}
	var Ya = [],
		qa = [];
	var ja = {
			M: 1,
			L: 2,
			C: 3,
			Q: 4,
			A: 5,
			Z: 6,
			R: 7
		},
		Za = [],
		Ka = [],
		$a = [],
		Qa = [],
		Ja = [],
		ts = [],
		es = Math.min,
		ns = Math.max,
		is = Math.cos,
		rs = Math.sin,
		os = Math.abs,
		as = Math.PI,
		ss = 2 * as,
		ls = "undefined" != typeof Float32Array,
		us = [];

	function hs(t) {
		return Math.round(t / as * 1e8) / 1e8 % 2 * as
	}
	o.prototype.increaseVersion = function() {
		this._version++
	}, o.prototype.getVersion = function() {
		return this._version
	}, o.prototype.setScale = function(t, e, n) {
		0 < (n = n || 0) && (this._ux = os(n / br / t) || 0, this._uy = os(n / br / e) || 0)
	}, o.prototype.setDPR = function(t) {
		this.dpr = t
	}, o.prototype.setContext = function(t) {
		this._ctx = t
	}, o.prototype.getContext = function() {
		return this._ctx
	}, o.prototype.beginPath = function() {
		return this._ctx && this._ctx.beginPath(), this.reset(), this
	}, o.prototype.reset = function() {
		this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0),
			this._version++
	}, o.prototype.moveTo = function(t, e) {
		return this._drawPendingPt(), this.addData(ja.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 =
			t, this._y0 = e, this._xi = t, this._yi = e, this
	}, o.prototype.lineTo = function(t, e) {
		var n = os(t - this._xi),
			i = os(e - this._yi),
			r = n > this._ux || i > this._uy;
		return this.addData(ja.L, t, e), this._ctx && r && this._ctx.lineTo(t, e), r ? (this._xi = t, this._yi =
			e, this._pendingPtDist = 0) : (r = n * n + i * i) > this._pendingPtDist && (this._pendingPtX =
			t, this._pendingPtY = e, this._pendingPtDist = r), this
	}, o.prototype.bezierCurveTo = function(t, e, n, i, r, o) {
		return this._drawPendingPt(), this.addData(ja.C, t, e, n, i, r, o), this._ctx && this._ctx
			.bezierCurveTo(t, e, n, i, r, o), this._xi = r, this._yi = o, this
	}, o.prototype.quadraticCurveTo = function(t, e, n, i) {
		return this._drawPendingPt(), this.addData(ja.Q, t, e, n, i), this._ctx && this._ctx.quadraticCurveTo(t,
			e, n, i), this._xi = n, this._yi = i, this
	}, o.prototype.arc = function(t, e, n, i, r, o) {
		this._drawPendingPt(), us[0] = i, us[1] = r, s = o, (l = hs((a = us)[0])) < 0 && (l += ss), h = l - a[
				0], u = a[1], u += h, !s && ss <= u - l ? u = l + ss : s && ss <= l - u ? u = l - ss : !s && u <
			l ?
			u = l + (ss - hs(l - u)) : s && l < u && (u = l - (ss - hs(u - l))), a[0] = l, a[1] = u;
		var a, s, l, u, h = (r = us[1]) - (i = us[0]);
		return this.addData(ja.A, t, e, n, n, i, h, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, n, i, r, o),
			this._xi = is(r) * n + t, this._yi = rs(r) * n + e, this
	}, o.prototype.arcTo = function(t, e, n, i, r) {
		return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, n, i, r), this
	}, o.prototype.rect = function(t, e, n, i) {
		return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, n, i), this.addData(ja.R, t, e, n, i),
			this
	}, o.prototype.closePath = function() {
		this._drawPendingPt(), this.addData(ja.Z);
		var t = this._ctx,
			e = this._x0,
			n = this._y0;
		return t && t.closePath(), this._xi = e, this._yi = n, this
	}, o.prototype.fill = function(t) {
		t && t.fill(), this.toStatic()
	}, o.prototype.stroke = function(t) {
		t && t.stroke(), this.toStatic()
	}, o.prototype.len = function() {
		return this._len
	}, o.prototype.setData = function(t) {
		var e = t.length;
		this.data && this.data.length === e || !ls || (this.data = new Float32Array(e));
		for (var n = 0; n < e; n++) this.data[n] = t[n];
		this._len = e
	}, o.prototype.appendPath = function(t) {
		for (var e = (t = t instanceof Array ? t : [t]).length, n = 0, i = this._len, r = 0; r < e; r++) n += t[
			r].len();
		for (ls && this.data instanceof Float32Array && (this.data = new Float32Array(i + n)), r = 0; r <
			e; r++)
			for (var o = t[r].data, a = 0; a < o.length; a++) this.data[i++] = o[a];
		this._len = i
	}, o.prototype.addData = function(t, e, n, i, r, o, a, s, l) {
		if (this._saveData) {
			var u = this.data;
			this._len + arguments.length > u.length && (this._expandData(), u = this.data);
			for (var h = 0; h < arguments.length; h++) u[this._len++] = arguments[h]
		}
	}, o.prototype._drawPendingPt = function() {
		0 < this._pendingPtDist && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this
			._pendingPtDist = 0)
	}, o.prototype._expandData = function() {
		if (!(this.data instanceof Array)) {
			for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
			this.data = t
		}
	}, o.prototype.toStatic = function() {
		var t;
		this._saveData && (this._drawPendingPt(), (t = this.data) instanceof Array) && (t.length = this._len,
			ls) && 11 < this._len && (this.data = new Float32Array(t))
	}, o.prototype.getBoundingRect = function() {
		$a[0] = $a[1] = Ja[0] = Ja[1] = Number.MAX_VALUE, Qa[0] = Qa[1] = ts[0] = ts[1] = -Number.MAX_VALUE;
		for (var t, e, n, i = this.data, r = 0, o = 0, a = 0, s = 0, l = 0; l < this._len;) {
			var u = i[l++],
				h = 1 === l;
			switch (h && (a = r = i[l], s = o = i[l + 1]), u) {
				case ja.M:
					r = a = i[l++], o = s = i[l++], Ja[0] = a, Ja[1] = s, ts[0] = a, ts[1] = s;
					break;
				case ja.L:
					Xa(r, o, i[l], i[l + 1], Ja, ts), r = i[l++], o = i[l++];
					break;
				case ja.C:
					C = T = M = S = b = w = x = _ = v = m = y = g = f = d = p = c = void 0;
					var c = r,
						p = o,
						d = i[l++],
						f = i[l++],
						g = i[l++],
						y = i[l++],
						m = i[l],
						v = i[l + 1],
						_ = Ja,
						x = ts,
						w = Vn,
						b = zn,
						S = w(c, d, g, m, Ya);
					_[0] = 1 / 0, _[1] = 1 / 0, x[0] = -1 / 0, x[1] = -1 / 0;
					for (var M = 0; M < S; M++) {
						var T = b(c, d, g, m, Ya[M]);
						_[0] = za(T, _[0]), x[0] = Ba(T, x[0])
					}
					for (S = w(p, f, y, v, qa), M = 0; M < S; M++) {
						var C = b(p, f, y, v, qa[M]);
						_[1] = za(C, _[1]), x[1] = Ba(C, x[1])
					}
					_[0] = za(c, _[0]), x[0] = Ba(c, x[0]), _[0] = za(m, _[0]), x[0] = Ba(m, x[0]), _[1] = za(p,
							_[1]), x[1] = Ba(p, x[1]), _[1] = za(v, _[1]), x[1] = Ba(v, x[1]), r = i[l++], o =
						i[l++];
					break;
				case ja.Q:
					w = r, t = o, L = i[l++], k = i[l++], P = i[l], e = i[l + 1], A = Ja, O = ts, n = D = n =
						I = void 0, I = Wn, n = Ba(za((D = Xn)(w, L, P), 1), 0), D = Ba(za(D(t, k, e), 1), 0),
						L = I(w, L, P, n), n = I(t, k, e, D), A[0] = za(w, P, L), A[1] = za(t, e, n), O[0] = Ba(
							w, P, L), O[1] = Ba(t, e, n), r = i[l++], o = i[l++];
					break;
				case ja.A:
					var I = i[l++],
						k = i[l++],
						D = i[l++],
						A = i[l++],
						P = i[l++],
						L = i[l++] + P,
						O = (l += 1, !i[l++]);
					h && (a = is(P) * D + I, s = rs(P) * A + k),
						function(t, e, n, i, r, o, a, s, l) {
							var u = ie,
								h = re,
								c = Math.abs(r - o);
							if (c % Ha < 1e-4 && 1e-4 < c) return s[0] = t - n, s[1] = e - i, l[0] = t + n, l[
								1] = e + i;
							Ga[0] = Va(r) * n + t, Ga[1] = Fa(r) * i + e, Wa[0] = Va(o) * n + t, Wa[1] = Fa(o) *
								i + e, u(s, Ga, Wa), h(l, Ga, Wa), (r %= Ha) < 0 && (r += Ha), (o %= Ha) < 0 &&
								(o += Ha), o < r && !a ? o += Ha : r < o && a && (r += Ha), a && (c = o, o = r,
									r = c);
							for (var p = 0; p < o; p += Math.PI / 2) r < p && (Ua[0] = Va(p) * n + t, Ua[1] =
								Fa(p) * i + e, u(s, Ua, s), h(l, Ua, l))
						}(I, k, D, A, P, L, O, Ja, ts), r = is(L) * D + I, o = rs(L) * A + k;
					break;
				case ja.R:
					Xa(a = r = i[l++], s = o = i[l++], a + i[l++], s + i[l++], Ja, ts);
					break;
				case ja.Z:
					r = a, o = s
			}
			ie($a, $a, Ja), re(Qa, Qa, ts)
		}
		return 0 === l && ($a[0] = $a[1] = Qa[0] = Qa[1] = 0), new U($a[0], $a[1], Qa[0] - $a[0], Qa[1] - $a[1])
	}, o.prototype._calculateLength = function() {
		var t = this.data,
			e = this._len,
			n = this._ux,
			i = this._uy,
			r = 0,
			o = 0,
			a = 0,
			s = 0;
		this._pathSegLen || (this._pathSegLen = []);
		for (var l = this._pathSegLen, u = 0, h = 0, c = 0; c < e;) {
			var p = t[c++],
				d = 1 === c,
				f = (d && (a = r = t[c], s = o = t[c + 1]), -1);
			switch (p) {
				case ja.M:
					r = a = t[c++], o = s = t[c++];
					break;
				case ja.L:
					var g = t[c++],
						y = (_ = t[c++]) - o;
					(os(I = g - r) > n || os(y) > i || c === e - 1) && (f = Math.sqrt(I * I + y * y), r = g, o =
						_);
					break;
				case ja.C:
					var m = t[c++],
						v = t[c++],
						_ = (g = t[c++], t[c++]),
						x = t[c++],
						w = t[c++],
						f = function(t, e, n, i, r, o, a, s, l) {
							for (var u = t, h = e, c = 0, p = 1 / l, d = 1; d <= l; d++) {
								var f = d * p,
									g = zn(t, n, r, a, f),
									f = zn(e, i, o, s, f),
									y = g - u,
									m = f - h;
								c += Math.sqrt(y * y + m * m), u = g, h = f
							}
							return c
						}(r, o, m, v, g, _, x, w, 10),
						r = x,
						o = w;
					break;
				case ja.Q:
					f = function(t, e, n, i, r, o, a) {
						for (var s = t, l = e, u = 0, h = 1 / a, c = 1; c <= a; c++) {
							var p = c * h,
								d = Wn(t, n, r, p),
								p = Wn(e, i, o, p),
								f = d - s,
								g = p - l;
							u += Math.sqrt(f * f + g * g), s = d, l = p
						}
						return u
					}(r, o, m = t[c++], v = t[c++], g = t[c++], _ = t[c++], 10), r = g, o = _;
					break;
				case ja.A:
					var x = t[c++],
						w = t[c++],
						b = t[c++],
						S = t[c++],
						M = t[c++],
						T = t[c++],
						C = T + M;
					c += 1, t[c++], d && (a = is(M) * b + x, s = rs(M) * S + w), f = ns(b, S) * es(ss, Math.abs(
						T)), r = is(C) * b + x, o = rs(C) * S + w;
					break;
				case ja.R:
					a = r = t[c++], s = o = t[c++], f = 2 * t[c++] + 2 * t[c++];
					break;
				case ja.Z:
					var I = a - r,
						y = s - o;
					f = Math.sqrt(I * I + y * y), r = a, o = s
			}
			0 <= f && (u += l[h++] = f)
		}
		return this._pathLen = u
	}, o.prototype.rebuildPath = function(t, e) {
		var n, i, r, o, a, s, l, u, h = this.data,
			E = this._ux,
			z = this._uy,
			B = this._len,
			c = e < 1,
			p = 0,
			d = 0,
			f = 0;
		if (!c || (this._pathSegLen || this._calculateLength(), a = this._pathSegLen, s = e * this._pathLen)) t:
			for (var g = 0; g < B;) {
				var y, m = h[g++],
					F = 1 === g;
				switch (F && (n = r = h[g], i = o = h[g + 1]), m !== ja.L && 0 < f && (t.lineTo(l, u), f = 0),
					m) {
					case ja.M:
						n = r = h[g++], i = o = h[g++], t.moveTo(r, o);
						break;
					case ja.L:
						var v = h[g++],
							_ = h[g++],
							x = os(v - r),
							w = os(_ - o);
						if (E < x || z < w) {
							if (c) {
								if (p + (y = a[d++]) > s) {
									var b = (s - p) / y;
									t.lineTo(r * (1 - b) + v * b, o * (1 - b) + _ * b);
									break t
								}
								p += y
							}
							t.lineTo(v, _), r = v, o = _, f = 0
						} else {
							x = x * x + w * w;
							f < x && (l = v, u = _, f = x)
						}
						break;
					case ja.C:
						var S = h[g++],
							M = h[g++],
							T = h[g++],
							C = h[g++],
							w = h[g++],
							x = h[g++];
						if (c) {
							if (p + (y = a[d++]) > s) {
								Hn(r, S, T, w, b = (s - p) / y, Za), Hn(o, M, C, x, b, Ka), t.bezierCurveTo(Za[
									1], Ka[1], Za[2], Ka[2], Za[3], Ka[3]);
								break t
							}
							p += y
						}
						t.bezierCurveTo(S, M, T, C, w, x), r = w, o = x;
						break;
					case ja.Q:
						if (S = h[g++], M = h[g++], T = h[g++], C = h[g++], c) {
							if (p + (y = a[d++]) > s) {
								Yn(r, S, T, b = (s - p) / y, Za), Yn(o, M, C, b, Ka), t.quadraticCurveTo(Za[1],
									Ka[1], Za[2], Ka[2]);
								break t
							}
							p += y
						}
						t.quadraticCurveTo(S, M, T, C), r = T, o = C;
						break;
					case ja.A:
						var I = h[g++],
							k = h[g++],
							D = h[g++],
							A = h[g++],
							P = h[g++],
							L = h[g++],
							O = h[g++],
							V = !h[g++],
							H = A < D ? D : A,
							R = .001 < os(D - A),
							N = P + L,
							G = !1;
						if (c && (p + (y = a[d++]) > s && (N = P + L * (s - p) / y, G = !0), p += y), R && t
							.ellipse ? t.ellipse(I, k, D, A, O, P, N, V) : t.arc(I, k, H, P, N, V), G) break t;
						F && (n = is(P) * D + I, i = rs(P) * A + k), r = is(N) * D + I, o = rs(N) * A + k;
						break;
					case ja.R:
						n = r = h[g], i = o = h[g + 1], v = h[g++], _ = h[g++];
						L = h[g++], R = h[g++];
						if (c) {
							if (p + (y = a[d++]) > s) {
								O = s - p;
								t.moveTo(v, _), t.lineTo(v + es(O, L), _), 0 < (O -= L) && t.lineTo(v + L, _ +
									es(O, R)), 0 < (O -= R) && t.lineTo(v + ns(L - O, 0), _ + R), 0 < (O -=
									L) && t.lineTo(v, _ + ns(R - O, 0));
								break t
							}
							p += y
						}
						t.rect(v, _, L, R);
						break;
					case ja.Z:
						if (c) {
							if (p + (y = a[d++]) > s) {
								t.lineTo(r * (1 - (b = (s - p) / y)) + n * b, o * (1 - b) + i * b);
								break t
							}
							p += y
						}
						t.closePath(), r = n, o = i
				}
			}
	}, o.prototype.clone = function() {
		var t = new o,
			e = this.data;
		return t.data = e.slice ? e.slice() : Array.prototype.slice.call(e), t._len = this._len, t
	}, o.CMD = ja, o.initDefaultProps = ((Du = o.prototype)._saveData = !0, Du._ux = 0, Du._uy = 0, Du
		._pendingPtDist = 0, void(Du._version = 0));
	var cs = o;

	function o(t) {
		this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this
			._saveData = !1), this._saveData && (this.data = [])
	}

	function ps(t, e, n, i, r, o, a) {
		var s;
		if (0 !== r) return s = 0, !(e + (r = r) < a && i + r < a || a < e - r && a < i - r || t + r < o && n + r <
			o || o < t - r && o < n - r) && (t === n ? Math.abs(o - t) <= r / 2 : (o = (s = (e - i) / (t -
			n)) * o - a + (t * i - n * e) / (t - n)) * o / (s * s + 1) <= r / 2 * r / 2)
	}
	var ds = 2 * Math.PI;

	function fs(t) {
		return (t %= ds) < 0 && (t += ds), t
	}
	var gs = 2 * Math.PI;

	function ys(t, e, n, i, r, o) {
		return e < o && i < o || o < e && o < i || i === e ? 0 : (n = (o = (o - e) / (i - e)) * (n - t) + t) === r ?
			1 / 0 : r < n ? 1 != o && 0 != o ? i < e ? 1 : -1 : i < e ? .5 : -.5 : 0
	}
	var ms = cs.CMD,
		vs = 2 * Math.PI,
		_s = 1e-4;
	var xs = [-1, -1, -1],
		ws = [-1, -1];

	function bs(t, e, n, i, r, o, a, s, l, u) {
		if (e < u && i < u && o < u && s < u || u < e && u < i && u < o && u < s) return 0;
		var h = Fn(e, i, o, s, u, xs);
		if (0 === h) return 0;
		for (var c, p = 0, d = -1, f = void 0, g = void 0, y = 0; y < h; y++) {
			var m = xs[y],
				v = 0 === m || 1 === m ? .5 : 1;
			zn(t, n, r, a, m) < l || (d < 0 && (d = Vn(e, i, o, s, ws), ws[1] < ws[0] && 1 < d && (c = void 0, c =
					ws[0], ws[0] = ws[1], ws[1] = c), f = zn(e, i, o, s, ws[0]), 1 < d) && (g = zn(e, i, o, s,
					ws[1])), 2 === d ? m < ws[0] ? p += f < e ? v : -v : m < ws[1] ? p += g < f ? v : -v : p +=
				s < g ? v : -v : m < ws[0] ? p += f < e ? v : -v : p += s < f ? v : -v)
		}
		return p
	}

	function Ss(t, e, n, i, r, o, a, s) {
		if (e < s && i < s && o < s || s < e && s < i && s < o) return 0;
		c = xs, h = (l = e) - 2 * (u = i) + (h = o), u = 2 * (u - l), l -= s = s, s = 0, Nn(h) ? En(u) && 0 <= (
				p = -l / u) && p <= 1 && (c[s++] = p) : Nn(l = u * u - 4 * h * l) ? 0 <= (p = -u / (2 * h)) && p <=
			1 && (c[s++] = p) : 0 < l && (d = (-u - (l = kn(l))) / (2 * h), 0 <= (p = (-u + l) / (2 * h)) && p <=
				1 && (c[s++] = p), 0 <= d) && d <= 1 && (c[s++] = d);
		var l, u, h, c, p, d, f = s;
		if (0 === f) return 0;
		var g = Xn(e, i, o);
		if (0 <= g && g <= 1) {
			for (var y = 0, m = Wn(e, i, o, g), v = 0; v < f; v++) {
				var _ = 0 === xs[v] || 1 === xs[v] ? .5 : 1;
				Wn(t, n, r, xs[v]) < a || (xs[v] < g ? y += m < e ? _ : -_ : y += o < m ? _ : -_)
			}
			return y
		}
		return _ = 0 === xs[0] || 1 === xs[0] ? .5 : 1, Wn(t, n, r, xs[0]) < a ? 0 : o < e ? _ : -_
	}

	function Ms(t, e, n, i, r) {
		for (var o, a = t.data, s = t.len(), l = 0, u = 0, h = 0, c = 0, p = 0, d = 0; d < s;) {
			var f = a[d++],
				g = 1 === d;
			switch (f === ms.M && 1 < d && (n || (l += ys(u, h, c, p, i, r))), g && (c = u = a[d], p = h = a[d +
					1]), f) {
				case ms.M:
					u = c = a[d++], h = p = a[d++];
					break;
				case ms.L:
					if (n) {
						if (ps(u, h, a[d], a[d + 1], e, i, r)) return !0
					} else l += ys(u, h, a[d], a[d + 1], i, r) || 0;
					u = a[d++], h = a[d++];
					break;
				case ms.C:
					if (n) {
						if (function(t, e, n, i, r, o, a, s, l, u, h) {
								if (0 !== l) return !(e + (l = l) < h && i + l < h && o + l < h && s + l < h || h <
									e - l && h < i - l && h < o - l && h < s - l || t + l < u && n + l <
									u && r + l < u && a + l < u || u < t - l && u < n - l && u < r - l &&
									u < a - l) && Gn(t, e, n, i, r, o, a, s, u, h, null) <= l / 2
							}(u, h, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], e, i, r)) return !0
					} else l += bs(u, h, a[d++], a[d++], a[d++], a[d++], a[d], a[d + 1], i, r) || 0;
					u = a[d++], h = a[d++];
					break;
				case ms.Q:
					if (n) {
						if (function(t, e, n, i, r, o, a, s, l) {
								if (0 !== a) return !(e + (a = a) < l && i + a < l && o + a < l || l < e - a && l <
										i - a && l < o - a || t + a < s && n + a < s && r + a < s || s < t -
										a && s < n - a && s < r - a) && qn(t, e, n, i, r, o, s, l, null) <= a /
									2
							}(u, h, a[d++], a[d++], a[d], a[d + 1], e, i, r)) return !0
					} else l += Ss(u, h, a[d++], a[d++], a[d], a[d + 1], i, r) || 0;
					u = a[d++], h = a[d++];
					break;
				case ms.A:
					var y = a[d++],
						m = a[d++],
						v = a[d++],
						_ = a[d++],
						x = a[d++],
						w = a[d++],
						b = (d += 1, !!(1 - a[d++])),
						S = Math.cos(x) * v + y,
						M = Math.sin(x) * _ + m,
						T = (g ? (c = S, p = M) : l += ys(u, h, S, M, i, r), (i - y) * _ / v + y);
					if (n) {
						if (function(t, e, n, i, r, o, a, s, l) {
								if (0 !== a) return a = a, s -= t, l -= e, !(n < (t = Math.sqrt(s * s + l * l)) -
									a || t + a < n) && (Math.abs(i - r) % gs < 1e-4 || ((r = o ? (e = i, i =
										fs(r), fs(e)) : (i = fs(i), fs(r))) < i && (r += gs), (t = Math
										.atan2(l, s)) < 0 && (t += gs), i <= t && t <= r) || i <= t + gs &&
									t + gs <= r)
							}(y, m, _, x, x + w, b, e, T, r)) return !0
					} else l += function(t, e, n, i, r, o, a, s) {
						if ((s -= e) > n || s < -n) return 0;
						var e = Math.sqrt(n * n - s * s);
						if (xs[0] = -e, xs[1] = e, (n = Math.abs(i - r)) < 1e-4) return 0;
						if (vs - 1e-4 <= n) return r = vs, h = o ? 1 : -1, a >= xs[i = 0] + t && a <= xs[1] +
							t ? h : 0;
						r < i && (e = i, i = r, r = e), i < 0 && (i += vs, r += vs);
						for (var l = 0, u = 0; u < 2; u++) {
							var h, c = xs[u];
							a < c + t && (h = o ? 1 : -1, i <= (c = (c = Math.atan2(s, c)) < 0 ? vs + c : c) &&
								c <= r || i <= c + vs && c + vs <= r) && (l += h = c > Math.PI / 2 && c <
								1.5 * Math.PI ? -h : h)
						}
						return l
					}(y, m, _, x, x + w, b, T, r);
					u = Math.cos(x + w) * v + y, h = Math.sin(x + w) * _ + m;
					break;
				case ms.R:
					if (c = u = a[d++], p = h = a[d++], S = c + a[d++], M = p + a[d++], n) {
						if (ps(c, p, S, p, e, i, r) || ps(S, p, S, M, e, i, r) || ps(S, M, c, M, e, i, r) || ps(c,
								M, c, p, e, i, r)) return !0
					} else l = (l += ys(S, p, S, M, i, r)) + ys(c, M, c, p, i, r);
					break;
				case ms.Z:
					if (n) {
						if (ps(u, h, c, p, e, i, r)) return !0
					} else l += ys(u, h, c, p, i, r);
					u = c, h = p
			}
		}
		return n || (t = h, o = p, Math.abs(t - o) < _s) || (l += ys(u, h, c, p, i, r) || 0), 0 !== l
	}
	var Ts, Cs = B({
			fill: "#000",
			stroke: null,
			strokePercent: 1,
			fillOpacity: 1,
			strokeOpacity: 1,
			lineDashOffset: 0,
			lineWidth: 1,
			lineCap: "butt",
			miterLimit: 10,
			strokeNoScale: !1,
			strokeFirst: !1
		}, Pa),
		Is = {
			style: B({
				fill: !0,
				stroke: !0,
				strokePercent: !0,
				fillOpacity: !0,
				strokeOpacity: !0,
				lineDashOffset: !0,
				lineWidth: !0,
				miterLimit: !0
			}, La.style)
		},
		ks = Or.concat(["invisible", "culling", "z", "z2", "zlevel", "parent"]),
		Z = (u(a, Ts = n), a.prototype.update = function() {
			var e = this,
				t = (Ts.prototype.update.call(this), this.style);
			if (t.decal) {
				var n, i = this._decalEl = this._decalEl || new a,
					r = (i.buildPath === a.prototype.buildPath && (i.buildPath = function(t) {
						e.buildPath(t, e.shape)
					}), i.silent = !0, i.style);
				for (n in t) r[n] !== t[n] && (r[n] = t[n]);
				r.fill = t.fill ? t.decal : null, r.decal = null, r.shadowColor = null, t.strokeFirst && (r
					.stroke = null);
				for (var o = 0; o < ks.length; ++o) i[ks[o]] = this[ks[o]];
				i.__dirty |= vn
			} else this._decalEl && (this._decalEl = null)
		}, a.prototype.getDecalElement = function() {
			return this._decalEl
		}, a.prototype._init = function(t) {
			var e = R(t),
				n = (this.shape = this.getDefaultShape(), this.getDefaultStyle());
			n && this.useStyle(n);
			for (var i = 0; i < e.length; i++) {
				var r = e[i],
					o = t[r];
				"style" === r ? this.style ? O(this.style, o) : this.useStyle(o) : "shape" === r ? O(this.shape,
					o) : Ts.prototype.attrKV.call(this, r, o)
			}
			this.style || this.useStyle({})
		}, a.prototype.getDefaultStyle = function() {
			return null
		}, a.prototype.getDefaultShape = function() {
			return {}
		}, a.prototype.canBeInsideText = function() {
			return this.hasFill()
		}, a.prototype.getInsideTextFill = function() {
			var t, e = this.style.fill;
			if ("none" !== e) {
				if (H(e)) return .5 < (t = wi(e, 0)) ? Sr : .2 < t ? "#eee" : Mr;
				if (e) return Mr
			}
			return Sr
		}, a.prototype.getInsideTextStroke = function(t) {
			var e = this.style.fill;
			if (H(e)) {
				var n = this.__zr;
				if (!(!n || !n.isDarkMode()) == wi(t, 0) < .4) return e
			}
		}, a.prototype.buildPath = function(t, e, n) {}, a.prototype.pathUpdated = function() {
			this.__dirty &= ~_n
		}, a.prototype.getUpdatedPathProxy = function(t) {
			return this.path || this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this
				.shape, t), this.path
		}, a.prototype.createPathProxy = function() {
			this.path = new cs(!1)
		}, a.prototype.hasStroke = function() {
			var t = this.style,
				e = t.stroke;
			return !(null == e || "none" === e || !(0 < t.lineWidth))
		}, a.prototype.hasFill = function() {
			var t = this.style.fill;
			return null != t && "none" !== t
		}, a.prototype.getBoundingRect = function() {
			var t, e, n = this._rect,
				i = this.style,
				r = !n;
			return r && (t = !1, this.path || (t = !0, this.createPathProxy()), e = this.path, (t || this
					.__dirty & _n) && (e.beginPath(), this.buildPath(e, this.shape, !1), this
					.pathUpdated()), n = e.getBoundingRect()), this._rect = n, this.hasStroke() && this.path &&
				0 <
				this.path.len() ? (t = this._rectStroke || (this._rectStroke = n.clone()), (this.__dirty ||
						r) && (t.copy(n), e = i.strokeNoScale ? this.getLineScale() : 1, r = i.lineWidth, this
						.hasFill() || (i = this.strokeContainThreshold, r = Math.max(r, null == i ? 4 : i)),
						1e-10 < e) && (t.width += r / e, t.height += r / e, t.x -= r / e / 2, t.y -= r / e / 2),
					t) : n
		}, a.prototype.contain = function(t, e) {
			var n = this.transformCoordToLocal(t, e),
				i = this.getBoundingRect(),
				r = this.style;
			if (t = n[0], e = n[1], i.contain(t, e)) {
				n = this.path;
				if (this.hasStroke()) {
					i = r.lineWidth, r = r.strokeNoScale ? this.getLineScale() : 1;
					if (1e-10 < r && (this.hasFill() || (i = Math.max(i, this.strokeContainThreshold)), Ms(n,
							i / r, !0, t, e))) return !0
				}
				if (this.hasFill()) return Ms(n, 0, !1, t, e)
			}
			return !1
		}, a.prototype.dirtyShape = function() {
			this.__dirty |= _n, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(),
				this.markRedraw()
		}, a.prototype.dirty = function() {
			this.dirtyStyle(), this.dirtyShape()
		}, a.prototype.animateShape = function(t) {
			return this.animate("shape", t)
		}, a.prototype.updateDuringAnimation = function(t) {
			"style" === t ? this.dirtyStyle() : "shape" === t ? this.dirtyShape() : this.markRedraw()
		}, a.prototype.attrKV = function(t, e) {
			"shape" === t ? this.setShape(e) : Ts.prototype.attrKV.call(this, t, e)
		}, a.prototype.setShape = function(t, e) {
			var n = (n = this.shape) || (this.shape = {});
			return "string" == typeof t ? n[t] = e : O(n, t), this.dirtyShape(), this
		}, a.prototype.shapeChanged = function() {
			return !!(this.__dirty & _n)
		}, a.prototype.createStyle = function(t) {
			return zt(Cs, t)
		}, a.prototype._innerSaveToNormal = function(t) {
			Ts.prototype._innerSaveToNormal.call(this, t);
			var e = this._normalState;
			t.shape && !e.shape && (e.shape = O({}, this.shape))
		}, a.prototype._applyStateObj = function(t, e, n, i, r, o) {
			Ts.prototype._applyStateObj.call(this, t, e, n, i, r, o);
			var a, s = !(e && i);
			if (e && e.shape ? r ? i ? a = e.shape : (a = O({}, n.shape), O(a, e.shape)) : (a = O({}, (i ?
					this : n).shape), O(a, e.shape)) : s && (a = n.shape), a)
				if (r) {
					this.shape = O({}, this.shape);
					for (var l = {}, u = R(a), h = 0; h < u.length; h++) {
						var c = u[h];
						"object" == typeof a[c] ? this.shape[c] = a[c] : l[c] = a[c]
					}
					this._transitionState(t, {
						shape: l
					}, o)
				} else this.shape = a, this.dirtyShape()
		}, a.prototype._mergeStates = function(t) {
			for (var e, n = Ts.prototype._mergeStates.call(this, t), i = 0; i < t.length; i++) {
				var r = t[i];
				r.shape && this._mergeStyle(e = e || {}, r.shape)
			}
			return e && (n.shape = e), n
		}, a.prototype.getAnimationStyleProps = function() {
			return Is
		}, a.prototype.isZeroArea = function() {
			return !1
		}, a.extend = function(n) {
			u(r, i = a), r.prototype.getDefaultStyle = function() {
				return _(n.style)
			}, r.prototype.getDefaultShape = function() {
				return _(n.shape)
			};
			var i, t, e = r;

			function r(t) {
				var e = i.call(this, t) || this;
				return n.init && n.init.call(e, t), e
			}
			for (t in n) "function" == typeof n[t] && (e.prototype[t] = n[t]);
			return e
		}, a.initDefaultProps = ((Du = a.prototype).type = "path", Du.strokeContainThreshold = 5, Du
			.segmentIgnoreThreshold = 0, Du.subPixelOptimize = !1, Du.autoBatch = !1, void(Du.__dirty = 2 | vn |
				_n)), a);

	function a(t) {
		return Ts.call(this, t) || this
	}
	var Ds, As = B({
			strokeFirst: !0,
			font: K,
			x: 0,
			y: 0,
			textAlign: "left",
			textBaseline: "top",
			miterLimit: 2
		}, Cs),
		Ps = (u(Ls, Ds = n), Ls.prototype.hasStroke = function() {
			var t = this.style,
				e = t.stroke;
			return null != e && "none" !== e && 0 < t.lineWidth
		}, Ls.prototype.hasFill = function() {
			var t = this.style.fill;
			return null != t && "none" !== t
		}, Ls.prototype.createStyle = function(t) {
			return zt(As, t)
		}, Ls.prototype.setBoundingRect = function(t) {
			this._rect = t
		}, Ls.prototype.getBoundingRect = function() {
			var t, e = this.style;
			return this._rect || (null != (t = e.text) ? t += "" : t = "", (t = Br(t, e.font, e.textAlign, e
				.textBaseline)).x += e.x || 0, t.y += e.y || 0, this.hasStroke() && (e = e.lineWidth, t
				.x -= e / 2, t.y -= e / 2, t.width += e, t.height += e), this._rect = t), this._rect
		}, Ls.initDefaultProps = void(Ls.prototype.dirtyRectTolerance = 10), Ls);

	function Ls() {
		return null !== Ds && Ds.apply(this, arguments) || this
	}
	Ps.prototype.type = "tspan";
	var Os = B({
			x: 0,
			y: 0
		}, Pa),
		Rs = {
			style: B({
				x: !0,
				y: !0,
				width: !0,
				height: !0,
				sx: !0,
				sy: !0,
				sWidth: !0,
				sHeight: !0
			}, La.style)
		};
	u(zs, Ns = n), zs.prototype.createStyle = function(t) {
		return zt(Os, t)
	}, zs.prototype._getSize = function(t) {
		var e, n = this.style,
			i = n[t];
		return null != i ? i : (i = (i = n.image) && "string" != typeof i && i.width && i.height ? n.image :
				this.__image) ? null == (e = n[n = "width" === t ? "height" : "width"]) ? i[t] : i[t] / i[n] *
			e : 0
	}, zs.prototype.getWidth = function() {
		return this._getSize("width")
	}, zs.prototype.getHeight = function() {
		return this._getSize("height")
	}, zs.prototype.getAnimationStyleProps = function() {
		return Rs
	}, zs.prototype.getBoundingRect = function() {
		var t = this.style;
		return this._rect || (this._rect = new U(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this
			._rect
	};
	var Ns, Es = zs;

	function zs() {
		return null !== Ns && Ns.apply(this, arguments) || this
	}
	Es.prototype.type = "image";
	var Bs = Math.round;

	function Fs(t, e, n) {
		var i, r, o;
		if (e) return i = e.x1, r = e.x2, o = e.y1, e = e.y2, t.x1 = i, t.x2 = r, t.y1 = o, t.y2 = e, (n = n && n
			.lineWidth) && (Bs(2 * i) === Bs(2 * r) && (t.x1 = t.x2 = Hs(i, n, !0)), Bs(2 * o) === Bs(2 *
			e)) && (t.y1 = t.y2 = Hs(o, n, !0)), t
	}

	function Vs(t, e, n) {
		var i, r, o;
		if (e) return i = e.x, r = e.y, o = e.width, e = e.height, t.x = i, t.y = r, t.width = o, t.height = e, (n =
			n && n.lineWidth) && (t.x = Hs(i, n, !0), t.y = Hs(r, n, !0), t.width = Math.max(Hs(i + o, n, !
			1) - t.x, 0 === o ? 0 : 1), t.height = Math.max(Hs(r + e, n, !1) - t.y, 0 === e ? 0 : 1)), t
	}

	function Hs(t, e, n) {
		var i;
		return e ? ((i = Bs(2 * t)) + Bs(e)) % 2 == 0 ? i / 2 : (i + (n ? 1 : -1)) / 2 : t
	}

	function Gs() {
		this.x = 0, this.y = 0, this.width = 0, this.height = 0
	}
	var Ws, Us = {},
		Xs = (u(Ys, Ws = Z), Ys.prototype.getDefaultShape = function() {
			return new Gs
		}, Ys.prototype.buildPath = function(t, e) {
			var n, i, r, o, a, s, l, u, h, c, p, d, f, g;
			this.subPixelOptimize ? (n = (a = Vs(Us, e, this.style)).x, i = a.y, r = a.width, o = a.height, a
				.r = e.r, e = a) : (n = e.x, i = e.y, r = e.width, o = e.height), e.r ? (a = t, p = (e = e)
				.x, d = e.y, f = e.width, g = e.height, e = e.r, f < 0 && (p += f, f = -f), g < 0 && (d +=
					g, g = -g), "number" == typeof e ? s = l = u = h = e : e instanceof Array ? 1 === e
				.length ? s = l = u = h = e[0] : 2 === e.length ? (s = u = e[0], l = h = e[1]) : 3 === e
				.length ? (s = e[0], l = h = e[1], u = e[2]) : (s = e[0], l = e[1], u = e[2], h = e[3]) :
				s = l = u = h = 0, f < s + l && (s *= f / (c = s + l), l *= f / c), f < u + h && (u *= f / (
					c = u + h), h *= f / c), g < l + u && (l *= g / (c = l + u), u *= g / c), g < s + h && (
					s *= g / (c = s + h), h *= g / c), a.moveTo(p + s, d), a.lineTo(p + f - l, d), 0 !==
				l && a.arc(p + f - l, d + l, l, -Math.PI / 2, 0), a.lineTo(p + f, d + g - u), 0 !== u && a
				.arc(p + f - u, d + g - u, u, 0, Math.PI / 2), a.lineTo(p + h, d + g), 0 !== h && a.arc(p +
					h, d + g - h, h, Math.PI / 2, Math.PI), a.lineTo(p, d + s), 0 !== s && a.arc(p + s, d +
					s, s, Math.PI, 1.5 * Math.PI)) : t.rect(n, i, r, o)
		}, Ys.prototype.isZeroArea = function() {
			return !this.shape.width || !this.shape.height
		}, Ys);

	function Ys(t) {
		return Ws.call(this, t) || this
	}
	Xs.prototype.type = "rect";
	var qs, js = {
			fill: "#000"
		},
		Zs = {
			style: B({
				fill: !0,
				stroke: !0,
				fillOpacity: !0,
				strokeOpacity: !0,
				lineWidth: !0,
				fontSize: !0,
				lineHeight: !0,
				width: !0,
				height: !0,
				textShadowColor: !0,
				textShadowBlur: !0,
				textShadowOffsetX: !0,
				textShadowOffsetY: !0,
				backgroundColor: !0,
				padding: !0,
				borderColor: !0,
				borderWidth: !0,
				borderRadius: !0
			}, La.style)
		},
		Ks = (u(tl, qs = n), tl.prototype.childrenRef = function() {
			return this._children
		}, tl.prototype.update = function() {
			qs.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
			for (var t = 0; t < this._children.length; t++) {
				var e = this._children[t];
				e.zlevel = this.zlevel, e.z = this.z, e.z2 = this.z2, e.culling = this.culling, e.cursor = this
					.cursor, e.invisible = this.invisible
			}
		}, tl.prototype.updateTransform = function() {
			var t = this.innerTransformable;
			t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : qs.prototype
				.updateTransform.call(this)
		}, tl.prototype.getLocalTransform = function(t) {
			var e = this.innerTransformable;
			return e ? e.getLocalTransform(t) : qs.prototype.getLocalTransform.call(this, t)
		}, tl.prototype.getComputedTransform = function() {
			return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget
				.updateInnerText(!0)), qs.prototype.getComputedTransform.call(this)
		}, tl.prototype._updateSubTexts = function() {
			var t;
			this._childCursor = 0, rl(t = this.style), E(t.rich, rl), this.style.rich ? this
				._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this
				.styleUpdated()
		}, tl.prototype.addSelfToZr = function(t) {
			qs.prototype.addSelfToZr.call(this, t);
			for (var e = 0; e < this._children.length; e++) this._children[e].__zr = t
		}, tl.prototype.removeSelfFromZr = function(t) {
			qs.prototype.removeSelfFromZr.call(this, t);
			for (var e = 0; e < this._children.length; e++) this._children[e].__zr = null
		}, tl.prototype.getBoundingRect = function() {
			if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
				for (var t = new U(0, 0, 0, 0), e = this._children, n = [], i = null, r = 0; r < e
					.length; r++) {
					var o = e[r],
						a = o.getBoundingRect(),
						o = o.getLocalTransform(n);
					o ? (t.copy(a), t.applyTransform(o), (i = i || t.clone()).union(t)) : (i = i || a.clone())
						.union(a)
				}
				this._rect = i || t
			}
			return this._rect
		}, tl.prototype.setDefaultTextStyle = function(t) {
			this._defaultStyle = t || js
		}, tl.prototype.setTextContent = function(t) {}, tl.prototype._mergeStyle = function(t, e) {
			var n, i;
			return e && (n = e.rich, i = t.rich || n && {}, O(t, e), n && i ? (this._mergeRich(i, n), t.rich =
				i) : i && (t.rich = i)), t
		}, tl.prototype._mergeRich = function(t, e) {
			for (var n = R(e), i = 0; i < n.length; i++) {
				var r = n[i];
				t[r] = t[r] || {}, O(t[r], e[r])
			}
		}, tl.prototype.getAnimationStyleProps = function() {
			return Zs
		}, tl.prototype._getOrCreateChild = function(t) {
			var e = this._children[this._childCursor];
			return e && e instanceof t || (e = new t), (this._children[this._childCursor++] = e).__zr = this
				.__zr, e.parent = this, e
		}, tl.prototype._updatePlainTexts = function() {
			var t, e = this.style,
				n = e.font || K,
				i = e.padding,
				r = function(t, e) {
					null != t && (t += "");
					var n, i = e.overflow,
						r = e.padding,
						o = e.font,
						a = "truncate" === i,
						s = Hr(o),
						l = N(e.lineHeight, s),
						u = !!e.backgroundColor,
						h = "truncate" === e.lineOverflow,
						c = e.width,
						i = (n = null == c || "break" !== i && "breakAll" !== i ? t ? t.split("\n") : [] : t ?
							ka(t, e.font, c, "breakAll" === i, 0).lines : []).length * l,
						p = N(e.height, i);
					if (p < i && h && (h = Math.floor(p / l), n = n.slice(0, h)), t && a && null != c)
						for (var d = xa(c, o, e.ellipsis, {
								minChar: e.truncateMinChar,
								placeholder: e.placeholder
							}), f = 0; f < n.length; f++) n[f] = wa(n[f], d);
					for (var h = p, g = 0, f = 0; f < n.length; f++) g = Math.max(Er(n[f], o), g);
					return null == c && (c = g), t = g, r && (h += r[0] + r[2], t += r[1] + r[3], c += r[1] + r[
						3]), {
						lines: n,
						height: p,
						outerWidth: t = u ? c : t,
						outerHeight: h,
						lineHeight: l,
						calculatedLineHeight: s,
						contentWidth: g,
						contentHeight: i,
						width: c
					}
				}(ll(e), e),
				o = ul(e),
				a = !!e.backgroundColor,
				s = r.outerHeight,
				l = r.outerWidth,
				u = r.contentWidth,
				h = r.lines,
				c = r.lineHeight,
				p = this._defaultStyle,
				d = e.x || 0,
				f = e.y || 0,
				g = e.align || p.align || "left",
				y = e.verticalAlign || p.verticalAlign || "top",
				m = d,
				v = Vr(f, r.contentHeight, y);
			(o || i) && (t = Fr(d, l, g), f = Vr(f, s, y), o) && this._renderBackground(e, e, t, f, l, s), v +=
				c / 2, i && (m = sl(d, g, i), "top" === y ? v += i[0] : "bottom" === y && (v -= i[2]));
			for (var _ = 0, o = !1, x = (al(("fill" in e ? e : (o = !0, p)).fill)), w = (ol("stroke" in e ? e
						.stroke : a || p.autoStroke && !o ? null : (_ = 2, p.stroke))), b = 0 < e
					.textShadowBlur, S = null != e.width && ("truncate" === e.overflow || "break" === e
						.overflow || "breakAll" === e.overflow), M = r.calculatedLineHeight, T = 0; T < h
				.length; T++) {
				var C = this._getOrCreateChild(Ps),
					I = C.createStyle();
				C.useStyle(I), I.text = h[T], I.x = m, I.y = v, g && (I.textAlign = g), I.textBaseline =
					"middle", I.opacity = e.opacity, I.strokeFirst = !0, b && (I.shadowBlur = e
						.textShadowBlur || 0, I.shadowColor = e.textShadowColor || "transparent", I
						.shadowOffsetX = e.textShadowOffsetX || 0, I.shadowOffsetY = e.textShadowOffsetY || 0),
					I.stroke = w, I.fill = x, w && (I.lineWidth = e.lineWidth || _, I.lineDash = e.lineDash, I
						.lineDashOffset = e.lineDashOffset || 0), I.font = n, nl(I, e), v += c, S && C
					.setBoundingRect(new U(Fr(I.x, e.width, I.textAlign), Vr(I.y, M, I.textBaseline), u, M))
			}
		}, tl.prototype._updateRichTexts = function() {
			var t = this.style,
				e = Ta(ll(t), t),
				n = e.width,
				i = e.outerWidth,
				r = e.outerHeight,
				o = t.padding,
				a = t.x || 0,
				s = t.y || 0,
				l = this._defaultStyle,
				u = t.align || l.align,
				l = t.verticalAlign || l.verticalAlign,
				a = Fr(a, i, u),
				u = Vr(s, r, l),
				h = a,
				c = u,
				p = (o && (h += o[3], c += o[0]), h + n);
			ul(t) && this._renderBackground(t, t, a, u, i, r);
			for (var d = !!t.backgroundColor, f = 0; f < e.lines.length; f++) {
				for (var g = e.lines[f], y = g.tokens, m = y.length, v = g.lineHeight, _ = g.width, x = 0, w =
						h, b = p, S = m - 1, M = void 0; x < m && (!(M = y[x]).align || "left" === M.align);)
					this._placeToken(M, t, v, c, w, "left", d), _ -= M.width, w += M.width, x++;
				for (; 0 <= S && "right" === (M = y[S]).align;) this._placeToken(M, t, v, c, b, "right", d),
					_ -= M.width, b -= M.width, S--;
				for (w += (n - (w - h) - (p - b) - _) / 2; x <= S;) M = y[x], this._placeToken(M, t, v, c, w + M
					.width / 2, "center", d), w += M.width, x++;
				c += v
			}
		}, tl.prototype._placeToken = function(t, e, n, i, r, o, a) {
			var s = e.rich[t.styleName] || {},
				l = (s.text = t.text, t.verticalAlign),
				u = i + n / 2,
				l = ("top" === l ? u = i + t.height / 2 : "bottom" === l && (u = i + n - t.height / 2), !t
					.isLineHolder && ul(s) && this._renderBackground(s, e, "right" === o ? r - t.width :
						"center" === o ? r - t.width / 2 : r, u - t.height / 2, t.width, t.height), !!s
					.backgroundColor),
				i = t.textPadding,
				n = (i && (r = sl(r, o, i), u -= t.height / 2 - i[0] - t.innerHeight / 2), this
					._getOrCreateChild(Ps)),
				i = n.createStyle(),
				h = (n.useStyle(i), this._defaultStyle),
				c = !1,
				p = 0,
				d = al(("fill" in s ? s : "fill" in e ? e : (c = !0, h)).fill),
				l = ol("stroke" in s ? s.stroke : "stroke" in e ? e.stroke : l || a || h.autoStroke && !c ?
					null : (p = 2, h.stroke)),
				a = 0 < s.textShadowBlur || 0 < e.textShadowBlur,
				c = (i.text = t.text, i.x = r, i.y = u, a && (i.shadowBlur = s.textShadowBlur || e
						.textShadowBlur || 0, i.shadowColor = s.textShadowColor || e.textShadowColor ||
						"transparent", i.shadowOffsetX = s.textShadowOffsetX || e.textShadowOffsetX || 0, i
						.shadowOffsetY = s.textShadowOffsetY || e.textShadowOffsetY || 0), i.textAlign = o, i
					.textBaseline = "middle", i.font = t.font || K, i.opacity = St(s.opacity, e.opacity, 1), nl(
						i, s), l && (i.lineWidth = St(s.lineWidth, e.lineWidth, p), i.lineDash = N(s.lineDash, e
						.lineDash), i.lineDashOffset = e.lineDashOffset || 0, i.stroke = l), d && (i.fill = d),
					t.contentWidth),
				h = t.contentHeight;
			n.setBoundingRect(new U(Fr(i.x, c, i.textAlign), Vr(i.y, h, i.textBaseline), c, h))
		}, tl.prototype._renderBackground = function(t, e, n, i, r, o) {
			var a, s, l, u, h = t.backgroundColor,
				c = t.borderWidth,
				p = t.borderColor,
				d = h && h.image,
				f = h && !d,
				g = t.borderRadius,
				y = this,
				g = ((f || t.lineHeight || c && p) && ((a = this._getOrCreateChild(Xs)).useStyle(a
							.createStyle()), a.style.fill = null, (u = a.shape).x = n, u.y = i, u.width = r, u
						.height = o, u.r = g, a.dirtyShape()), f ? ((l = a.style).fill = h || null, l
						.fillOpacity = N(t.fillOpacity, 1)) : d && ((s = this._getOrCreateChild(Es)).onload =
						function() {
							y.dirtyStyle()
						}, (u = s.style).image = h.image, u.x = n, u.y = i, u.width = r, u.height = o), c &&
					p && ((l = a.style).lineWidth = c, l.stroke = p, l.strokeOpacity = N(t.strokeOpacity, 1), l
						.lineDash = t.borderDash, l.lineDashOffset = t.borderDashOffset || 0, a
						.strokeContainThreshold = 0, a.hasFill()) && a.hasStroke() && (l.strokeFirst = !0, l
						.lineWidth *= 2), (a || s).style);
			g.shadowBlur = t.shadowBlur || 0, g.shadowColor = t.shadowColor || "transparent", g.shadowOffsetX =
				t.shadowOffsetX || 0, g.shadowOffsetY = t.shadowOffsetY || 0, g.opacity = St(t.opacity, e
					.opacity, 1)
		}, tl.makeFont = function(t) {
			var e = "";
			return (e = il(t) ? [t.fontStyle, t.fontWeight, el(t.fontSize), t.fontFamily || "sans-serif"].join(
				" ") : e) && It(e) || t.textFont || t.font
		}, tl),
		$s = {
			left: !0,
			right: 1,
			center: 1
		},
		Qs = {
			top: 1,
			bottom: 1,
			middle: 1
		},
		Js = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];

	function tl(t) {
		var e = qs.call(this) || this;
		return e.type = "text", e._children = [], e._defaultStyle = js, e.attr(t), e
	}

	function el(t) {
		return "string" != typeof t || -1 === t.indexOf("px") && -1 === t.indexOf("rem") && -1 === t.indexOf("em") ?
			isNaN(+t) ? x + "px" : t + "px" : t
	}

	function nl(t, e) {
		for (var n = 0; n < Js.length; n++) {
			var i = Js[n],
				r = e[i];
			null != r && (t[i] = r)
		}
	}

	function il(t) {
		return null != t.fontSize || t.fontFamily || t.fontWeight
	}

	function rl(t) {
		var e;
		t && (t.font = Ks.makeFont(t), e = t.align, t.align = null == (e = "middle" === e ? "center" : e) || $s[e] ?
			e : "left", e = t.verticalAlign, t.verticalAlign = null == (e = "center" === e ? "middle" : e) ||
			Qs[e] ? e : "top", t.padding) && (t.padding = Tt(t.padding))
	}

	function ol(t, e) {
		return null == t || e <= 0 || "transparent" === t || "none" === t ? null : t.image || t.colorStops ?
			"#000" : t
	}

	function al(t) {
		return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
	}

	function sl(t, e, n) {
		return "right" === e ? t - n[1] : "center" === e ? t + n[3] / 2 - n[1] / 2 : t + n[3]
	}

	function ll(t) {
		t = t.text;
		return null != t && (t += ""), t
	}

	function ul(t) {
		return !!(t.backgroundColor || t.lineHeight || t.borderWidth && t.borderColor)
	}
	var k = Yo(),
		hl = 1,
		cl = {},
		pl = Yo(),
		dl = Yo(),
		fl = 0,
		gl = 1,
		yl = 2,
		ml = ["emphasis", "blur", "select"],
		vl = ["normal", "emphasis", "blur", "select"],
		_l = "highlight",
		xl = "downplay",
		wl = "select",
		bl = "unselect",
		Sl = "toggleSelect";

	function Ml(t) {
		return null != t && "none" !== t
	}
	var Tl = new ei(100);

	function Cl(t) {
		var e;
		return H(t) ? ((e = Tl.get(t)) || (e = mi(t, -.1), Tl.put(t, e)), e) : vt(t) ? ((e = O({}, t)).colorStops =
			F(t.colorStops, function(t) {
				return {
					offset: t.offset,
					color: mi(t.color, -.1)
				}
			}), e) : t
	}

	function Il(t, e, n) {
		t.onHoverStateChange && (t.hoverState || 0) !== n && t.onHoverStateChange(e), t.hoverState = n
	}

	function kl(t) {
		Il(t, "emphasis", yl)
	}

	function Dl(t) {
		t.hoverState === yl && Il(t, "normal", fl)
	}

	function Al(t) {
		Il(t, "blur", gl)
	}

	function Pl(t) {
		t.hoverState === gl && Il(t, "normal", fl)
	}

	function Ll(t) {
		t.selected = !0
	}

	function Ol(t) {
		t.selected = !1
	}

	function Rl(t, e, n) {
		e(t, n)
	}

	function Nl(t, e, n) {
		Rl(t, e, n), t.isGroup && t.traverse(function(t) {
			Rl(t, e, n)
		})
	}

	function El(t, e) {
		switch (e) {
			case "emphasis":
				t.hoverState = yl;
				break;
			case "normal":
				t.hoverState = fl;
				break;
			case "blur":
				t.hoverState = gl;
				break;
			case "select":
				t.selected = !0
		}
	}

	function zl(t, e, n) {
		var i = 0 <= I(t.currentStates, e),
			r = t.style.opacity,
			t = i ? null : function(t, e, n, i) {
				for (var r = t.style, o = {}, a = 0; a < e.length; a++) {
					var s = e[a],
						l = r[s];
					o[s] = null == l ? i && i[s] : l
				}
				for (a = 0; a < t.animators.length; a++) {
					var u = t.animators[a];
					u.__fromStateTransition && u.__fromStateTransition.indexOf(n) < 0 && "style" === u.targetName &&
						u.saveTo(o, e)
				}
				return o
			}(t, ["opacity"], e, {
				opacity: 1
			}),
			e = (n = n || {}).style || {};
		return null == e.opacity && (n = O({}, n), e = O({
			opacity: i ? r : .1 * t.opacity
		}, e), n.style = e), n
	}

	function Bl(t, e) {
		var n, i, r, o, a, s = this.states[t];
		if (this.style) {
			if ("emphasis" === t) return n = this, i = s, e = (e = e) && 0 <= I(e, "select"), a = !1,
				n instanceof Z && (r = pl(n), o = e && r.selectFill || r.normalFill, e = e && r.selectStroke ||
					r.normalStroke, Ml(o) || Ml(e)) && ("inherit" === (r = (i = i || {}).style || {}).fill ? (
					a = !0, i = O({}, i), (r = O({}, r)).fill = o) : !Ml(r.fill) && Ml(o) ? (a = !0, i =
					O({}, i), (r = O({}, r)).fill = Cl(o)) : !Ml(r.stroke) && Ml(e) && (a || (i = O({}, i),
					r =
					O({}, r)), r.stroke = Cl(e)), i.style = r), i && null == i.z2 && (a || (i = O({}, i)), o = n
					.z2EmphasisLift, i.z2 = n.z2 + (null != o ? o : 10)), i;
			if ("blur" === t) return zl(this, t, s);
			if ("select" === t) return e = this, (r = s) && null == r.z2 && (r = O({}, r), a = e.z2SelectLift, r
				.z2 = e.z2 + (null != a ? a : 9)), r
		}
		return s
	}

	function Fl(t) {
		t.stateProxy = Bl;
		var e = t.getTextContent(),
			t = t.getTextGuideLine();
		e && (e.stateProxy = Bl), t && (t.stateProxy = Bl)
	}

	function Vl(t, e) {
		ql(t, e) || t.__highByOuter || Nl(t, kl)
	}

	function Hl(t, e) {
		ql(t, e) || t.__highByOuter || Nl(t, Dl)
	}

	function Gl(t, e) {
		t.__highByOuter |= 1 << (e || 0), Nl(t, kl)
	}

	function Wl(t, e) {
		(t.__highByOuter &= ~(1 << (e || 0))) || Nl(t, Dl)
	}

	function Ul(t) {
		Nl(t, Pl)
	}

	function Xl(t) {
		Nl(t, Ll)
	}

	function Yl(t) {
		Nl(t, Ol)
	}

	function ql(t, e) {
		return t.__highDownSilentOnTouch && e.zrByTouch
	}

	function jl(r) {
		var e = r.getModel(),
			o = [],
			a = [];
		e.eachComponent(function(t, e) {
			var n = dl(e),
				t = "series" === t,
				i = t ? r.getViewOfSeriesModel(e) : r.getViewOfComponentModel(e);
			t || a.push(i), n.isBlured && (i.group.traverse(function(t) {
				Pl(t)
			}), t) && o.push(e), n.isBlured = !1
		}), E(a, function(t) {
			t && t.toggleBlurSeries && t.toggleBlurSeries(o, !1, e)
		})
	}

	function Zl(t, o, a, s) {
		var l, u, h, n = s.getModel();

		function c(t, e) {
			for (var n = 0; n < e.length; n++) {
				var i = t.getItemGraphicEl(e[n]);
				i && Ul(i)
			}
		}
		a = a || "coordinateSystem", null != t && o && "none" !== o && (l = n.getSeriesByIndex(t), (u = l
			.coordinateSystem) && u.master && (u = u.master), h = [], n.eachSeries(function(t) {
			var e = l === t,
				n = t.coordinateSystem;
			if (n && n.master && (n = n.master), !("series" === a && !e || "coordinateSystem" === a && !
					(n && u ? n === u : e) || "series" === o && e)) {
				if (s.getViewOfSeriesModel(t).group.traverse(function(t) {
						t.__highByOuter && e && "self" === o || Al(t)
					}), ut(o)) c(t.getData(), o);
				else if (L(o))
					for (var i = R(o), r = 0; r < i.length; r++) c(t.getData(i[r]), o[i[r]]);
				h.push(t), dl(t).isBlured = !0
			}
		}), n.eachComponent(function(t, e) {
			"series" !== t && (t = s.getViewOfComponentModel(e)) && t.toggleBlurSeries && t
				.toggleBlurSeries(h, !0, n)
		}))
	}

	function Kl(t, e, n) {
		null != t && null != e && (t = n.getModel().getComponent(t, e)) && (dl(t).isBlured = !0, e = n
			.getViewOfComponentModel(t)) && e.focusBlurEnabled && e.group.traverse(function(t) {
			Al(t)
		})
	}

	function $l(t, e, n, i) {
		var r = {
			focusSelf: !1,
			dispatchers: null
		};
		if (null == t || "series" === t || null == e || null == n) return r;
		t = i.getModel().getComponent(t, e);
		if (!t) return r;
		e = i.getViewOfComponentModel(t);
		if (!e || !e.findHighDownDispatchers) return r;
		for (var o, a = e.findHighDownDispatchers(n), s = 0; s < a.length; s++)
			if ("self" === k(a[s]).focus) {
				o = !0;
				break
			} return {
			focusSelf: o,
			dispatchers: a
		}
	}

	function Ql(i) {
		E(i.getAllData(), function(t) {
			var e = t.data,
				n = t.type;
			e.eachItemGraphicEl(function(t, e) {
				(i.isSelected(e, n) ? Xl : Yl)(t)
			})
		})
	}

	function Jl(t, e, n) {
		ru(t, !0), Nl(t, Fl);
		t = k(t), null != e ? (t.focus = e, t.blurScope = n) : t.focus && (t.focus = null)
	}

	function tu(t, e, n, i) {
		i ? ru(t, !1) : Jl(t, e, n)
	}
	var eu = ["emphasis", "blur", "select"],
		nu = {
			itemStyle: "getItemStyle",
			lineStyle: "getLineStyle",
			areaStyle: "getAreaStyle"
		};

	function iu(t, e, n, i) {
		n = n || "itemStyle";
		for (var r = 0; r < eu.length; r++) {
			var o = eu[r],
				a = e.getModel([o, n]);
			t.ensureState(o).style = i ? i(a) : a[nu[n]]()
		}
	}

	function ru(t, e) {
		var e = !1 === e,
			n = t;
		t.highDownSilentOnTouch && (n.__highDownSilentOnTouch = t.highDownSilentOnTouch), e && !n
			.__highDownDispatcher || (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !e)
	}

	function ou(t) {
		return !(!t || !t.__highDownDispatcher)
	}

	function au(t) {
		t = t.type;
		return t === wl || t === bl || t === Sl
	}

	function su(t) {
		t = t.type;
		return t === _l || t === xl
	}
	var lu = cs.CMD,
		uu = [
			[],
			[],
			[]
		],
		hu = Math.sqrt,
		cu = Math.atan2;
	var pu = Math.sqrt,
		du = Math.sin,
		fu = Math.cos,
		gu = Math.PI;

	function yu(t) {
		return Math.sqrt(t[0] * t[0] + t[1] * t[1])
	}

	function mu(t, e) {
		return (t[0] * e[0] + t[1] * e[1]) / (yu(t) * yu(e))
	}

	function vu(t, e) {
		return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(mu(t, e))
	}

	function _u(t, e, n, i, r, o, a, s, l, u, h) {
		var l = l * (gu / 180),
			c = fu(l) * (t - n) / 2 + du(l) * (e - i) / 2,
			p = -1 * du(l) * (t - n) / 2 + fu(l) * (e - i) / 2,
			d = c * c / (a * a) + p * p / (s * s),
			d = (1 < d && (a *= pu(d), s *= pu(d)), (r === o ? -1 : 1) * pu((a * a * (s * s) - a * a * (p * p) - s *
				s * (c * c)) / (a * a * (p * p) + s * s * (c * c))) || 0),
			r = d * a * p / s,
			d = d * -s * c / a,
			t = (t + n) / 2 + fu(l) * r - du(l) * d,
			n = (e + i) / 2 + du(l) * r + fu(l) * d,
			e = vu([1, 0], [(c - r) / a, (p - d) / s]),
			i = [(c - r) / a, (p - d) / s],
			c = [(-1 * c - r) / a, (-1 * p - d) / s],
			r = vu(i, c);
		mu(i, c) <= -1 && (r = gu), (r = 1 <= mu(i, c) ? 0 : r) < 0 && (p = Math.round(r / gu * 1e6) / 1e6, r = 2 *
			gu + p % 2 * gu), h.addData(u, t, n, a, s, e, r, l, o)
	}
	var xu = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi,
		wu = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
	u(Mu, bu = Z), Mu.prototype.applyTransform = function(t) {};
	var bu, Su = Mu;

	function Mu() {
		return null !== bu && bu.apply(this, arguments) || this
	}

	function Tu(t) {
		return null != t.setData
	}

	function Cu(t, e) {
		var S = function(t) {
				var e = new cs;
				if (t) {
					var n, i = 0,
						r = 0,
						o = i,
						a = r,
						s = cs.CMD,
						l = t.match(xu);
					if (l) {
						for (var u = 0; u < l.length; u++) {
							for (var h = l[u], c = h.charAt(0), p = void 0, d = h.match(wu) || [], f = d.length, g =
									0; g < f; g++) d[g] = parseFloat(d[g]);
							for (var y = 0; y < f;) {
								var m = void 0,
									v = void 0,
									_ = void 0,
									x = void 0,
									w = void 0,
									b = void 0,
									S = void 0,
									M = i,
									T = r,
									C = void 0,
									I = void 0;
								switch (c) {
									case "l":
										i += d[y++], r += d[y++], p = s.L, e.addData(p, i, r);
										break;
									case "L":
										i = d[y++], r = d[y++], p = s.L, e.addData(p, i, r);
										break;
									case "m":
										i += d[y++], r += d[y++], p = s.M, e.addData(p, i, r), o = i, a = r, c =
											"l";
										break;
									case "M":
										i = d[y++], r = d[y++], p = s.M, e.addData(p, i, r), o = i, a = r, c = "L";
										break;
									case "h":
										i += d[y++], p = s.L, e.addData(p, i, r);
										break;
									case "H":
										i = d[y++], p = s.L, e.addData(p, i, r);
										break;
									case "v":
										r += d[y++], p = s.L, e.addData(p, i, r);
										break;
									case "V":
										r = d[y++], p = s.L, e.addData(p, i, r);
										break;
									case "C":
										p = s.C, e.addData(p, d[y++], d[y++], d[y++], d[y++], d[y++], d[y++]), i =
											d[y - 2], r = d[y - 1];
										break;
									case "c":
										p = s.C, e.addData(p, d[y++] + i, d[y++] + r, d[y++] + i, d[y++] + r, d[
											y++] + i, d[y++] + r), i += d[y - 2], r += d[y - 1];
										break;
									case "S":
										m = i, v = r, C = e.len(), I = e.data, n === s.C && (m += i - I[C - 4], v +=
											r - I[C - 3]), p = s.C, M = d[y++], T = d[y++], i = d[y++], r = d[
											y++], e.addData(p, m, v, M, T, i, r);
										break;
									case "s":
										m = i, v = r, C = e.len(), I = e.data, n === s.C && (m += i - I[C - 4], v +=
												r - I[C - 3]), p = s.C, M = i + d[y++], T = r + d[y++], i += d[y++],
											r += d[y++], e.addData(p, m, v, M, T, i, r);
										break;
									case "Q":
										M = d[y++], T = d[y++], i = d[y++], r = d[y++], p = s.Q, e.addData(p, M, T,
											i, r);
										break;
									case "q":
										M = d[y++] + i, T = d[y++] + r, i += d[y++], r += d[y++], p = s.Q, e
											.addData(p, M, T, i, r);
										break;
									case "T":
										m = i, v = r, C = e.len(), I = e.data, n === s.Q && (m += i - I[C - 4], v +=
											r - I[C - 3]), i = d[y++], r = d[y++], p = s.Q, e.addData(p, m, v,
											i, r);
										break;
									case "t":
										m = i, v = r, C = e.len(), I = e.data, n === s.Q && (m += i - I[C - 4], v +=
											r - I[C - 3]), i += d[y++], r += d[y++], p = s.Q, e.addData(p, m, v,
											i, r);
										break;
									case "A":
										_ = d[y++], x = d[y++], w = d[y++], b = d[y++], S = d[y++], _u(M = i, T = r,
											i = d[y++], r = d[y++], b, S, _, x, w, p = s.A, e);
										break;
									case "a":
										_ = d[y++], x = d[y++], w = d[y++], b = d[y++], S = d[y++], _u(M = i, T = r,
											i += d[y++], r += d[y++], b, S, _, x, w, p = s.A, e)
								}
							}
							"z" !== c && "Z" !== c || (p = s.Z, e.addData(p), i = o, r = a), n = p
						}
						e.toStatic()
					}
				}
				return e
			}(t),
			t = O({}, e);
		return t.buildPath = function(t) {
			var e;
			Tu(t) ? (t.setData(S.data), (e = t.getContext()) && t.rebuildPath(e, 1)) : S.rebuildPath(e = t, 1)
		}, t.applyTransform = function(t) {
			var e = S,
				n = t;
			if (n) {
				for (var i, r, o, a, s = e.data, l = e.len(), u = lu.M, h = lu.C, c = lu.L, p = lu.R, d = lu.A,
						f = lu.Q, g = 0, y = 0; g < l;) {
					switch (i = s[g++], y = g, r = 0, i) {
						case u:
						case c:
							r = 1;
							break;
						case h:
							r = 3;
							break;
						case f:
							r = 2;
							break;
						case d:
							var m = n[4],
								v = n[5],
								_ = hu(n[0] * n[0] + n[1] * n[1]),
								x = hu(n[2] * n[2] + n[3] * n[3]),
								w = cu(-n[1] / x, n[0] / _);
							s[g] *= _, s[g++] += m, s[g] *= x, s[g++] += v, s[g++] *= _, s[g++] *= x, s[g++] +=
								w, s[g++] += w, y = g += 2;
							break;
						case p:
							a[0] = s[g++], a[1] = s[g++], ne(a, a, n), s[y++] = a[0], s[y++] = a[1], a[0] += s[
								g++], a[1] += s[g++], ne(a, a, n), s[y++] = a[0], s[y++] = a[1]
					}
					for (o = 0; o < r; o++) {
						var b = uu[o];
						b[0] = s[g++], b[1] = s[g++], ne(b, b, n), s[y++] = b[0], s[y++] = b[1]
					}
				}
				e.increaseVersion()
			}
			this.dirtyShape()
		}, t
	}

	function Iu() {
		this.cx = 0, this.cy = 0, this.r = 0
	}
	u(Au, ku = Z), Au.prototype.getDefaultShape = function() {
		return new Iu
	}, Au.prototype.buildPath = function(t, e) {
		t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI)
	};
	var ku, Du = Au;

	function Au(t) {
		return ku.call(this, t) || this
	}
	Du.prototype.type = "circle";

	function Pu() {
		this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0
	}
	u(Ru, Lu = Z), Ru.prototype.getDefaultShape = function() {
		return new Pu
	}, Ru.prototype.buildPath = function(t, e) {
		var n = e.cx,
			i = e.cy,
			r = e.rx,
			e = e.ry,
			o = .5522848 * r,
			a = .5522848 * e;
		t.moveTo(n - r, i), t.bezierCurveTo(n - r, i - a, n - o, i - e, n, i - e), t.bezierCurveTo(n + o, i - e,
			n + r, i - a, n + r, i), t.bezierCurveTo(n + r, i + a, n + o, i + e, n, i + e), t.bezierCurveTo(
			n - o, i + e, n - r, i + a, n - r, i), t.closePath()
	};
	var Lu, Ou = Ru;

	function Ru(t) {
		return Lu.call(this, t) || this
	}
	Ou.prototype.type = "ellipse";
	var Nu = Math.PI,
		Eu = 2 * Nu,
		zu = Math.sin,
		Bu = Math.cos,
		Fu = Math.acos,
		Vu = Math.atan2,
		Hu = Math.abs,
		Gu = Math.sqrt,
		Wu = Math.max,
		Uu = Math.min,
		Xu = 1e-4;

	function Yu(t, e, n, i, r, o, a) {
		var s = t - n,
			l = e - i,
			a = (a ? o : -o) / Gu(s * s + l * l),
			l = a * l,
			a = -a * s,
			s = t + l,
			t = e + a,
			e = n + l,
			n = i + a,
			i = (s + e) / 2,
			u = (t + n) / 2,
			h = e - s,
			c = n - t,
			p = h * h + c * c,
			o = r - o,
			s = s * n - e * t,
			n = (c < 0 ? -1 : 1) * Gu(Wu(0, o * o * p - s * s)),
			e = (s * c - h * n) / p,
			t = (-s * h - c * n) / p,
			d = (s * c + h * n) / p,
			s = (-s * h + c * n) / p,
			h = e - i,
			c = t - u,
			n = d - i,
			p = s - u;
		return n * n + p * p < h * h + c * c && (e = d, t = s), {
			cx: e,
			cy: t,
			x0: -l,
			y0: -a,
			x1: e * (r / o - 1),
			y1: t * (r / o - 1)
		}
	}

	function qu(t, e) {
		var n, i, r, o, a, s, l, u, h, c, p, d, f, g, y, m, v, _, x, w, b, S, M, T, C, I, k, D, A, P, L = Wu(e.r,
				0),
			O = Wu(e.r0 || 0, 0),
			R = 0 < L;
		(R || 0 < O) && (R || (L = O, O = 0), L < O && (R = L, L = O, O = R), R = e.startAngle, n = e.endAngle,
			isNaN(R) || isNaN(n) || (i = e.cx, r = e.cy, o = !!e.clockwise, w = Hu(n - R), Xu < (a = Eu < w && w %
				Eu) && (w = a), Xu < L ? Eu - Xu < w ? (t.moveTo(i + L * Bu(R), r + L * zu(R)), t.arc(i, r, L,
				R, n, !o), Xu < O && (t.moveTo(i + O * Bu(n), r + O * zu(n)), t.arc(i, r, O, n, R, o))) : (g =
				f = d = p = S = b = c = h = I = C = T = M = u = l = s = a = void 0, y = L * Bu(R), m = L * zu(
					R), v = O * Bu(n), _ = O * zu(n), (x = Xu < w) && ((e = e.cornerRadius) && (a = (e =
						function(
							t) {
							if (V(t)) {
								var e = t.length;
								if (!e) return t;
								e = 1 === e ? [t[0], t[0], 0, 0] : 2 === e ? [t[0], t[0], t[1], t[1]] :
									3 === e ? t.concat(t[2]) : t
							} else e = [t, t, t, t];
							return e
						}(e))[0], s = e[1], l = e[2], u = e[3]), e = Hu(L - O) / 2, M = Uu(e, l), T = Uu(e, u),
					C =
					Uu(e, a), I = Uu(e, s), b = h = Wu(M, T), S = c = Wu(C, I), Xu < h || Xu < c) && (p = L *
					Bu(n), d = L * zu(n), f = O * Bu(R), g = O * zu(R), w < Nu) && ((e = function(t, e, n, i, r,
					o, a, s) {
					var l = (s = s - o) * (n = n - t) - (a = a - r) * (i = i - e);
					if (!(l * l < Xu)) return [t + (l = (a * (e - o) - s * (t - r)) / l) * n, e + l * i]
				}(y, m, f, g, p, d, v, _)) && (M = y - e[0], T = m - e[1], C = p - e[0], I = d - e[1], w =
					1 / zu(Fu((M * C + T * I) / (Gu(M * M + T * T) * Gu(C * C + I * I))) / 2), M = Gu(e[0] *
						e[0] + e[1] * e[1]), b = Uu(h, (L - M) / (1 + w)), S = Uu(c, (O - M) / (w - 1)))), x ?
				Xu < b ? (k = Uu(l, b), D = Uu(u, b), A = Yu(f, g, y, m, L, k, o), P = Yu(p, d, v, _, L, D, o),
					t.moveTo(i + A.cx + A.x0, r + A.cy + A.y0), b < h && k === D ? t.arc(i + A.cx, r + A.cy, b,
						Vu(A.y0, A.x0), Vu(P.y0, P.x0), !o) : (0 < k && t.arc(i + A.cx, r + A.cy, k, Vu(A.y0, A
						.x0), Vu(A.y1, A.x1), !o), t.arc(i, r, L, Vu(A.cy + A.y1, A.cx + A.x1), Vu(P.cy + P
						.y1, P.cx + P.x1), !o), 0 < D && t.arc(i + P.cx, r + P.cy, D, Vu(P.y1, P.x1), Vu(P
						.y0, P.x0), !o))) : (t.moveTo(i + y, r + m), t.arc(i, r, L, R, n, !o)) : t.moveTo(i + y,
					r + m), Xu < O && x ? Xu < S ? (k = Uu(a, S), A = Yu(v, _, p, d, O, -(D = Uu(s, S)), o), P =
					Yu(y, m, f, g, O, -k, o), t.lineTo(i + A.cx + A.x0, r + A.cy + A.y0), S < c && k === D ? t
					.arc(i + A.cx, r + A.cy, S, Vu(A.y0, A.x0), Vu(P.y0, P.x0), !o) : (0 < D && t.arc(i + A.cx,
						r + A.cy, D, Vu(A.y0, A.x0), Vu(A.y1, A.x1), !o), t.arc(i, r, O, Vu(A.cy + A.y1, A
						.cx + A.x1), Vu(P.cy + P.y1, P.cx + P.x1), o), 0 < k && t.arc(i + P.cx, r + P.cy, k,
						Vu(P.y1, P.x1), Vu(P.y0, P.x0), !o))) : (t.lineTo(i + v, r + _), t.arc(i, r, O, n, R,
					o)) : t.lineTo(i + v, r + _)) : t.moveTo(i, r), t.closePath()))
	}

	function ju() {
		this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = 2 * Math.PI, this
			.clockwise = !0, this.cornerRadius = 0
	}
	u($u, Zu = Z), $u.prototype.getDefaultShape = function() {
		return new ju
	}, $u.prototype.buildPath = function(t, e) {
		qu(t, e)
	}, $u.prototype.isZeroArea = function() {
		return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0
	};
	var Zu, Ku = $u;

	function $u(t) {
		return Zu.call(this, t) || this
	}
	Ku.prototype.type = "sector";

	function Qu() {
		this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0
	}
	u(eh, Ju = Z), eh.prototype.getDefaultShape = function() {
		return new Qu
	}, eh.prototype.buildPath = function(t, e) {
		var n = e.cx,
			i = e.cy,
			r = 2 * Math.PI;
		t.moveTo(n + e.r, i), t.arc(n, i, e.r, 0, r, !1), t.moveTo(n + e.r0, i), t.arc(n, i, e.r0, 0, r, !0)
	};
	var Ju, th = eh;

	function eh(t) {
		return Ju.call(this, t) || this
	}

	function nh(t, e, n) {
		var i = e.smooth,
			r = e.points;
		if (r && 2 <= r.length) {
			if (i) {
				var o = function(t, e, n, i) {
					var r, o, a = [],
						s = [],
						l = [],
						u = [];
					if (i) {
						for (var h = [1 / 0, 1 / 0], c = [-1 / 0, -1 / 0], p = 0, d = t.length; p < d; p++) ie(
							h, h, t[p]), re(c, c, t[p]);
						ie(h, h, i[0]), re(c, c, i[1])
					}
					for (p = 0, d = t.length; p < d; p++) {
						var f = t[p];
						if (n) r = t[p ? p - 1 : d - 1], o = t[(p + 1) % d];
						else {
							if (0 === p || p === d - 1) {
								a.push(Ut(t[p]));
								continue
							}
							r = t[p - 1], o = t[p + 1]
						}
						Yt(s, o, r), Zt(s, s, e);
						var g = $t(f, r),
							y = $t(f, o),
							m = g + y,
							m = (0 !== m && (g /= m, y /= m), Zt(l, s, -g), Zt(u, s, y), Xt([], f, l)),
							g = Xt([], f, u);
						i && (re(m, m, h), ie(m, m, c), re(g, g, h), ie(g, g, c)), a.push(m), a.push(g)
					}
					return n && a.push(a.shift()), a
				}(r, i, n, e.smoothConstraint);
				t.moveTo(r[0][0], r[0][1]);
				for (var a = r.length, s = 0; s < (n ? a : a - 1); s++) {
					var l = o[2 * s],
						u = o[2 * s + 1],
						h = r[(s + 1) % a];
					t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1])
				}
			} else {
				t.moveTo(r[0][0], r[0][1]);
				for (var s = 1, c = r.length; s < c; s++) t.lineTo(r[s][0], r[s][1])
			}
			n && t.closePath()
		}
	}
	th.prototype.type = "ring";

	function ih() {
		this.points = null, this.smooth = 0, this.smoothConstraint = null
	}
	u(ah, rh = Z), ah.prototype.getDefaultShape = function() {
		return new ih
	}, ah.prototype.buildPath = function(t, e) {
		nh(t, e, !0)
	};
	var rh, oh = ah;

	function ah(t) {
		return rh.call(this, t) || this
	}
	oh.prototype.type = "polygon";

	function sh() {
		this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null
	}
	u(hh, lh = Z), hh.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		}
	}, hh.prototype.getDefaultShape = function() {
		return new sh
	}, hh.prototype.buildPath = function(t, e) {
		nh(t, e, !1)
	};
	var lh, uh = hh;

	function hh(t) {
		return lh.call(this, t) || this
	}
	uh.prototype.type = "polyline";

	function ch() {
		this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1
	}
	var ph, dh = {},
		fh = (u(gh, ph = Z), gh.prototype.getDefaultStyle = function() {
			return {
				stroke: "#000",
				fill: null
			}
		}, gh.prototype.getDefaultShape = function() {
			return new ch
		}, gh.prototype.buildPath = function(t, e) {
			o = (this.subPixelOptimize ? (n = (o = Fs(dh, e, this.style)).x1, i = o.y1, r = o.x2, o) : (n = e
				.x1, i = e.y1, r = e.x2, e)).y2;
			var n, i, r, o, e = e.percent;
			0 !== e && (t.moveTo(n, i), e < 1 && (r = n * (1 - e) + r * e, o = i * (1 - e) + o * e), t.lineTo(r,
				o))
		}, gh.prototype.pointAt = function(t) {
			var e = this.shape;
			return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
		}, gh);

	function gh(t) {
		return ph.call(this, t) || this
	}
	fh.prototype.type = "line";

	function yh() {
		this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1
	}
	var mh = [];

	function vh(t, e, n) {
		var i = t.cpx2,
			r = t.cpy2;
		return null != i || null != r ? [(n ? Bn : zn)(t.x1, t.cpx1, t.cpx2, t.x2, e), (n ? Bn : zn)(t.y1, t.cpy1, t
			.cpy2, t.y2, e)] : [(n ? Un : Wn)(t.x1, t.cpx1, t.x2, e), (n ? Un : Wn)(t.y1, t.cpy1, t.y2, e)]
	}
	u(wh, _h = Z), wh.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		}
	}, wh.prototype.getDefaultShape = function() {
		return new yh
	}, wh.prototype.buildPath = function(t, e) {
		var n = e.x1,
			i = e.y1,
			r = e.x2,
			o = e.y2,
			a = e.cpx1,
			s = e.cpy1,
			l = e.cpx2,
			u = e.cpy2,
			e = e.percent;
		0 !== e && (t.moveTo(n, i), null == l || null == u ? (e < 1 && (Yn(n, a, r, e, mh), a = mh[1], r = mh[
			2], Yn(i, s, o, e, mh), s = mh[1], o = mh[2]), t.quadraticCurveTo(a, s, r, o)) : (e < 1 && (
			Hn(n, a, l, r, e, mh), a = mh[1], l = mh[2], r = mh[3], Hn(i, s, u, o, e, mh), s = mh[
				1], u = mh[2], o = mh[3]), t.bezierCurveTo(a, s, l, u, r, o)))
	}, wh.prototype.pointAt = function(t) {
		return vh(this.shape, t, !1)
	}, wh.prototype.tangentAt = function(t) {
		t = vh(this.shape, t, !0);
		return Kt(t, t)
	};
	var _h, xh = wh;

	function wh(t) {
		return _h.call(this, t) || this
	}
	xh.prototype.type = "bezier-curve";

	function bh() {
		this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = 2 * Math.PI, this.clockwise = !0
	}
	u(Th, Sh = Z), Th.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		}
	}, Th.prototype.getDefaultShape = function() {
		return new bh
	}, Th.prototype.buildPath = function(t, e) {
		var n = e.cx,
			i = e.cy,
			r = Math.max(e.r, 0),
			o = e.startAngle,
			a = e.endAngle,
			e = e.clockwise,
			s = Math.cos(o),
			l = Math.sin(o);
		t.moveTo(s * r + n, l * r + i), t.arc(n, i, r, o, a, !e)
	};
	var Sh, Mh = Th;

	function Th(t) {
		return Sh.call(this, t) || this
	}
	Mh.prototype.type = "arc";
	u(kh, Ch = Z), kh.prototype._updatePathDirty = function() {
		for (var t = this.shape.paths, e = this.shapeChanged(), n = 0; n < t.length; n++) e = e || t[n]
			.shapeChanged();
		e && this.dirtyShape()
	}, kh.prototype.beforeBrush = function() {
		this._updatePathDirty();
		for (var t = this.shape.paths || [], e = this.getGlobalScale(), n = 0; n < t.length; n++) t[n].path ||
			t[n].createPathProxy(), t[n].path.setScale(e[0], e[1], t[n].segmentIgnoreThreshold)
	}, kh.prototype.buildPath = function(t, e) {
		for (var n = e.paths || [], i = 0; i < n.length; i++) n[i].buildPath(t, n[i].shape, !0)
	}, kh.prototype.afterBrush = function() {
		for (var t = this.shape.paths || [], e = 0; e < t.length; e++) t[e].pathUpdated()
	}, kh.prototype.getBoundingRect = function() {
		return this._updatePathDirty.call(this), Z.prototype.getBoundingRect.call(this)
	};
	var Ch, Ih = kh;

	function kh() {
		var t = null !== Ch && Ch.apply(this, arguments) || this;
		return t.type = "compound", t
	}
	Ah.prototype.addColorStop = function(t, e) {
		this.colorStops.push({
			offset: t,
			color: e
		})
	};
	var Dh = Ah;

	function Ah(t) {
		this.colorStops = t || []
	}
	u(Oh, Ph = Dh);
	var Ph, Lh = Oh;

	function Oh(t, e, n, i, r, o) {
		r = Ph.call(this, r) || this;
		return r.x = null == t ? 0 : t, r.y = null == e ? 0 : e, r.x2 = null == n ? 1 : n, r.y2 = null == i ? 0 : i,
			r.type = "linear", r.global = o || !1, r
	}
	u(Nh, Rh = Dh);
	var Rh, Dh = Nh;

	function Nh(t, e, n, i, r) {
		i = Rh.call(this, i) || this;
		return i.x = null == t ? .5 : t, i.y = null == e ? .5 : e, i.r = null == n ? .5 : n, i.type = "radial", i
			.global = r || !1, i
	}
	var Eh = [0, 0],
		zh = [0, 0],
		Bh = new W,
		Fh = new W,
		Vh = (Hh.prototype.fromBoundingRect = function(t, e) {
			var n = this._corners,
				i = this._axes,
				r = t.x,
				o = t.y,
				a = r + t.width,
				t = o + t.height;
			if (n[0].set(r, o), n[1].set(a, o), n[2].set(a, t), n[3].set(r, t), e)
				for (var s = 0; s < 4; s++) n[s].transform(e);
			for (W.sub(i[0], n[1], n[0]), W.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize(), s =
				0; s < 2; s++) this._origin[s] = i[s].dot(n[0])
		}, Hh.prototype.intersect = function(t, e) {
			var n = !0,
				i = !e;
			return Bh.set(1 / 0, 1 / 0), Fh.set(0, 0), !this._intersectCheckOneSide(this, t, Bh, Fh, i, 1) && (
					n = !1, i) || !this._intersectCheckOneSide(t, this, Bh, Fh, i, -1) && (n = !1, i) || i || W
				.copy(e, n ? Bh : Fh), n
		}, Hh.prototype._intersectCheckOneSide = function(t, e, n, i, r, o) {
			for (var a = !0, s = 0; s < 2; s++) {
				var l = this._axes[s];
				if (this._getProjMinMaxOnAxis(s, t._corners, Eh), this._getProjMinMaxOnAxis(s, e._corners, zh),
					Eh[1] < zh[0] || zh[1] < Eh[0]) {
					if (a = !1, r) return a;
					var u = Math.abs(zh[0] - Eh[1]),
						h = Math.abs(Eh[0] - zh[1]);
					Math.min(u, h) > i.len() && (u < h ? W.scale(i, l, -u * o) : W.scale(i, l, h * o))
				} else n && (u = Math.abs(zh[0] - Eh[1]), h = Math.abs(Eh[0] - zh[1]), Math.min(u, h) < n
					.len()) && (u < h ? W.scale(n, l, u * o) : W.scale(n, l, -h * o))
			}
			return a
		}, Hh.prototype._getProjMinMaxOnAxis = function(t, e, n) {
			for (var i = this._axes[t], r = this._origin, o = e[0].dot(i) + r[t], a = o, s = o, l = 1; l < e
				.length; l++) var u = e[l].dot(i) + r[t],
				a = Math.min(u, a),
				s = Math.max(u, s);
			n[0] = a, n[1] = s
		}, Hh);

	function Hh(t, e) {
		this._corners = [], this._axes = [], this._origin = [0, 0];
		for (var n = 0; n < 4; n++) this._corners[n] = new W;
		for (n = 0; n < 2; n++) this._axes[n] = new W;
		t && this.fromBoundingRect(t, e)
	}
	var Gh, Wh = [],
		n = (u(Uh, Gh = n), Uh.prototype.traverse = function(t, e) {
			t.call(e, this)
		}, Uh.prototype.useStyle = function() {
			this.style = {}
		}, Uh.prototype.getCursor = function() {
			return this._cursor
		}, Uh.prototype.innerAfterBrush = function() {
			this._cursor = this._displayables.length
		}, Uh.prototype.clearDisplaybles = function() {
			this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this
				.notClear = !1
		}, Uh.prototype.clearTemporalDisplayables = function() {
			this._temporaryDisplayables = []
		}, Uh.prototype.addDisplayable = function(t, e) {
			(e ? this._temporaryDisplayables : this._displayables).push(t), this.markRedraw()
		}, Uh.prototype.addDisplayables = function(t, e) {
			e = e || !1;
			for (var n = 0; n < t.length; n++) this.addDisplayable(t[n], e)
		}, Uh.prototype.getDisplayables = function() {
			return this._displayables
		}, Uh.prototype.getTemporalDisplayables = function() {
			return this._temporaryDisplayables
		}, Uh.prototype.eachPendingDisplayable = function(t) {
			for (var e = this._cursor; e < this._displayables.length; e++) t && t(this._displayables[e]);
			for (e = 0; e < this._temporaryDisplayables.length; e++) t && t(this._temporaryDisplayables[e])
		}, Uh.prototype.update = function() {
			this.updateTransform();
			for (var t, e = this._cursor; e < this._displayables.length; e++)(t = this._displayables[e])
				.parent = this, t.update(), t.parent = null;
			for (e = 0; e < this._temporaryDisplayables.length; e++)(t = this._temporaryDisplayables[e])
				.parent = this, t.update(), t.parent = null
		}, Uh.prototype.getBoundingRect = function() {
			if (!this._rect) {
				for (var t = new U(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) {
					var n = this._displayables[e],
						i = n.getBoundingRect().clone();
					n.needLocalTransform() && i.applyTransform(n.getLocalTransform(Wh)), t.union(i)
				}
				this._rect = t
			}
			return this._rect
		}, Uh.prototype.contain = function(t, e) {
			var n = this.transformCoordToLocal(t, e);
			if (this.getBoundingRect().contain(n[0], n[1]))
				for (var i = 0; i < this._displayables.length; i++)
					if (this._displayables[i].contain(t, e)) return !0;
			return !1
		}, Uh);

	function Uh() {
		var t = null !== Gh && Gh.apply(this, arguments) || this;
		return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor =
			0, t
	}
	var Xh = Yo();

	function Yh(t, e, n, i, r, o, a) {
		var s, l, u, h, c, p, d = !1,
			f = (S(r) ? (a = o, o = r, r = null) : L(r) && (o = r.cb, a = r.during, d = r.isFrom, l = r.removeOpt,
				r = r.dataIndex), "leave" === t),
			g = (f || e.stopAnimation("leave"), p = t, s = r, l = f ? l || {} : null, i = (g = i) && i
				.getAnimationDelayParams ? i.getAnimationDelayParams(e, r) : null, g && g.ecModel && (u = (u = g
					.ecModel.getUpdatePayload()) && u.animation), p = "update" === p, g && g.isAnimationEnabled() ?
				(c = h = r = void 0, c = l ? (r = N(l.duration, 200), h = N(l.easing, "cubicOut"), 0) : (r = g
					.getShallow(p ? "animationDurationUpdate" : "animationDuration"), h = g.getShallow(p ?
						"animationEasingUpdate" : "animationEasing"), g.getShallow(p ? "animationDelayUpdate" :
						"animationDelay")), S(c = u && (null != u.duration && (r = u.duration), null != u
					.easing && (h = u.easing), null != u.delay) ? u.delay : c) && (c = c(s, i)), {
					duration: (r = S(r) ? r(s) : r) || 0,
					delay: c,
					easing: h
				}) : null);
		g && 0 < g.duration ? (p = {
			duration: g.duration,
			delay: g.delay || 0,
			easing: g.easing,
			done: o,
			force: !!o || !!a,
			setToFinal: !f,
			scope: t,
			during: a
		}, d ? e.animateFrom(n, p) : e.animateTo(n, p)) : (e.stopAnimation(), d || e.attr(n), a && a(1), o &&
			o())
	}

	function qh(t, e, n, i, r, o) {
		Yh("update", t, e, n, i, r, o)
	}

	function jh(t, e, n, i, r, o) {
		Yh("enter", t, e, n, i, r, o)
	}

	function Zh(t) {
		if (!t.__zr) return !0;
		for (var e = 0; e < t.animators.length; e++)
			if ("leave" === t.animators[e].scope) return !0;
		return !1
	}

	function Kh(t, e, n, i, r, o) {
		Zh(t) || Yh("leave", t, e, n, i, r, o)
	}

	function $h(t, e, n, i) {
		t.removeTextContent(), t.removeTextGuideLine(), Kh(t, {
			style: {
				opacity: 0
			}
		}, e, n, i)
	}

	function Qh(t, e, n) {
		function i() {
			t.parent && t.parent.remove(t)
		}
		t.isGroup ? t.traverse(function(t) {
			t.isGroup || $h(t, e, n, i)
		}) : $h(t, e, n, i)
	}

	function Jh(t) {
		Xh(t).oldStyle = t.style
	}
	var tc = Math.max,
		ec = Math.min,
		nc = {};

	function ic(t) {
		return Z.extend(t)
	}
	var rc = function(t, e) {
		var n, i = Cu(t, e);
		return u(r, n = Su), r;

		function r(t) {
			t = n.call(this, t) || this;
			return t.applyTransform = i.applyTransform, t.buildPath = i.buildPath, t
		}
	};

	function oc(t, e) {
		return rc(t, e)
	}

	function ac(t, e) {
		nc[t] = e
	}

	function sc(t) {
		if (nc.hasOwnProperty(t)) return nc[t]
	}

	function lc(t, e, n, i) {
		t = new Su(Cu(t, e));
		return n && ("center" === i && (n = hc(n, t.getBoundingRect())), pc(t, n)), t
	}

	function uc(t, e, n) {
		var i = new Es({
			style: {
				image: t,
				x: e.x,
				y: e.y,
				width: e.width,
				height: e.height
			},
			onload: function(t) {
				"center" === n && (t = {
					width: t.width,
					height: t.height
				}, i.setStyle(hc(e, t)))
			}
		});
		return i
	}

	function hc(t, e) {
		var e = e.width / e.height,
			n = t.height * e,
			e = n <= t.width ? t.height : (n = t.width) / e;
		return {
			x: t.x + t.width / 2 - n / 2,
			y: t.y + t.height / 2 - e / 2,
			width: n,
			height: e
		}
	}

	function cc(t, e) {
		for (var n = [], i = t.length, r = 0; r < i; r++) {
			var o = t[r];
			n.push(o.getUpdatedPathProxy(!0))
		}
		return (e = new Z(e)).createPathProxy(), e.buildPath = function(t) {
			var e;
			Tu(t) && (t.appendPath(n), e = t.getContext()) && t.rebuildPath(e, 1)
		}, e
	}

	function pc(t, e) {
		t.applyTransform && (e = t.getBoundingRect().calculateTransform(e), t.applyTransform(e))
	}

	function dc(t, e) {
		return Fs(t, t, {
			lineWidth: e
		}), t
	}
	var fc = Hs;

	function gc(t, e) {
		for (var n = Re([]); t && t !== e;) Ee(n, t.getLocalTransform(), n), t = t.parent;
		return n
	}

	function yc(t, e, n) {
		return e && !ut(e) && (e = Pr.getLocalTransform(e)), ne([], t, e = n ? Ve([], e) : e)
	}

	function mc(t) {
		return !t.isGroup
	}

	function vc(t, e, i) {
		var n, r;

		function o(t) {
			var e = {
				x: t.x,
				y: t.y,
				rotation: t.rotation
			};
			return null != t.shape && (e.shape = O({}, t.shape)), e
		}
		t && e && (n = {}, t.traverse(function(t) {
			mc(t) && t.anid && (n[t.anid] = t)
		}), r = n, e.traverse(function(t) {
			var e, n;
			mc(t) && t.anid && (e = r[t.anid]) && (n = o(t), t.attr(o(e)), qh(t, n, i, k(t).dataIndex))
		}))
	}

	function _c(t, n) {
		return F(t, function(t) {
			var e = t[0],
				e = tc(e, n.x),
				t = (e = ec(e, n.x + n.width), t[1]),
				t = tc(t, n.y);
			return [e, ec(t, n.y + n.height)]
		})
	}

	function xc(t, e) {
		var n = tc(t.x, e.x),
			i = ec(t.x + t.width, e.x + e.width),
			r = tc(t.y, e.y),
			t = ec(t.y + t.height, e.y + e.height);
		if (n <= i && r <= t) return {
			x: n,
			y: r,
			width: i - n,
			height: t - r
		}
	}

	function wc(t, e, n) {
		var e = O({
				rectHover: !0
			}, e),
			i = e.style = {
				strokeNoScale: !0
			};
		if (n = n || {
				x: -1,
				y: -1,
				width: 2,
				height: 2
			}, t) return 0 === t.indexOf("image://") ? (i.image = t.slice(8), B(i, n), new Es(e)) : lc(t.replace(
			"path://", ""), e, n, "center")
	}

	function bc(t, e, n, i, r, o, a, s) {
		var l, n = n - t,
			i = i - e,
			a = a - r,
			s = s - o,
			u = a * i - n * s;
		return !((l = u) <= 1e-6 && -1e-6 <= l || (r = ((l = t - r) * i - n * (t = e - o)) / u) < 0 || 1 < r || (i =
			(l * s - a * t) / u) < 0 || 1 < i)
	}

	function Sc(t) {
		var e = t.itemTooltipOption,
			n = t.componentModel,
			i = t.itemName,
			e = H(e) ? {
				formatter: e
			} : e,
			r = n.mainType,
			n = n.componentIndex,
			o = {
				componentType: r,
				name: i,
				$vars: ["name"]
			},
			a = (o[r + "Index"] = n, t.formatterParamsExtra),
			t = (a && E(R(a), function(t) {
				Ft(o, t) || (o[t] = a[t], o.$vars.push(t))
			}), k(t.el));
		t.componentMainType = r, t.componentIndex = n, t.tooltipConfig = {
			name: i,
			option: B({
				content: i,
				formatterParams: o
			}, e)
		}
	}

	function Mc(t, e) {
		var n;
		(n = t.isGroup ? e(t) : n) || t.traverse(e)
	}

	function Tc(t, e) {
		if (t)
			if (V(t))
				for (var n = 0; n < t.length; n++) Mc(t[n], e);
			else Mc(t, e)
	}
	ac("circle", Du), ac("ellipse", Ou), ac("sector", Ku), ac("ring", th), ac("polygon", oh), ac("polyline", uh),
		ac("rect", Xs), ac("line", fh), ac("bezierCurve", xh), ac("arc", Mh);
	var Cc = Object.freeze({
			__proto__: null,
			Arc: Mh,
			BezierCurve: xh,
			BoundingRect: U,
			Circle: Du,
			CompoundPath: Ih,
			Ellipse: Ou,
			Group: no,
			Image: Es,
			IncrementalDisplayable: n,
			Line: fh,
			LinearGradient: Lh,
			OrientedBoundingRect: Vh,
			Path: Z,
			Point: W,
			Polygon: oh,
			Polyline: uh,
			RadialGradient: Dh,
			Rect: Xs,
			Ring: th,
			Sector: Ku,
			Text: Ks,
			applyTransform: yc,
			clipPointsByRect: _c,
			clipRectByRect: xc,
			createIcon: wc,
			extendPath: oc,
			extendShape: ic,
			getShapeClass: sc,
			getTransform: gc,
			groupTransition: vc,
			initProps: jh,
			isElementRemoved: Zh,
			lineLineIntersect: bc,
			linePolygonIntersect: function(t, e, n, i, r) {
				for (var o = 0, a = r[r.length - 1]; o < r.length; o++) {
					var s = r[o];
					if (bc(t, e, n, i, s[0], s[1], a[0], a[1])) return !0;
					a = s
				}
			},
			makeImage: uc,
			makePath: lc,
			mergePath: cc,
			registerShape: ac,
			removeElement: Kh,
			removeElementWithFadeOut: Qh,
			resizePath: pc,
			setTooltipConfig: Sc,
			subPixelOptimize: fc,
			subPixelOptimizeLine: dc,
			subPixelOptimizeRect: function(t) {
				return Vs(t.shape, t.shape, t.style), t
			},
			transformDirection: function(t, e, n) {
				var i = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
					r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
					i = yc(["left" === t ? -i : "right" === t ? i : 0, "top" === t ? -r : "bottom" === t ?
						r : 0
					], e, n);
				return Math.abs(i[0]) > Math.abs(i[1]) ? 0 < i[0] ? "right" : "left" : 0 < i[1] ? "bottom" :
					"top"
			},
			traverseElements: Tc,
			updateProps: qh
		}),
		Ic = {};

	function kc(t, e) {
		for (var n = 0; n < ml.length; n++) {
			var i = ml[n],
				r = e[i],
				i = t.ensureState(i);
			i.style = i.style || {}, i.style.text = r
		}
		var o = t.currentStates.slice();
		t.clearStates(!0), t.setStyle({
			text: e.normal
		}), t.useStates(o, !0)
	}

	function Dc(t, e, n) {
		for (var i, r = t.labelFetcher, o = t.labelDataIndex, a = t.labelDimIndex, s = e.normal, l = {
				normal: i = null == (i = r ? r.getFormattedLabel(o, "normal", null, a, s && s.get("formatter"),
					null != n ? {
						interpolatedValue: n
					} : null) : i) ? S(t.defaultText) ? t.defaultText(o, t, n) : t.defaultText : i
			}, u = 0; u < ml.length; u++) {
			var h = ml[u],
				c = e[h];
			l[h] = N(r ? r.getFormattedLabel(o, h, null, a, c && c.get("formatter")) : null, i)
		}
		return l
	}

	function Ac(t, e, n, i) {
		n = n || Ic;
		for (var r = t instanceof Ks, o = !1, a = 0; a < vl.length; a++)
			if ((p = e[vl[a]]) && p.getShallow("show")) {
				o = !0;
				break
			} var s = r ? t : t.getTextContent();
		if (o) {
			r || (s || (s = new Ks, t.setTextContent(s)), t.stateProxy && (s.stateProxy = t.stateProxy));
			var l = Dc(n, e),
				u = e.normal,
				h = !!u.getShallow("show"),
				c = Lc(u, i && i.normal, n, !1, !r);
			for (c.text = l.normal, r || t.setTextConfig(Oc(u, n, !1)), a = 0; a < ml.length; a++) {
				var p, d, f, g = ml[a];
				(p = e[g]) && (d = s.ensureState(g), (f = !!N(p.getShallow("show"), h)) != h && (d.ignore = !f), d
					.style = Lc(p, i && i[g], n, !0, !r), d.style.text = l[g], r || (t.ensureState(g).textConfig =
						Oc(p, n, !0)))
			}
			s.silent = !!u.getShallow("silent"), null != s.style.x && (c.x = s.style.x), null != s.style.y && (c.y =
				s.style.y), s.ignore = !h, s.useStyle(c), s.dirty(), n.enableTextSetter && (Bc(s).setLabelText =
				function(t) {
					t = Dc(n, e, t);
					kc(s, t)
				})
		} else s && (s.ignore = !0);
		t.dirty()
	}

	function Pc(t, e) {
		for (var n = {
				normal: t.getModel(e = e || "label")
			}, i = 0; i < ml.length; i++) {
			var r = ml[i];
			n[r] = t.getModel([r, e])
		}
		return n
	}

	function Lc(t, e, n, i, r) {
		var o, a = {},
			s = a,
			l = t,
			u = n,
			h = i,
			c = r;
		u = u || Ic;
		var p, t = l.ecModel,
			d = t && t.option.textStyle,
			f = function(t) {
				for (var e; t && t !== t.ecModel;) {
					var n = (t.option || Ic).rich;
					if (n) {
						e = e || {};
						for (var i = R(n), r = 0; r < i.length; r++) e[i[r]] = 1
					}
					t = t.parentModel
				}
				return e
			}(l);
		if (f)
			for (var g in p = {}, f) f.hasOwnProperty(g) && (o = l.getModel(["rich", g]), zc(p[g] = {}, o, d, u, h,
				c, !1, !0));
		return p && (s.rich = p), (t = l.get("overflow")) && (s.overflow = t), null != (t = l.get("minMargin")) && (
			s.margin = t), zc(s, l, d, u, h, c, !0, !1), e && O(a, e), a
	}

	function Oc(t, e, n) {
		e = e || {};
		var i = {},
			r = t.getShallow("rotate"),
			o = N(t.getShallow("distance"), n ? null : 5),
			a = t.getShallow("offset");
		return null != (n = "outside" === (n = t.getShallow("position") || (n ? null : "inside")) ? e
				.defaultOutsidePosition || "top" : n) && (i.position = n), null != a && (i.offset = a), null != r &&
			(r *= Math.PI / 180, i.rotation = r), null != o && (i.distance = o), i.outsideFill = "inherit" === t
			.get("color") ? e.inheritColor || null : "auto", i
	}
	var Rc = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur",
			"textShadowOffsetX", "textShadowOffsetY"
		],
		Nc = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"],
		Ec = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor",
			"shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"
		];

	function zc(t, e, n, i, r, o, a, s) {
		n = !r && n || Ic;
		var l = i && i.inheritColor,
			u = e.getShallow("color"),
			h = e.getShallow("textBorderColor"),
			c = N(e.getShallow("opacity"), n.opacity),
			u = ("inherit" !== u && "auto" !== u || (u = l || null), "inherit" !== h && "auto" !== h || (h = l ||
					null), o || (u = u || n.color, h = h || n.textBorderColor), null != u && (t.fill = u), null !=
				h && (t.stroke = h), N(e.getShallow("textBorderWidth"), n.textBorderWidth)),
			h = (null != u && (t.lineWidth = u), N(e.getShallow("textBorderType"), n.textBorderType)),
			u = (null != h && (t.lineDash = h), N(e.getShallow("textBorderDashOffset"), n.textBorderDashOffset));
		null != u && (t.lineDashOffset = u), null != (c = r || null != c || s ? c : i && i.defaultOpacity) && (t
			.opacity = c), r || o || null == t.fill && i.inheritColor && (t.fill = i.inheritColor);
		for (var p = 0; p < Rc.length; p++) {
			var d = Rc[p];
			null != (f = N(e.getShallow(d), n[d])) && (t[d] = f)
		}
		for (p = 0; p < Nc.length; p++) d = Nc[p], null != (f = e.getShallow(d)) && (t[d] = f);
		if (null == t.verticalAlign && null != (h = e.getShallow("baseline")) && (t.verticalAlign = h), !a || !i
			.disableBox) {
			for (p = 0; p < Ec.length; p++) {
				var f, d = Ec[p];
				null != (f = e.getShallow(d)) && (t[d] = f)
			}
			u = e.getShallow("borderType");
			null != u && (t.borderDash = u), "auto" !== t.backgroundColor && "inherit" !== t.backgroundColor || !
				l || (t.backgroundColor = l), "auto" !== t.borderColor && "inherit" !== t.borderColor || !l || (t
					.borderColor = l)
		}
	}
	var Bc = Yo();
	var Fc = ["textStyle", "color"],
		Vc = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width",
			"height", "overflow"
		],
		Hc = new Ks,
		fc = (Gc.prototype.getTextColor = function(t) {
			var e = this.ecModel;
			return this.getShallow("color") || (!t && e ? e.get(Fc) : null)
		}, Gc.prototype.getFont = function() {
			return t = {
				fontStyle: this.getShallow("fontStyle"),
				fontWeight: this.getShallow("fontWeight"),
				fontSize: this.getShallow("fontSize"),
				fontFamily: this.getShallow("fontFamily")
			}, e = (e = this.ecModel) && e.getModel("textStyle"), It([t.fontStyle || e && e.getShallow(
					"fontStyle") || "", t.fontWeight || e && e.getShallow("fontWeight") || "", (t
					.fontSize || e && e.getShallow("fontSize") || 12) + "px", t.fontFamily || e && e
				.getShallow("fontFamily") || "sans-serif"
			].join(" "));
			var t, e
		}, Gc.prototype.getTextRect = function(t) {
			for (var e = {
					text: t,
					verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
				}, n = 0; n < Vc.length; n++) e[Vc[n]] = this.getShallow(Vc[n]);
			return Hc.useStyle(e), Hc.update(), Hc.getBoundingRect()
		}, Gc);

	function Gc() {}
	var Wc = [
			["lineWidth", "width"],
			["stroke", "color"],
			["opacity"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["shadowColor"],
			["lineDash", "type"],
			["lineDashOffset", "dashOffset"],
			["lineCap", "cap"],
			["lineJoin", "join"],
			["miterLimit"]
		],
		Uc = ha(Wc),
		Xc = (Yc.prototype.getLineStyle = function(t) {
			return Uc(this, t)
		}, Yc);

	function Yc() {}
	var qc = [
			["fill", "color"],
			["stroke", "borderColor"],
			["lineWidth", "borderWidth"],
			["opacity"],
			["shadowBlur"],
			["shadowOffsetX"],
			["shadowOffsetY"],
			["shadowColor"],
			["lineDash", "borderType"],
			["lineDashOffset", "borderDashOffset"],
			["lineCap", "borderCap"],
			["lineJoin", "borderJoin"],
			["miterLimit", "borderMiterLimit"]
		],
		jc = ha(qc),
		Zc = (Kc.prototype.getItemStyle = function(t, e) {
			return jc(this, t, e)
		}, Kc);

	function Kc() {}
	Jc.prototype.init = function(t, e, n) {
		for (var i = 3; i < arguments.length; i++) i - 3, 0
	}, Jc.prototype.mergeOption = function(t, e) {
		d(this.option, t, !0)
	}, Jc.prototype.get = function(t, e) {
		return null == t ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel)
	}, Jc.prototype.getShallow = function(t, e) {
		var n = this.option,
			n = null == n ? n : n[t];
		return null != n || e || (e = this.parentModel) && (n = e.getShallow(t)), n
	}, Jc.prototype.getModel = function(t, e) {
		var n = null != t,
			t = n ? this.parsePath(t) : null;
		return new Jc(n ? this._doGet(t) : this.option, e = e || this.parentModel && this.parentModel.getModel(
			this.resolveParentPath(t)), this.ecModel)
	}, Jc.prototype.isEmpty = function() {
		return null == this.option
	}, Jc.prototype.restoreData = function() {}, Jc.prototype.clone = function() {
		return new this.constructor(_(this.option))
	}, Jc.prototype.parsePath = function(t) {
		return "string" == typeof t ? t.split(".") : t
	}, Jc.prototype.resolveParentPath = function(t) {
		return t
	}, Jc.prototype.isAnimationEnabled = function() {
		if (!b.node && this.option) return null != this.option.animation ? !!this.option.animation : this
			.parentModel ? this.parentModel.isAnimationEnabled() : void 0
	}, Jc.prototype._doGet = function(t, e) {
		var n = this.option;
		if (t) {
			for (var i = 0; i < t.length && (!t[i] || null != (n = n && "object" == typeof n ? n[t[i]] :
					null)); i++);
			null == n && e && (n = e._doGet(this.resolveParentPath(t), e.parentModel))
		}
		return n
	};
	var $c, Qc = Jc;

	function Jc(t, e, n) {
		this.parentModel = e, this.ecModel = n, this.option = t
	}
	ra(Qc), gp = Qc, $c = ["__\0is_clz", aa++].join("_"), gp.prototype[$c] = !0, gp.isInstance = function(t) {
		return !(!t || !t[$c])
	}, lt(Qc, Xc), lt(Qc, Zc), lt(Qc, pa), lt(Qc, fc);
	var tp = Math.round(10 * Math.random());

	function ep(t) {
		return [t || "", tp++].join("_")
	}

	function np(t, e) {
		return d(d({}, t, !0), e, !0)
	}
	var ip = "ZH",
		rp = "EN",
		op = rp,
		ap = {},
		sp = {},
		lp = b.domSupported && -1 < (document.documentElement.lang || navigator.language || navigator
			.browserLanguage).toUpperCase().indexOf(ip) ? ip : op;

	function up(t, e) {
		t = t.toUpperCase(), sp[t] = new Qc(e), ap[t] = e
	}
	up(rp, {
		time: {
			month: ["January", "February", "March", "April", "May", "June", "July", "August", "September",
				"October", "November", "December"
			],
			monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
			dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
		},
		legend: {
			selector: {
				all: "All",
				inverse: "Inv"
			}
		},
		toolbox: {
			brush: {
				title: {
					rect: "Box Select",
					polygon: "Lasso Select",
					lineX: "Horizontally Select",
					lineY: "Vertically Select",
					keep: "Keep Selections",
					clear: "Clear Selections"
				}
			},
			dataView: {
				title: "Data View",
				lang: ["Data View", "Close", "Refresh"]
			},
			dataZoom: {
				title: {
					zoom: "Zoom",
					back: "Zoom Reset"
				}
			},
			magicType: {
				title: {
					line: "Switch to Line Chart",
					bar: "Switch to Bar Chart",
					stack: "Stack",
					tiled: "Tile"
				}
			},
			restore: {
				title: "Restore"
			},
			saveAsImage: {
				title: "Save as Image",
				lang: ["Right Click to Save Image"]
			}
		},
		series: {
			typeNames: {
				pie: "Pie chart",
				bar: "Bar chart",
				line: "Line chart",
				scatter: "Scatter plot",
				effectScatter: "Ripple scatter plot",
				radar: "Radar chart",
				tree: "Tree",
				treemap: "Treemap",
				boxplot: "Boxplot",
				candlestick: "Candlestick",
				k: "K line chart",
				heatmap: "Heat map",
				map: "Map",
				parallel: "Parallel coordinate map",
				lines: "Line graph",
				graph: "Relationship graph",
				sankey: "Sankey diagram",
				funnel: "Funnel chart",
				gauge: "Gauge",
				pictorialBar: "Pictorial bar",
				themeRiver: "Theme River Map",
				sunburst: "Sunburst"
			}
		},
		aria: {
			general: {
				withTitle: 'This is a chart about "{title}"',
				withoutTitle: "This is a chart"
			},
			series: {
				single: {
					prefix: "",
					withName: " with type {seriesType} named {seriesName}.",
					withoutName: " with type {seriesType}."
				},
				multiple: {
					prefix: ". It consists of {seriesCount} series count.",
					withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
					withoutName: " The {seriesId} series is a {seriesType}.",
					separator: {
						middle: "",
						end: ""
					}
				}
			},
			data: {
				allData: "The data is as follows: ",
				partialData: "The first {displayCnt} items are: ",
				withName: "the data for {name} is {value}",
				withoutName: "{value}",
				separator: {
					middle: ", ",
					end: ". "
				}
			}
		}
	}), up(ip, {
		time: {
			month: ["", "", "", "", "", "", "", "", "", "", "", ""],
			monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
			dayOfWeek: ["", "", "", "", "", "", ""],
			dayOfWeekAbbr: ["", "", "", "", "", "", ""]
		},
		legend: {
			selector: {
				all: "",
				inverse: ""
			}
		},
		toolbox: {
			brush: {
				title: {
					rect: "",
					polygon: "",
					lineX: "",
					lineY: "",
					keep: "",
					clear: ""
				}
			},
			dataView: {
				title: "",
				lang: ["", "", ""]
			},
			dataZoom: {
				title: {
					zoom: "",
					back: ""
				}
			},
			magicType: {
				title: {
					line: "",
					bar: "",
					stack: "",
					tiled: ""
				}
			},
			restore: {
				title: ""
			},
			saveAsImage: {
				title: "",
				lang: [""]
			}
		},
		series: {
			typeNames: {
				pie: "",
				bar: "",
				line: "",
				scatter: "",
				effectScatter: "",
				radar: "",
				tree: "",
				treemap: "",
				boxplot: "",
				candlestick: "K",
				k: "K",
				heatmap: "",
				map: "",
				parallel: "",
				lines: "",
				graph: "",
				sankey: "",
				funnel: "",
				gauge: "",
				pictorialBar: "",
				themeRiver: "",
				sunburst: ""
			}
		},
		aria: {
			general: {
				withTitle: "{title}",
				withoutTitle: ""
			},
			series: {
				single: {
					prefix: "",
					withName: "{seriesType}{seriesName}",
					withoutName: "{seriesType}"
				},
				multiple: {
					prefix: "{seriesCount}",
					withName: "{seriesId}{seriesName}{seriesType}",
					withoutName: "{seriesId}{seriesType}",
					separator: {
						middle: "",
						end: ""
					}
				}
			},
			data: {
				allData: "",
				partialData: "{displayCnt}",
				withName: "{name}{value}",
				withoutName: "{value}",
				separator: {
					middle: "",
					end: ""
				}
			}
		}
	});
	var hp = 1e3,
		cp = 60 * hp,
		pp = 60 * cp,
		dp = 24 * pp,
		aa = 365 * dp,
		fp = {
			year: "{yyyy}",
			month: "{MMM}",
			day: "{d}",
			hour: "{HH}:{mm}",
			minute: "{HH}:{mm}",
			second: "{HH}:{mm}:{ss}",
			millisecond: "{HH}:{mm}:{ss} {SSS}",
			none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
		},
		gp = "{yyyy}-{MM}-{dd}",
		yp = {
			year: "{yyyy}",
			month: "{yyyy}-{MM}",
			day: gp,
			hour: gp + " " + fp.hour,
			minute: gp + " " + fp.minute,
			second: gp + " " + fp.second,
			millisecond: fp.none
		},
		mp = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
		vp = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day",
			"hour", "minute", "second", "millisecond"
		];

	function _p(t, e) {
		return "0000".substr(0, e - (t += "").length) + t
	}

	function xp(t) {
		switch (t) {
			case "half-year":
			case "quarter":
				return "month";
			case "week":
			case "half-week":
				return "day";
			case "half-day":
			case "quarter-day":
				return "hour";
			default:
				return t
		}
	}

	function wp(t, e, n, i) {
		var t = So(t),
			r = t[Mp(n)](),
			o = t[Tp(n)]() + 1,
			a = Math.floor((o - 1) / 3) + 1,
			s = t[Cp(n)](),
			l = t["get" + (n ? "UTC" : "") + "Day"](),
			u = t[Ip(n)](),
			h = (u - 1) % 12 + 1,
			c = t[kp(n)](),
			p = t[Dp(n)](),
			t = t[Ap(n)](),
			n = (i instanceof Qc ? i : sp[i || lp] || sp[op]).getModel("time"),
			i = n.get("month"),
			d = n.get("monthAbbr"),
			f = n.get("dayOfWeek"),
			n = n.get("dayOfWeekAbbr");
		return (e || "").replace(/{yyyy}/g, r + "").replace(/{yy}/g, _p(r % 100 + "", 2)).replace(/{Q}/g, a + "")
			.replace(/{MMMM}/g, i[o - 1]).replace(/{MMM}/g, d[o - 1]).replace(/{MM}/g, _p(o, 2)).replace(/{M}/g, o +
				"").replace(/{dd}/g, _p(s, 2)).replace(/{d}/g, s + "").replace(/{eeee}/g, f[l]).replace(/{ee}/g, n[
				l]).replace(/{e}/g, l + "").replace(/{HH}/g, _p(u, 2)).replace(/{H}/g, u + "").replace(/{hh}/g, _p(
				h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, _p(c, 2)).replace(/{m}/g, c + "").replace(
				/{ss}/g, _p(p, 2)).replace(/{s}/g, p + "").replace(/{SSS}/g, _p(t, 3)).replace(/{S}/g, t + "")
	}

	function bp(t, e) {
		var t = So(t),
			n = t[Tp(e)]() + 1,
			i = t[Cp(e)](),
			r = t[Ip(e)](),
			o = t[kp(e)](),
			a = t[Dp(e)](),
			t = 0 === t[Ap(e)](),
			e = t && 0 === a,
			a = e && 0 === o,
			o = a && 0 === r,
			r = o && 1 === i;
		return r && 1 === n ? "year" : r ? "month" : o ? "day" : a ? "hour" : e ? "minute" : t ? "second" :
			"millisecond"
	}

	function Sp(t, e, n) {
		var i = G(t) ? So(t) : t;
		switch (e = e || bp(t, n)) {
			case "year":
				return i[Mp(n)]();
			case "half-year":
				return 6 <= i[Tp(n)]() ? 1 : 0;
			case "quarter":
				return Math.floor((i[Tp(n)]() + 1) / 4);
			case "month":
				return i[Tp(n)]();
			case "day":
				return i[Cp(n)]();
			case "half-day":
				return i[Ip(n)]() / 24;
			case "hour":
				return i[Ip(n)]();
			case "minute":
				return i[kp(n)]();
			case "second":
				return i[Dp(n)]();
			case "millisecond":
				return i[Ap(n)]()
		}
	}

	function Mp(t) {
		return t ? "getUTCFullYear" : "getFullYear"
	}

	function Tp(t) {
		return t ? "getUTCMonth" : "getMonth"
	}

	function Cp(t) {
		return t ? "getUTCDate" : "getDate"
	}

	function Ip(t) {
		return t ? "getUTCHours" : "getHours"
	}

	function kp(t) {
		return t ? "getUTCMinutes" : "getMinutes"
	}

	function Dp(t) {
		return t ? "getUTCSeconds" : "getSeconds"
	}

	function Ap(t) {
		return t ? "getUTCMilliseconds" : "getMilliseconds"
	}

	function Pp(t) {
		return t ? "setUTCMonth" : "setMonth"
	}

	function Lp(t) {
		return t ? "setUTCDate" : "setDate"
	}

	function Op(t) {
		return t ? "setUTCHours" : "setHours"
	}

	function Rp(t) {
		return t ? "setUTCMinutes" : "setMinutes"
	}

	function Np(t) {
		return t ? "setUTCSeconds" : "setSeconds"
	}

	function Ep(t) {
		return t ? "setUTCMilliseconds" : "setMilliseconds"
	}

	function zp(t) {
		var e;
		return ko(t) ? (e = (t + "").split("."))[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (1 < e
			.length ? "." + e[1] : "") : H(t) ? t : "-"
	}

	function Bp(t, e) {
		return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, e) {
			return e.toUpperCase()
		}), t = e ? t && t.charAt(0).toUpperCase() + t.slice(1) : t
	}
	var Fp = Tt;

	function Vp(t, e, n) {
		function i(t) {
			return t && It(t) ? t : "-"
		}

		function r(t) {
			return null != t && !isNaN(t) && isFinite(t)
		}
		var o = "time" === e,
			a = t instanceof Date;
		if (o || a) {
			var o = o ? So(t) : t;
			if (!isNaN(+o)) return wp(o, "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}", n);
			if (a) return "-"
		}
		return "ordinal" === e ? ft(t) ? i(t) : G(t) && r(t) ? t + "" : "-" : r(o = Io(t)) ? zp(o) : ft(t) ? i(t) :
			"boolean" == typeof t ? t + "" : "-"
	}

	function Hp(t, e) {
		return "{" + t + (null == e ? "" : e) + "}"
	}
	var Gp = ["a", "b", "c", "d", "e", "f", "g"];

	function Wp(t, e, n) {
		var i = (e = V(e) ? e : [e]).length;
		if (!i) return "";
		for (var r = e[0].$vars || [], o = 0; o < r.length; o++) {
			var a = Gp[o];
			t = t.replace(Hp(a), Hp(a, 0))
		}
		for (var s = 0; s < i; s++)
			for (var l = 0; l < r.length; l++) {
				var u = e[s][r[l]];
				t = t.replace(Hp(Gp[l], s), n ? xe(u) : u)
			}
		return t
	}

	function Up(t, e) {
		var t = H(t) ? {
				color: t,
				extraCssText: e
			} : t || {},
			n = t.color,
			i = t.type,
			r = (e = t.extraCssText, t.renderMode || "html");
		return n ? "html" === r ? "subItem" === i ?
			'<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' +
			xe(n) + ";" + (e || "") + '"></span>' :
			'<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' +
			xe(n) + ";" + (e || "") + '"></span>' : {
				renderMode: r,
				content: "{" + (t.markerId || "markerX") + "|}  ",
				style: "subItem" === i ? {
					width: 4,
					height: 4,
					borderRadius: 2,
					backgroundColor: n
				} : {
					width: 10,
					height: 10,
					borderRadius: 5,
					backgroundColor: n
				}
			} : ""
	}

	function Xp(t, e) {
		return e = e || "transparent", H(t) ? t : L(t) && t.colorStops && (t.colorStops[0] || {}).color || e
	}

	function Yp(t, e) {
		var n;
		"_blank" === e || "blank" === e ? ((n = window.open()).opener = null, n.location.href = t) : window.open(t,
			e)
	}
	var qp = E,
		jp = ["left", "right", "top", "bottom", "width", "height"],
		Zp = [
			["width", "left", "right"],
			["height", "top", "bottom"]
		];

	function Kp(a, s, l, u, h) {
		var c = 0,
			p = 0,
			d = (null == u && (u = 1 / 0), null == h && (h = 1 / 0), 0);
		s.eachChild(function(t, e) {
			var n, i, r, o = t.getBoundingRect(),
				e = s.childAt(e + 1),
				e = e && e.getBoundingRect();
			d = "horizontal" === a ? (r = o.width + (e ? -e.x + o.x : 0), (n = c + r) > u || t.newline ? (
				c = 0, n = r, p += d + l, o.height) : Math.max(d, o.height)) : (r = o.height + (e ? -e
					.y + o.y : 0), (i = p + r) > h || t.newline ? (c += d + l, p = 0, i = r, o.width) :
				Math.max(d, o.width)), t.newline || (t.x = c, t.y = p, t.markRedraw(), "horizontal" ===
				a ? c = n + l : p = i + l)
		})
	}
	var $p = Kp;

	function Qp(t, e, n) {
		n = Fp(n || 0);
		var i = e.width,
			r = e.height,
			o = fo(t.left, i),
			a = fo(t.top, r),
			e = fo(t.right, i),
			s = fo(t.bottom, r),
			l = fo(t.width, i),
			u = fo(t.height, r),
			h = n[2] + n[0],
			c = n[1] + n[3],
			p = t.aspect;
		switch (isNaN(l) && (l = i - e - c - o), isNaN(u) && (u = r - s - h - a), null != p && (isNaN(l) && isNaN(
				u) && (i / r < p ? l = .8 * i : u = .8 * r), isNaN(l) && (l = p * u), isNaN(u)) && (u = l / p),
			isNaN(o) && (o = i - e - l - c), isNaN(a) && (a = r - s - u - h), t.left || t.right) {
			case "center":
				o = i / 2 - l / 2 - n[3];
				break;
			case "right":
				o = i - l - c
		}
		switch (t.top || t.bottom) {
			case "middle":
			case "center":
				a = r / 2 - u / 2 - n[0];
				break;
			case "bottom":
				a = r - u - h
		}
		o = o || 0, a = a || 0, isNaN(l) && (l = i - c - o - (e || 0)), isNaN(u) && (u = r - h - a - (s || 0));
		p = new U(o + n[3], a + n[0], l, u);
		return p.margin = n, p
	}

	function Jp(t) {
		t = t.layoutMode || t.constructor.layoutMode;
		return L(t) ? t : t ? {
			type: t
		} : null
	}

	function td(l, u, t) {
		var h = t && t.ignoreSize,
			t = (V(h) || (h = [h, h]), n(Zp[0], 0)),
			e = n(Zp[1], 1);

		function n(t, e) {
			var n = {},
				i = 0,
				r = {},
				o = 0;
			if (qp(t, function(t) {
					r[t] = l[t]
				}), qp(t, function(t) {
					c(u, t) && (n[t] = r[t] = u[t]), p(n, t) && i++, p(r, t) && o++
				}), h[e]) p(u, t[1]) ? r[t[2]] = null : p(u, t[2]) && (r[t[1]] = null);
			else if (2 !== o && i) {
				if (!(2 <= i))
					for (var a = 0; a < t.length; a++) {
						var s = t[a];
						if (!c(n, s) && c(l, s)) {
							n[s] = l[s];
							break
						}
					}
				return n
			}
			return r
		}

		function c(t, e) {
			return t.hasOwnProperty(e)
		}

		function p(t, e) {
			return null != t[e] && "auto" !== t[e]
		}

		function i(t, e, n) {
			qp(t, function(t) {
				e[t] = n[t]
			})
		}
		i(Zp[0], l, t), i(Zp[1], l, e)
	}

	function ed(t) {
		return e = {}, (n = t) && e && qp(jp, function(t) {
			n.hasOwnProperty(t) && (e[t] = n[t])
		}), e;
		var e, n
	}
	dt(Kp, "vertical"), dt(Kp, "horizontal");
	var nd, id, rd, od, ad = Yo(),
		g = (u(sd, nd = Qc), sd.prototype.init = function(t, e, n) {
			this.mergeDefaultAndTheme(t, n)
		}, sd.prototype.mergeDefaultAndTheme = function(t, e) {
			var n = Jp(this),
				i = n ? ed(t) : {};
			d(t, e.getTheme().get(this.mainType)), d(t, this.getDefaultOption()), n && td(t, i, n)
		}, sd.prototype.mergeOption = function(t, e) {
			d(this.option, t, !0);
			var n = Jp(this);
			n && td(this.option, t, n)
		}, sd.prototype.optionUpdated = function(t, e) {}, sd.prototype.getDefaultOption = function() {
			var t = this.constructor;
			if (!(e = t) || !e[na]) return t.defaultOption;
			var e = ad(this);
			if (!e.defaultOption) {
				for (var n = [], i = t; i;) {
					var r = i.prototype.defaultOption;
					r && n.push(r), i = i.superClass
				}
				for (var o = {}, a = n.length - 1; 0 <= a; a--) o = d(o, n[a], !0);
				e.defaultOption = o
			}
			return e.defaultOption
		}, sd.prototype.getReferringComponents = function(t, e) {
			var n = t + "Id";
			return $o(this.ecModel, t, {
				index: this.get(t + "Index", !0),
				id: this.get(n, !0)
			}, e)
		}, sd.prototype.getBoxLayoutParams = function() {
			return {
				left: this.get("left"),
				top: this.get("top"),
				right: this.get("right"),
				bottom: this.get("bottom"),
				width: this.get("width"),
				height: this.get("height")
			}
		}, sd.prototype.getZLevelKey = function() {
			return ""
		}, sd.prototype.setZLevel = function(t) {
			this.option.zlevel = t
		}, sd.protoInitialize = ((Xc = sd.prototype).type = "component", Xc.id = "", Xc.name = "", Xc.mainType =
			"", Xc.subType = "", void(Xc.componentIndex = 0)), sd);

	function sd(t, e, n) {
		t = nd.call(this, t, e, n) || this;
		return t.uid = ep("ec_cpt_model"), t
	}

	function ld(t, e) {
		return t[e] || (t[e] = {
			predecessor: [],
			successor: []
		}), t[e]
	}
	oa(g, Qc), ua(g), od = {}, (rd = g).registerSubTypeDefaulter = function(t, e) {
		t = ia(t);
		od[t.main] = e
	}, rd.determineSubType = function(t, e) {
		var n, i = e.type;
		return i || (n = ia(t).main, rd.hasSubTypes(t) && od[n] && (i = od[n](e))), i
	}, id = function(t) {
		var e = [];
		return E(g.getClassesByMainType(t), function(t) {
			e = e.concat(t.dependencies || t.prototype.dependencies || [])
		}), e = F(e, function(t) {
			return ia(t).main
		}), "dataset" !== t && I(e, "dataset") <= 0 && e.unshift("dataset"), e
	}, g.topologicalTravel = function(t, e, n, i) {
		if (t.length) {
			c = {}, p = [], E(h = e, function(n) {
				var e, i, r = ld(c, n),
					t = (t = r.originalDeps = id(n), e = h, i = [], E(t, function(t) {
						0 <= I(e, t) && i.push(t)
					}), i);
				r.entryCount = t.length, 0 === r.entryCount && p.push(n), E(t, function(t) {
					I(r.predecessor, t) < 0 && r.predecessor.push(t);
					var e = ld(c, t);
					I(e.successor, t) < 0 && e.successor.push(n)
				})
			});
			var e = {
					graph: c,
					noEntryList: p
				},
				r = e.graph,
				o = e.noEntryList,
				a = {};
			for (E(t, function(t) {
					a[t] = !0
				}); o.length;) {
				var s = o.pop(),
					l = r[s],
					u = !!a[s];
				u && (n.call(i, s, l.originalDeps.slice()), delete a[s]), E(l.successor, u ? f : d)
			}
			E(a, function() {
				throw new Error("")
			})
		}
		var h, c, p;

		function d(t) {
			r[t].entryCount--, 0 === r[t].entryCount && o.push(t)
		}

		function f(t) {
			a[t] = !0, d(t)
		}
	};
	var Zc = "",
		pa = ("undefined" != typeof navigator && (Zc = navigator.platform || ""), "rgba(0, 0, 0, 0.2)"),
		ud = {
			darkMode: "auto",
			colorBy: "series",
			color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4",
				"#ea7ccc"
			],
			gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
			aria: {
				decal: {
					decals: [{
						color: pa,
						dashArrayX: [1, 0],
						dashArrayY: [2, 5],
						symbolSize: 1,
						rotation: Math.PI / 6
					}, {
						color: pa,
						symbol: "circle",
						dashArrayX: [
							[8, 8],
							[0, 8, 8, 0]
						],
						dashArrayY: [6, 0],
						symbolSize: .8
					}, {
						color: pa,
						dashArrayX: [1, 0],
						dashArrayY: [4, 3],
						rotation: -Math.PI / 4
					}, {
						color: pa,
						dashArrayX: [
							[6, 6],
							[0, 6, 6, 0]
						],
						dashArrayY: [6, 0]
					}, {
						color: pa,
						dashArrayX: [
							[1, 0],
							[1, 6]
						],
						dashArrayY: [1, 0, 6, 0],
						rotation: Math.PI / 4
					}, {
						color: pa,
						symbol: "triangle",
						dashArrayX: [
							[9, 9],
							[0, 9, 9, 0]
						],
						dashArrayY: [7, 2],
						symbolSize: .75
					}]
				}
			},
			textStyle: {
				fontFamily: Zc.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
				fontSize: 12,
				fontStyle: "normal",
				fontWeight: "normal"
			},
			blendMode: null,
			stateAnimation: {
				duration: 300,
				easing: "cubicOut"
			},
			animation: "auto",
			animationDuration: 1e3,
			animationDurationUpdate: 500,
			animationEasing: "cubicInOut",
			animationEasingUpdate: "cubicInOut",
			animationThreshold: 2e3,
			progressiveThreshold: 3e3,
			progressive: 400,
			hoverLayerThreshold: 3e3,
			useUTC: !1
		},
		hd = z(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]),
		cd = "original",
		pd = "arrayRows",
		dd = "objectRows",
		fd = "keyedColumns",
		gd = "typedArray",
		yd = "unknown",
		md = "column",
		vd = "row",
		_d = {
			Must: 1,
			Might: 2,
			Not: 3
		},
		xd = Yo();

	function wd(n, t, e) {
		var r, i, o, a, s, l = {},
			u = Sd(t);
		return u && n && (o = [], a = [], t = t.ecModel, t = xd(t).datasetMap, u = u.uid + "_" + e.seriesLayoutBy,
			E(n = n.slice(), function(t, e) {
				t = L(t) ? t : n[e] = {
					name: t
				};
				"ordinal" === t.type && null == r && (r = e, i = c(t)), l[t.name] = []
			}), s = t.get(u) || t.set(u, {
				categoryWayDim: i,
				valueWayDim: 0
			}), E(n, function(t, e) {
				var n, i = t.name,
					t = c(t);
				null == r ? (n = s.valueWayDim, h(l[i], n, t), h(a, n, t), s.valueWayDim += t) : r === e ? (
					h(l[i], 0, t), h(o, 0, t)) : (n = s.categoryWayDim, h(l[i], n, t), h(a, n, t), s
					.categoryWayDim += t)
			}), o.length && (l.itemName = o), a.length) && (l.seriesName = a), l;

		function h(t, e, n) {
			for (var i = 0; i < n; i++) t.push(e + i)
		}

		function c(t) {
			t = t.dimsDef;
			return t ? t.length : 1
		}
	}

	function bd(t, l, u) {
		var h, c, p, e = {};
		return Sd(t) && (c = l.sourceFormat, p = l.dimensionsDefine, c !== dd && c !== fd || E(p, function(t, e) {
			"name" === (L(t) ? t.name : t) && (h = e)
		}), t = function() {
			for (var t = {}, e = {}, n = [], i = 0, r = Math.min(5, u); i < r; i++) {
				var o = Td(l.data, c, l.seriesLayoutBy, p, l.startIndex, i),
					a = (n.push(o), o === _d.Not);
				if (a && null == t.v && i !== h && (t.v = i), null != t.n && t.n !== t.v && (a || n[t.n] !==
						_d.Not) || (t.n = i), s(t) && n[t.n] !== _d.Not) return t;
				a || (o === _d.Might && null == e.v && i !== h && (e.v = i), null != e.n && e.n !== e.v) ||
					(e.n = i)
			}

			function s(t) {
				return null != t.v && null != t.n
			}
			return s(t) ? t : s(e) ? e : null
		}()) && (e.value = [t.v], t = null != h ? h : t.n, e.itemName = [t], e.seriesName = [t]), e
	}

	function Sd(t) {
		if (!t.get("data", !0)) return $o(t.ecModel, "dataset", {
			index: t.get("datasetIndex", !0),
			id: t.get("datasetId", !0)
		}, Ko).models[0]
	}

	function Md(t, e) {
		return Td(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e)
	}

	function Td(t, e, n, i, r, o) {
		var a, s, l;
		if (!yt(t)) {
			if (i && (L(i = i[o]) ? (s = i.name, l = i.type) : H(i) && (s = i)), null != l) return "ordinal" === l ?
				_d.Must : _d.Not;
			if (e === pd) {
				var u = t;
				if (n === vd) {
					for (var h = u[o], c = 0; c < (h || []).length && c < 5; c++)
						if (null != (a = m(h[r + c]))) return a
				} else
					for (c = 0; c < u.length && c < 5; c++) {
						var p = u[r + c];
						if (p && null != (a = m(p[o]))) return a
					}
			} else if (e === dd) {
				var d = t;
				if (!s) return _d.Not;
				for (c = 0; c < d.length && c < 5; c++)
					if ((g = d[c]) && null != (a = m(g[s]))) return a
			} else if (e === fd) {
				if (!s) return _d.Not;
				if (!(h = t[s]) || yt(h)) return _d.Not;
				for (c = 0; c < h.length && c < 5; c++)
					if (null != (a = m(h[c]))) return a
			} else if (e === cd)
				for (var f = t, c = 0; c < f.length && c < 5; c++) {
					var g = f[c],
						y = zo(g);
					if (!V(y)) return _d.Not;
					if (null != (a = m(y[o]))) return a
				}
		}
		return _d.Not;

		function m(t) {
			var e = H(t);
			return null != t && isFinite(t) && "" !== t ? e ? _d.Might : _d.Not : e && "-" !== t ? _d.Must : void 0
		}
	}
	var Cd = z();
	var Id = Yo(),
		kd = (Yo(), Dd.prototype.getColorFromPalette = function(t, e, n) {
			var i = Ro(this.get("color", !0)),
				r = this.get("colorLayer", !0),
				o = this,
				a = Id;
			return a = a(e = e || o), o = a.paletteIdx || 0, (e = a.paletteNameMap = a.paletteNameMap || {})
				.hasOwnProperty(t) ? e[t] : (r = (r = null != n && r ? function(t, e) {
					for (var n = t.length, i = 0; i < n; i++)
						if (t[i].length > e) return t[i];
					return t[n - 1]
				}(r, n) : i) || i) && r.length ? (n = r[o], t && (e[t] = n), a.paletteIdx = (o + 1) % r.length,
					n) : void 0
		}, Dd.prototype.clearColorPalette = function() {
			var t, e;
			(e = Id)(t = this).paletteIdx = 0, e(t).paletteNameMap = {}
		}, Dd);

	function Dd() {}
	var Ad, Pd, Ld, Od, Rd = "\0_ec_inner",
		Nd = (u(s, Od = Qc), s.prototype.init = function(t, e, n, i, r, o) {
			i = i || {}, this.option = null, this._theme = new Qc(i), this._locale = new Qc(r), this
				._optionManager = o
		}, s.prototype.setOption = function(t, e, n) {
			e = Bd(e);
			this._optionManager.setOption(t, n, e), this._resetOption(null, e)
		}, s.prototype.resetOption = function(t, e) {
			return this._resetOption(t, Bd(e))
		}, s.prototype._resetOption = function(t, e) {
			var n, i = !1,
				r = this._optionManager;
			return t && "recreate" !== t || (n = r.mountOption("recreate" === t), this.option && "recreate" !==
					t ? (this.restoreData(), this._mergeOption(n, e)) : Ld(this, n), i = !0), "timeline" !==
				t && "media" !== t || this.restoreData(), t && "recreate" !== t && "timeline" !== t || (n = r
					.getTimelineOption(this)) && (i = !0, this._mergeOption(n, e)), t && "recreate" !== t &&
				"media" !== t || (n = r.getMediaOption(this)).length && E(n, function(t) {
					i = !0, this._mergeOption(t, e)
				}, this), i
		}, s.prototype.mergeOption = function(t) {
			this._mergeOption(t, null)
		}, s.prototype._mergeOption = function(i, t) {
			var r = this.option,
				h = this._componentsMap,
				c = this._componentsCount,
				n = [],
				o = z(),
				p = t && t.replaceMergeMainTypeMap;
			xd(this).datasetMap = z(), E(i, function(t, e) {
				null != t && (g.hasClass(e) ? e && (n.push(e), o.set(e, !0)) : r[e] = null == r[e] ? _(
					t) : d(r[e], t, !0))
			}), p && p.each(function(t, e) {
				g.hasClass(e) && !o.get(e) && (n.push(e), o.set(e, !0))
			}), g.topologicalTravel(n, g.getAllClassMainTypes(), function(o) {
				t = this, n = Ro(i[e = o]);
				var t = (e = (e = Cd.get(e)) && e(t)) ? n.concat(e) : n,
					e = h.get(o),
					n = Bo(e, t, e ? p && p.get(o) ? "replaceMerge" : "normalMerge" : "replaceAll");
				Uo(n, o, g), r[o] = null, h.set(o, null), c.set(o, 0);
				var a, s = [],
					l = [],
					u = 0;
				E(n, function(t, e) {
					var n = t.existing,
						i = t.newOption;
					if (i) {
						var r = g.getClass(o, t.keyInfo.subType, !("series" === o));
						if (!r) return;
						if ("tooltip" === o) {
							if (a) return;
							a = !0
						}
						n && n.constructor === r ? (n.name = t.keyInfo.name, n.mergeOption(i,
							this), n.optionUpdated(i, !1)) : (e = O({
								componentIndex: e
							}, t.keyInfo), O(n = new r(i, this, this, e), e), t.brandNew &&
							(n.__requireNewView = !0), n.init(i, this, this), n
							.optionUpdated(null, !0))
					} else n && (n.mergeOption({}, this), n.optionUpdated({}, !1));
					n ? (s.push(n.option), l.push(n), u++) : (s.push(void 0), l.push(void 0))
				}, this), r[o] = s, h.set(o, l), c.set(o, u), "series" === o && Ad(this)
			}, this), this._seriesIndices || Ad(this)
		}, s.prototype.getOption = function() {
			var a = _(this.option);
			return E(a, function(t, e) {
				if (g.hasClass(e)) {
					for (var n = Ro(t), i = n.length, r = !1, o = i - 1; 0 <= o; o--) n[o] && !Wo(n[
						o]) ? r = !0 : (n[o] = null, r || i--);
					n.length = i, a[e] = n
				}
			}), delete a[Rd], a
		}, s.prototype.getTheme = function() {
			return this._theme
		}, s.prototype.getLocaleModel = function() {
			return this._locale
		}, s.prototype.setUpdatePayload = function(t) {
			this._payload = t
		}, s.prototype.getUpdatePayload = function() {
			return this._payload
		}, s.prototype.getComponent = function(t, e) {
			var n = this._componentsMap.get(t);
			if (n) {
				t = n[e || 0];
				if (t) return t;
				if (null == e)
					for (var i = 0; i < n.length; i++)
						if (n[i]) return n[i]
			}
		}, s.prototype.queryComponents = function(t) {
			var e, n, i, r, o, a = t.mainType;
			return a && (n = t.index, i = t.id, r = t.name, o = this._componentsMap.get(a)) && o.length ? (
				null != n ? (e = [], E(Ro(n), function(t) {
					o[t] && e.push(o[t])
				})) : e = null != i ? Ed("id", i, o) : null != r ? Ed("name", r, o) : ct(o, function(t) {
					return !!t
				}), zd(e, t)) : []
		}, s.prototype.findComponents = function(t) {
			var e, n = t.query,
				i = t.mainType,
				r = (r = i + "Index", o = i + "Id", e = i + "Name", !n || null == n[r] && null == n[o] &&
					null == n[e] ? null : {
						mainType: i,
						index: n[r],
						id: n[o],
						name: n[e]
					}),
				o = zd(r ? this.queryComponents(r) : ct(this._componentsMap.get(i), function(t) {
					return !!t
				}), t);
			return t.filter ? ct(o, t.filter) : o
		}, s.prototype.eachComponent = function(t, e, n) {
			var i = this._componentsMap;
			if (S(t)) {
				var r = e,
					o = t;
				i.each(function(t, e) {
					for (var n = 0; t && n < t.length; n++) {
						var i = t[n];
						i && o.call(r, e, i, i.componentIndex)
					}
				})
			} else
				for (var a = H(t) ? i.get(t) : L(t) ? this.findComponents(t) : null, s = 0; a && s < a
					.length; s++) {
					var l = a[s];
					l && e.call(n, l, l.componentIndex)
				}
		}, s.prototype.getSeriesByName = function(t) {
			var e = Ho(t, null);
			return ct(this._componentsMap.get("series"), function(t) {
				return !!t && null != e && t.name === e
			})
		}, s.prototype.getSeriesByIndex = function(t) {
			return this._componentsMap.get("series")[t]
		}, s.prototype.getSeriesByType = function(e) {
			return ct(this._componentsMap.get("series"), function(t) {
				return !!t && t.subType === e
			})
		}, s.prototype.getSeries = function() {
			return ct(this._componentsMap.get("series"), function(t) {
				return !!t
			})
		}, s.prototype.getSeriesCount = function() {
			return this._componentsCount.get("series")
		}, s.prototype.eachSeries = function(n, i) {
			Pd(this), E(this._seriesIndices, function(t) {
				var e = this._componentsMap.get("series")[t];
				n.call(i, e, t)
			}, this)
		}, s.prototype.eachRawSeries = function(e, n) {
			E(this._componentsMap.get("series"), function(t) {
				t && e.call(n, t, t.componentIndex)
			})
		}, s.prototype.eachSeriesByType = function(n, i, r) {
			Pd(this), E(this._seriesIndices, function(t) {
				var e = this._componentsMap.get("series")[t];
				e.subType === n && i.call(r, e, t)
			}, this)
		}, s.prototype.eachRawSeriesByType = function(t, e, n) {
			return E(this.getSeriesByType(t), e, n)
		}, s.prototype.isSeriesFiltered = function(t) {
			return Pd(this), null == this._seriesIndicesMap.get(t.componentIndex)
		}, s.prototype.getCurrentSeriesIndices = function() {
			return (this._seriesIndices || []).slice()
		}, s.prototype.filterSeries = function(n, i) {
			Pd(this);
			var r = [];
			E(this._seriesIndices, function(t) {
				var e = this._componentsMap.get("series")[t];
				n.call(i, e, t) && r.push(t)
			}, this), this._seriesIndices = r, this._seriesIndicesMap = z(r)
		}, s.prototype.restoreData = function(n) {
			Ad(this);
			var t = this._componentsMap,
				i = [];
			t.each(function(t, e) {
				g.hasClass(e) && i.push(e)
			}), g.topologicalTravel(i, g.getAllClassMainTypes(), function(e) {
				E(t.get(e), function(t) {
					!t || "series" === e && function(t, e) {
						{
							var n, i;
							if (e) return n = e.seriesIndex, i = e.seriesId, e = e
								.seriesName, null != n && t.componentIndex !== n ||
								null != i && t.id !== i || null != e && t.name !== e
						}
					}(t, n) || t.restoreData()
				})
			})
		}, s.internalField = (Ad = function(t) {
			var e = t._seriesIndices = [];
			E(t._componentsMap.get("series"), function(t) {
				t && e.push(t.componentIndex)
			}), t._seriesIndicesMap = z(e)
		}, Pd = function(t) {}, void(Ld = function(t, e) {
			t.option = {}, t.option[Rd] = 1, t._componentsMap = z({
				series: []
			}), t._componentsCount = z();
			var n, i, r = e.aria;
			L(r) && null == r.enabled && (r.enabled = !0), n = e, r = t._theme.option, i = n.color && !n
				.colorLayer, E(r, function(t, e) {
					"colorLayer" === e && i || g.hasClass(e) || ("object" == typeof t ? n[e] = n[
						e] ? d(n[e], t, !1) : _(t) : null == n[e] && (n[e] = t))
				}), d(e, ud, !1), t._mergeOption(e, null)
		})), s);

	function s() {
		return null !== Od && Od.apply(this, arguments) || this
	}

	function Ed(e, t, n) {
		var i, r;
		return V(t) ? (i = z(), E(t, function(t) {
			null != t && null != Ho(t, null) && i.set(t, !0)
		}), ct(n, function(t) {
			return t && i.get(t[e])
		})) : (r = Ho(t, null), ct(n, function(t) {
			return t && null != r && t[e] === r
		}))
	}

	function zd(t, e) {
		return e.hasOwnProperty("subType") ? ct(t, function(t) {
			return t && t.subType === e.subType
		}) : t
	}

	function Bd(t) {
		var e = z();
		return t && E(Ro(t.replaceMerge), function(t) {
			e.set(t, !0)
		}), {
			replaceMergeMainTypeMap: e
		}
	}
	lt(Nd, kd);

	function Fd(e) {
		E(Vd, function(t) {
			this[t] = pt(e[t], e)
		}, this)
	}
	var Vd = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isSSR",
			"isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getOption", "getId",
			"updateLabelLayout"
		],
		Hd = {},
		Gd = (Wd.prototype.create = function(n, i) {
			var r = [];
			E(Hd, function(t, e) {
				t = t.create(n, i);
				r = r.concat(t || [])
			}), this._coordinateSystems = r
		}, Wd.prototype.update = function(e, n) {
			E(this._coordinateSystems, function(t) {
				t.update && t.update(e, n)
			})
		}, Wd.prototype.getCoordinateSystems = function() {
			return this._coordinateSystems.slice()
		}, Wd.register = function(t, e) {
			Hd[t] = e
		}, Wd.get = function(t) {
			return Hd[t]
		}, Wd);

	function Wd() {
		this._coordinateSystems = []
	}
	var Ud = /^(min|max)?(.+)$/,
		Xd = (Yd.prototype.setOption = function(t, e, n) {
			t && (E(Ro(t.series), function(t) {
				t && t.data && yt(t.data) && Dt(t.data)
			}), E(Ro(t.dataset), function(t) {
				t && t.source && yt(t.source) && Dt(t.source)
			})), t = _(t);
			var i, r, o, a, s, l, u, h, c, p, d = this._optionBackup,
				t = (i = e, r = !d, s = [], t = (e = t).baseOption, l = e.timeline, u = e.options, h = e.media,
					c = !!e.media, p = !!(u || l || t && t.timeline), t ? (a = t).timeline || (a.timeline = l) :
					((p || c) && (e.options = e.media = null), a = e), c && V(h) && E(h, function(t) {
						t && t.option && (t.query ? s.push(t) : o = o || t)
					}), f(a), E(u, f), E(s, function(t) {
						return f(t.option)
					}), {
						baseOption: a,
						timelineOptions: u || [],
						mediaDefault: o,
						mediaList: s
					});

			function f(e) {
				E(i, function(t) {
					t(e, r)
				})
			}
			this._newBaseOption = t.baseOption, d ? (t.timelineOptions.length && (d.timelineOptions = t
					.timelineOptions), t.mediaList.length && (d.mediaList = t.mediaList), t.mediaDefault &&
				(d.mediaDefault = t.mediaDefault)) : this._optionBackup = t
		}, Yd.prototype.mountOption = function(t) {
			var e = this._optionBackup;
			return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this
				._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], _(t ? e.baseOption : this
					._newBaseOption)
		}, Yd.prototype.getTimelineOption = function(t) {
			var e, n = this._timelineOptions;
			return e = n.length && (t = t.getComponent("timeline")) ? _(n[t.getCurrentIndex()]) : e
		}, Yd.prototype.getMediaOption = function(t) {
			var e, n, i = this._api.getWidth(),
				r = this._api.getHeight(),
				o = this._mediaList,
				a = this._mediaDefault,
				s = [],
				l = [];
			if (o.length || a) {
				for (var u = 0, h = o.length; u < h; u++) ! function(t, e, n) {
					var i = {
							width: e,
							height: n,
							aspectratio: e / n
						},
						r = !0;
					return E(t, function(t, e) {
						var n, e = e.match(Ud);
						e && e[1] && e[2] && (n = e[1], e = e[2].toLowerCase(), e = i[e], t = t, (
								"min" === (n = n) ? t <= e : "max" === n ? e <= t : e === t) ||
							(r = !1))
					}), r
				}(o[u].query, i, r) || s.push(u);
				(s = !s.length && a ? [-1] : s).length && (e = s, n = this._currentMediaIndices, e.join(",") !==
					n.join(",")) && (l = F(s, function(t) {
					return _((-1 === t ? a : o[t]).option)
				})), this._currentMediaIndices = s
			}
			return l
		}, Yd);

	function Yd(t) {
		this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t
	}
	var qd = E,
		jd = L,
		Zd = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];

	function Kd(t) {
		var e = t && t.itemStyle;
		if (e)
			for (var n = 0, i = Zd.length; n < i; n++) {
				var r = Zd[n],
					o = e.normal,
					a = e.emphasis;
				o && o[r] && (t[r] = t[r] || {}, t[r].normal ? d(t[r].normal, o[r]) : t[r].normal = o[r], o[r] =
					null), a && a[r] && (t[r] = t[r] || {}, t[r].emphasis ? d(t[r].emphasis, a[r]) : t[r]
					.emphasis = a[r], a[r] = null)
			}
	}

	function $d(t, e, n) {
		var i, r;
		t && t[e] && (t[e].normal || t[e].emphasis) && (i = t[e].normal, r = t[e].emphasis, i && (n ? (t[e].normal =
			t[e].emphasis = null, B(t[e], i)) : t[e] = i), r) && (t.emphasis = t.emphasis || {}, (t.emphasis[
			e] = r).focus && (t.emphasis.focus = r.focus), r.blurScope) && (t.emphasis.blurScope = r.blurScope)
	}

	function Qd(t) {
		$d(t, "itemStyle"), $d(t, "lineStyle"), $d(t, "areaStyle"), $d(t, "label"), $d(t, "labelLine"), $d(t,
			"upperLabel"), $d(t, "edgeLabel")
	}

	function Jd(t, e) {
		var n = jd(t) && t[e],
			i = jd(n) && n.textStyle;
		if (i)
			for (var r = 0, o = Eo.length; r < o; r++) {
				var a = Eo[r];
				i.hasOwnProperty(a) && (n[a] = i[a])
			}
	}

	function tf(t) {
		t && (Qd(t), Jd(t, "label"), t.emphasis) && Jd(t.emphasis, "label")
	}

	function ef(t) {
		return V(t) ? t : t ? [t] : []
	}

	function nf(t) {
		return (V(t) ? t[0] : t) || {}
	}

	function rf(e, t) {
		qd(ef(e.series), function(t) {
			if (jd(t))
				if (jd(t)) {
					Kd(t), Qd(t), Jd(t, "label"), Jd(t, "upperLabel"), Jd(t, "edgeLabel"), t.emphasis && (
						Jd(t.emphasis, "label"), Jd(t.emphasis, "upperLabel"), Jd(t.emphasis,
							"edgeLabel"));
					var e = t.markPoint,
						n = (e && (Kd(e), tf(e)), t.markLine),
						i = (n && (Kd(n), tf(n)), t.markArea),
						r = (i && tf(i), t.data);
					if ("graph" === t.type) {
						var r = r || t.nodes,
							o = t.links || t.edges;
						if (o && !yt(o))
							for (var a = 0; a < o.length; a++) tf(o[a]);
						E(t.categories, function(t) {
							Qd(t)
						})
					}
					if (r && !yt(r))
						for (a = 0; a < r.length; a++) tf(r[a]);
					if ((e = t.markPoint) && e.data)
						for (var s = e.data, a = 0; a < s.length; a++) tf(s[a]);
					if ((n = t.markLine) && n.data) {
						var l = n.data;
						for (a = 0; a < l.length; a++) V(l[a]) ? (tf(l[a][0]), tf(l[a][1])) : tf(l[a])
					}
					"gauge" === t.type ? (Jd(t, "axisLabel"), Jd(t, "title"), Jd(t, "detail")) :
						"treemap" === t.type ? ($d(t.breadcrumb, "itemStyle"), E(t.levels, function(t) {
							Qd(t)
						})) : "tree" === t.type && Qd(t.leaves)
				}
		});
		var n = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
		t && n.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), qd(n, function(t) {
			qd(ef(e[t]), function(t) {
				t && (Jd(t, "axisLabel"), Jd(t.axisPointer, "label"))
			})
		}), qd(ef(e.parallel), function(t) {
			t = t && t.parallelAxisDefault;
			Jd(t, "axisLabel"), Jd(t && t.axisPointer, "label")
		}), qd(ef(e.calendar), function(t) {
			$d(t, "itemStyle"), Jd(t, "dayLabel"), Jd(t, "monthLabel"), Jd(t, "yearLabel")
		}), qd(ef(e.radar), function(t) {
			Jd(t, "name"), t.name && null == t.axisName && (t.axisName = t.name, delete t.name), null != t
				.nameGap && null == t.axisNameGap && (t.axisNameGap = t.nameGap, delete t.nameGap)
		}), qd(ef(e.geo), function(t) {
			jd(t) && (tf(t), qd(ef(t.regions), function(t) {
				tf(t)
			}))
		}), qd(ef(e.timeline), function(t) {
			tf(t), $d(t, "label"), $d(t, "itemStyle"), $d(t, "controlStyle", !0);
			t = t.data;
			V(t) && E(t, function(t) {
				L(t) && ($d(t, "label"), $d(t, "itemStyle"))
			})
		}), qd(ef(e.toolbox), function(t) {
			$d(t, "iconStyle"), qd(t.feature, function(t) {
				$d(t, "iconStyle")
			})
		}), Jd(nf(e.axisPointer), "label"), Jd(nf(e.tooltip).axisPointer, "label")
	}

	function of(e) {
		e && E(af, function(t) {
			t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]])
		})
	}
	var af = [
			["x", "left"],
			["y", "top"],
			["x2", "right"],
			["y2", "bottom"]
		],
		sf = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
		lf = [
			["borderRadius", "barBorderRadius"],
			["borderColor", "barBorderColor"],
			["borderWidth", "barBorderWidth"]
		];

	function uf(t) {
		var e = t && t.itemStyle;
		if (e)
			for (var n = 0; n < lf.length; n++) {
				var i = lf[n][1],
					r = lf[n][0];
				null != e[i] && (e[r] = e[i])
			}
	}

	function hf(t) {
		t && "edge" === t.alignTo && null != t.margin && null == t.edgeDistance && (t.edgeDistance = t.margin)
	}

	function cf(t) {
		t && t.downplay && !t.blur && (t.blur = t.downplay)
	}

	function pf(e, t) {
		rf(e, t), e.series = Ro(e.series), E(e.series, function(t) {
			if (L(t)) {
				var e, n = t.type;
				if ("line" === n) null != t.clipOverflow && (t.clip = t.clipOverflow);
				else if ("pie" === n || "gauge" === n) {
					if (null != t.clockWise && (t.clockwise = t.clockWise), hf(t.label), (e = t.data) && !
						yt(e))
						for (var i = 0; i < e.length; i++) hf(e[i]);
					null != t.hoverOffset && (t.emphasis = t.emphasis || {}, t.emphasis.scaleSize = null) &&
						(t.emphasis.scaleSize = t.hoverOffset)
				} else if ("gauge" === n) {
					var r = function(t, e) {
						for (var n = e.split(","), i = t, r = 0; r < n.length && null != (i = i && i[n[
								r]]); r++);
						return i
					}(t, "pointer.color");
					if (null != r) {
						var o = t;
						var a = "itemStyle.color";
						var s = void 0;
						for (var l, u = a.split(","), h = o, c = 0; c < u.length - 1; c++) null == h[l = u[
							c]] && (h[l] = {}), h = h[l];
						!s && null != h[u[c]] || (h[u[c]] = r)
					}
				} else if ("bar" === n) {
					if (uf(t), uf(t.backgroundStyle), uf(t.emphasis), (e = t.data) && !yt(e))
						for (i = 0; i < e.length; i++) "object" == typeof e[i] && (uf(e[i]), uf(e[i] && e[i]
							.emphasis))
				} else "sunburst" === n ? ((a = t.highlightPolicy) && (t.emphasis = t.emphasis || {}, t
						.emphasis.focus || (t.emphasis.focus = a)), cf(t), function t(e, n) {
						if (e)
							for (var i = 0; i < e.length; i++) n(e[i]), e[i] && t(e[i].children, n)
					}(t.data, cf)) : "graph" === n || "sankey" === n ? (o = t) && null != o
					.focusNodeAdjacency && (o.emphasis = o.emphasis || {}, null == o.emphasis.focus) && (o
						.emphasis.focus = "adjacency") : "map" === n && (t.mapType && !t.map && (t.map = t
						.mapType), t.mapLocation) && B(t, t.mapLocation);
				null != t.hoverAnimation && (t.emphasis = t.emphasis || {}, t.emphasis) && null == t
					.emphasis.scale && (t.emphasis.scale = t.hoverAnimation), of(t)
			}
		}), e.dataRange && (e.visualMap = e.dataRange), E(sf, function(t) {
			t = e[t];
			t && E(t = V(t) ? t : [t], function(t) {
				of(t)
			})
		})
	}

	function df(_) {
		E(_, function(p, d) {
			var f = [],
				g = [NaN, NaN],
				t = [p.stackResultDimension, p.stackedOverDimension],
				y = p.data,
				m = p.isStackedByIndex,
				v = p.seriesModel.get("stackStrategy") || "samesign";
			y.modify(t, function(t, e, n) {
				var i, r, o = y.get(p.stackedDimension, n);
				if (isNaN(o)) return g;
				m ? r = y.getRawIndex(n) : i = y.get(p.stackedByDimension, n);
				for (var a, s, l, u = NaN, h = d - 1; 0 <= h; h--) {
					var c = _[h];
					if (0 <= (r = m ? r : c.data.rawIndexOf(c.stackedByDimension, i))) {
						c = c.data.getByRawIndex(c.stackResultDimension, r);
						if ("all" === v || "positive" === v && 0 < c || "negative" === v && c < 0 ||
							"samesign" === v && 0 <= o && 0 < c || "samesign" === v && o <= 0 && c <
							0) {
							a = o, s = c, l = void 0, l = Math.max(yo(a), yo(s)), a += s, o = co <
								l ? a : go(a, l), u = c;
							break
						}
					}
				}
				return f[0] = o, f[1] = u, f
			})
		})
	}
	var ff, gf, yf = function(t) {
		this.data = t.data || (t.sourceFormat === fd ? {} : []), this.sourceFormat = t.sourceFormat || yd, this
			.seriesLayoutBy = t.seriesLayoutBy || md, this.startIndex = t.startIndex || 0, this
			.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
		var e = this.dimensionsDefine = t.dimensionsDefine;
		if (e)
			for (var n = 0; n < e.length; n++) {
				var i = e[n];
				null == i.type && Md(this, n) === _d.Must && (i.type = "ordinal")
			}
	};

	function mf(t) {
		return t instanceof yf
	}

	function vf(t, e, n) {
		n = n || xf(t);
		var i = e.seriesLayoutBy,
			r = function(t, e, n, i, r) {
				var o, a;
				if (!t) return {
					dimensionsDefine: wf(r),
					startIndex: a,
					dimensionsDetectedCount: o
				}; {
					var s;
					e === pd ? (s = t, "auto" === i || null == i ? bf(function(t) {
							null != t && "-" !== t && (H(t) ? null == a && (a = 1) : a = 0)
						}, n, s, 10) : a = G(i) ? i : i ? 1 : 0, r || 1 !== a || (r = [], bf(function(t, e) {
							r[e] = null != t ? t + "" : ""
						}, n, s, 1 / 0)), o = r ? r.length : n === vd ? s.length : s[0] ? s[0].length : null) :
						e === dd ? r = r || function(t) {
							for (var e, n = 0; n < t.length && !(e = t[n++]););
							if (e) return R(e)
						}(t) : e === fd ? r || (r = [], E(t, function(t, e) {
							r.push(e)
						})) : e === cd && (i = zo(t[0]), o = V(i) && i.length || 1)
				}
				return {
					startIndex: a,
					dimensionsDefine: wf(r),
					dimensionsDetectedCount: o
				}
			}(t, n, i, e.sourceHeader, e.dimensions);
		return new yf({
			data: t,
			sourceFormat: n,
			seriesLayoutBy: i,
			dimensionsDefine: r.dimensionsDefine,
			startIndex: r.startIndex,
			dimensionsDetectedCount: r.dimensionsDetectedCount,
			metaRawOption: _(e)
		})
	}

	function _f(t) {
		return new yf({
			data: t,
			sourceFormat: yt(t) ? gd : cd
		})
	}

	function xf(t) {
		var e = yd;
		if (yt(t)) e = gd;
		else if (V(t)) {
			0 === t.length && (e = pd);
			for (var n = 0, i = t.length; n < i; n++) {
				var r = t[n];
				if (null != r) {
					if (V(r)) {
						e = pd;
						break
					}
					if (L(r)) {
						e = dd;
						break
					}
				}
			}
		} else if (L(t))
			for (var o in t)
				if (Ft(t, o) && ut(t[o])) {
					e = fd;
					break
				} return e
	}

	function wf(t) {
		var i;
		if (t) return i = z(), F(t, function(t, e) {
			var n, t = {
				name: (t = L(t) ? t : {
					name: t
				}).name,
				displayName: t.displayName,
				type: t.type
			};
			return null != t.name && (t.name += "", null == t.displayName && (t.displayName = t.name), (
				n = i.get(t.name)) ? t.name += "-" + n.count++ : i.set(t.name, {
				count: 1
			})), t
		})
	}

	function bf(t, e, n, i) {
		if (e === vd)
			for (var r = 0; r < n.length && r < i; r++) t(n[r] ? n[r][0] : null, r);
		else
			for (var o = n[0] || [], r = 0; r < o.length && r < i; r++) t(o[r], r)
	}

	function Sf(t) {
		t = t.sourceFormat;
		return t === dd || t === fd
	}
	kf.prototype.getSource = function() {
			return this._source
		}, kf.prototype.count = function() {
			return 0
		}, kf.prototype.getItem = function(t, e) {}, kf.prototype.appendData = function(t) {}, kf.prototype.clean =
		function() {}, kf.protoInitialize = ((fc = kf.prototype).pure = !1, void(fc.persistent = !0)), kf
		.internalField = (gf = function(t, e, n) {
			var i, r = n.sourceFormat,
				o = n.seriesLayoutBy,
				a = n.startIndex,
				n = n.dimensionsDefine;
			O(t, ff[Ff(r, o)]), r === gd ? (t.getItem = Mf, t.count = Cf, t.fillStorage = Tf) : (i = Lf(r, o), t
				.getItem = pt(i, null, e, a, n), i = Nf(r, o), t.count = pt(i, null, e, a, n))
		}, Mf = function(t, e) {
			t -= this._offset, e = e || [];
			for (var n = this._data, i = this._dimSize, r = i * t, o = 0; o < i; o++) e[o] = n[r + o];
			return e
		}, Tf = function(t, e, n, i) {
			for (var r = this._data, o = this._dimSize, a = 0; a < o; a++) {
				for (var s = i[a], l = null == s[0] ? 1 / 0 : s[0], u = null == s[1] ? -1 / 0 : s[1], h = e - t,
						c = n[a], p = 0; p < h; p++) {
					var d = r[p * o + a];
					(c[t + p] = d) < l && (l = d), u < d && (u = d)
				}
				s[0] = l, s[1] = u
			}
		}, Cf = function() {
			return this._data ? this._data.length / this._dimSize : 0
		}, (fc = {})[pd + "_" + md] = {
			pure: !0,
			appendData: Df
		}, fc[pd + "_" + vd] = {
			pure: !0,
			appendData: function() {
				throw new Error('Do not support appendData when set seriesLayoutBy: "row".')
			}
		}, fc[dd] = {
			pure: !0,
			appendData: Df
		}, fc[fd] = {
			pure: !0,
			appendData: function(t) {
				var r = this._data;
				E(t, function(t, e) {
					for (var n = r[e] || (r[e] = []), i = 0; i < (t || []).length; i++) n.push(t[i])
				})
			}
		}, fc[cd] = {
			appendData: Df
		}, fc[gd] = {
			persistent: !1,
			pure: !0,
			appendData: function(t) {
				this._data = t
			},
			clean: function() {
				this._offset += this.count(), this._data = null
			}
		}, void(ff = fc));
	var Mf, Tf, Cf, If = kf;

	function kf(t, e) {
		var t = mf(t) ? t : _f(t),
			n = (this._source = t, this._data = t.data);
		t.sourceFormat === gd && (this._offset = 0, this._dimSize = e, this._data = n), gf(this, n, t)
	}

	function Df(t) {
		for (var e = 0; e < t.length; e++) this._data.push(t[e])
	}

	function Af(t, e, n, i) {
		return t[i]
	}(gp = {})[pd + "_" + md] = function(t, e, n, i) {
		return t[i + e]
	}, gp[pd + "_" + vd] = function(t, e, n, i, r) {
		i += e;
		for (var o = r || [], a = t, s = 0; s < a.length; s++) {
			var l = a[s];
			o[s] = l ? l[i] : null
		}
		return o
	}, gp[dd] = Af, gp[fd] = function(t, e, n, i, r) {
		for (var o = r || [], a = 0; a < n.length; a++) {
			var s = t[n[a].name];
			o[a] = s ? s[i] : null
		}
		return o
	}, gp[cd] = Af;
	var Pf = gp;

	function Lf(t, e) {
		return Pf[Ff(t, e)]
	}

	function Of(t, e, n) {
		return t.length
	}(Xc = {})[pd + "_" + md] = function(t, e, n) {
		return Math.max(0, t.length - e)
	}, Xc[pd + "_" + vd] = function(t, e, n) {
		t = t[0];
		return t ? Math.max(0, t.length - e) : 0
	}, Xc[dd] = Of, Xc[fd] = function(t, e, n) {
		t = t[n[0].name];
		return t ? t.length : 0
	}, Xc[cd] = Of;
	var Rf = Xc;

	function Nf(t, e) {
		return Rf[Ff(t, e)]
	}

	function Ef(t, e, n) {
		return t[e]
	}(pa = {})[pd] = Ef, pa[dd] = function(t, e, n) {
		return t[n]
	}, pa[fd] = Ef, pa[cd] = function(t, e, n) {
		t = zo(t);
		return t instanceof Array ? t[e] : t
	}, pa[gd] = Ef;
	var zf = pa;

	function Bf(t) {
		return zf[t]
	}

	function Ff(t, e) {
		return t === pd ? t + "_" + e : t
	}

	function Vf(t, e, n) {
		if (t) {
			var i, r, e = t.getRawDataItem(e);
			if (null != e) return i = (r = t.getStore()).getSource().sourceFormat, null != n ? (t = t
				.getDimensionIndex(n), n = r.getDimensionProperty(t), Bf(i)(e, t, n)) : (r = e, i === cd ?
				zo(e) : r)
		}
	}
	var Hf = /\{@(.+?)\}/g,
		Zc = (Gf.prototype.getDataParams = function(t, e) {
			var n = this.getData(e),
				i = this.getRawValue(t, e),
				r = n.getRawIndex(t),
				o = n.getName(t),
				a = n.getRawDataItem(t),
				s = n.getItemVisual(t, "style"),
				t = s && s[n.getItemVisual(t, "drawType") || "fill"],
				s = s && s.stroke,
				l = this.mainType,
				u = "series" === l,
				n = n.userOutput && n.userOutput.get();
			return {
				componentType: l,
				componentSubType: this.subType,
				componentIndex: this.componentIndex,
				seriesType: u ? this.subType : null,
				seriesIndex: this.seriesIndex,
				seriesId: u ? this.id : null,
				seriesName: u ? this.name : null,
				name: o,
				dataIndex: r,
				data: a,
				dataType: e,
				value: i,
				color: t,
				borderColor: s,
				dimensionNames: n ? n.fullDimensions : null,
				encode: n ? n.encode : null,
				$vars: ["seriesName", "name", "value"]
			}
		}, Gf.prototype.getFormattedLabel = function(i, t, e, n, r, o) {
			t = t || "normal";
			var a = this.getData(e),
				e = this.getDataParams(i, e);
			return o && (e.value = o.interpolatedValue), null != n && V(e.value) && (e.value = e.value[n]), S(
				r = r || a.getItemModel(i).get("normal" === t ? ["label", "formatter"] : [t, "label",
					"formatter"
				])) ? (e.status = t, e.dimensionIndex = n, r(e)) : H(r) ? Wp(r, e).replace(Hf, function(t,
				e) {
				var n = e.length,
					n = ("[" === e.charAt(0) && "]" === e.charAt(n - 1) && (e = +e.slice(1, n - 1)), Vf(
						a, i, e));
				return null != (n = o && V(o.interpolatedValue) && 0 <= (e = a.getDimensionIndex(e)) ? o
					.interpolatedValue[e] : n) ? n + "" : ""
			}) : void 0
		}, Gf.prototype.getRawValue = function(t, e) {
			return Vf(this.getData(e), t)
		}, Gf.prototype.formatTooltip = function(t, e, n) {}, Gf);

	function Gf() {}

	function Wf(t) {
		var e, n;
		return L(t) ? t.type && (n = t) : e = t, {
			text: e,
			frag: n
		}
	}

	function Uf(t) {
		return new Xf(t)
	}
	Yf.prototype.perform = function(t) {
		var e, n = this._upstream,
			i = t && t.skip;
		this._dirty && n && ((o = this.context).data = o.outputData = n.context.outputData), this.__pipeline &&
			(this.__pipeline.currentTask = this), this._plan && !i && (e = this._plan(this.context));
		var r, o = u(this._modBy),
			a = this._modDataCount || 0,
			s = u(t && t.modBy),
			l = t && t.modDataCount || 0;

		function u(t) {
			return t = 1 <= t ? t : 1
		}
		o === s && a === l || (e = "reset"), !this._dirty && "reset" !== e || (this._dirty = !1, r = this
			._doReset(i)), this._modBy = s, this._modDataCount = l;
		o = t && t.step;
		if (this._dueEnd = n ? n._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this
			._progress) {
			var h = this._dueIndex,
				c = Math.min(null != o ? this._dueIndex + o : 1 / 0, this._dueEnd);
			if (!i && (r || h < c)) {
				var p = this._progress;
				if (V(p))
					for (var d = 0; d < p.length; d++) this._doProgress(p[d], h, c, s, l);
				else this._doProgress(p, h, c, s, l)
			}
			this._dueIndex = c;
			a = null != this._settedOutputEnd ? this._settedOutputEnd : c;
			this._outputDueEnd = a
		} else this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd :
			this._dueEnd;
		return this.unfinished()
	}, Yf.prototype.dirty = function() {
		this._dirty = !0, this._onDirty && this._onDirty(this.context)
	}, Yf.prototype._doProgress = function(t, e, n, i, r) {
		Jf.reset(e, n, i, r), this._callingProgress = t, this._callingProgress({
			start: e,
			end: n,
			count: n - e,
			next: Jf.next
		}, this.context)
	}, Yf.prototype._doReset = function(t) {
		this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null, !t && this
			._reset && ((e = this._reset(this.context)) && e.progress && (n = e.forceFirstProgress, e = e
				.progress), V(e)) && !e.length && (e = null), this._progress = e, this._modBy = this
			._modDataCount = null;
		var e, n, t = this._downstream;
		return t && t.dirty(), n
	}, Yf.prototype.unfinished = function() {
		return this._progress && this._dueIndex < this._dueEnd
	}, Yf.prototype.pipe = function(t) {
		this._downstream === t && !this._dirty || ((this._downstream = t)._upstream = this, t.dirty())
	}, Yf.prototype.dispose = function() {
		this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this
			._downstream._upstream = null), this._dirty = !1, this._disposed = !0)
	}, Yf.prototype.getUpstream = function() {
		return this._upstream
	}, Yf.prototype.getDownstream = function() {
		return this._downstream
	}, Yf.prototype.setOutputEnd = function(t) {
		this._outputDueEnd = this._settedOutputEnd = t
	};
	var Xf = Yf;

	function Yf(t) {
		this._reset = (t = t || {}).reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty,
			this._dirty = !0
	}
	var qf, jf, Zf, Kf, $f, Qf, Jf = Qf = {
		reset: function(t, e, n, i) {
			jf = t, qf = e, Zf = n, Kf = i, $f = Math.ceil(Kf / Zf), Qf.next = 1 < Zf && 0 < Kf ? eg : tg
		}
	};

	function tg() {
		return jf < qf ? jf++ : null
	}

	function eg() {
		var t = jf % $f * Zf + Math.ceil(jf / $f),
			t = qf <= jf ? null : t < Kf ? t : jf;
		return jf++, t
	}

	function ng(t, e) {
		e = e && e.type;
		return "ordinal" === e ? t : null == (t = "time" !== e || G(t) || null == t || "-" === t ? t : +So(t)) ||
			"" === t ? NaN : +t
	}
	var ig = z({
		number: function(t) {
			return parseFloat(t)
		},
		time: function(t) {
			return +So(t)
		},
		trim: function(t) {
			return H(t) ? It(t) : t
		}
	});

	function rg(t) {
		return ig.get(t)
	}
	var og = {
			lt: function(t, e) {
				return t < e
			},
			lte: function(t, e) {
				return t <= e
			},
			gt: function(t, e) {
				return e < t
			},
			gte: function(t, e) {
				return e <= t
			}
		},
		ag = (ug.prototype.evaluate = function(t) {
			return G(t) ? this._opFn(t, this._rvalFloat) : this._opFn(Io(t), this._rvalFloat)
		}, ug),
		sg = (lg.prototype.evaluate = function(t, e) {
			var n = G(t) ? t : Io(t),
				i = G(e) ? e : Io(e),
				r = isNaN(n),
				o = isNaN(i);
			return r && (n = this._incomparable), o && (i = this._incomparable), r && o && (r = H(t), o = H(e),
					r && (n = o ? t : 0), o) && (i = r ? e : 0), n < i ? this._resultLT : i < n ? -this
				._resultLT : 0
		}, lg);

	function lg(t, e) {
		t = "desc" === t;
		this._resultLT = t ? 1 : -1, this._incomparable = "min" === (e = null == e ? t ? "min" : "max" : e) ? -1 /
			0 : 1 / 0
	}

	function ug(t, e) {
		G(e) || f(""), this._opFn = og[t], this._rvalFloat = Io(e)
	}
	cg.prototype.evaluate = function(t) {
		var e, n = t === this._rval;
		return n || (e = typeof t) === this._rvalTypeof || "number" != e && "number" !== this._rvalTypeof || (
			n = Io(t) === this._rvalFloat), this._isEQ ? n : !n
	};
	var hg = cg;

	function cg(t, e) {
		this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = Io(e)
	}
	dg.prototype.getRawData = function() {
			throw new Error("not supported")
		}, dg.prototype.getRawDataItem = function(t) {
			throw new Error("not supported")
		}, dg.prototype.cloneRawData = function() {}, dg.prototype.getDimensionInfo = function(t) {}, dg.prototype
		.cloneAllDimensionInfo = function() {}, dg.prototype.count = function() {}, dg.prototype.retrieveValue =
		function(t, e) {}, dg.prototype.retrieveValueFromItem = function(t, e) {}, dg.prototype.convertValue = ng;
	var pg = dg;

	function dg() {}

	function fg(t) {
		return xg(t.sourceFormat) || f(""), t.data
	}

	function gg(t) {
		var e = t.sourceFormat,
			n = t.data;
		if (xg(e) || f(""), e === pd) {
			for (var i = [], r = 0, o = n.length; r < o; r++) i.push(n[r].slice());
			return i
		}
		if (e === dd) {
			for (i = [], r = 0, o = n.length; r < o; r++) i.push(O({}, n[r]));
			return i
		}
	}

	function yg(t, e, n) {
		if (null != n) return G(n) || !isNaN(n) && !Ft(e, n) ? t[n] : Ft(e, n) ? e[n] : void 0
	}

	function mg(t) {
		return _(t)
	}
	var vg = z();

	function _g(t, e) {
		var n = Ro(t),
			t = n.length;
		t || f("");
		for (var i = 0, r = t; i < r; i++) e = function(t, i) {
			i.length || f(""), L(t) || f("");
			var e = t.type,
				d = vg.get(e),
				e = (d || f(""), F(i, function(t) {
					var e = t,
						t = d,
						n = new pg,
						i = e.data,
						r = n.sourceFormat = e.sourceFormat,
						o = e.startIndex,
						a = (e.seriesLayoutBy !== md && f(""), []),
						s = {};
					if (h = e.dimensionsDefine) E(h, function(t, e) {
						var n = t.name,
							e = {
								index: e,
								name: n,
								displayName: t.displayName
							};
						a.push(e), null != n && (Ft(s, n) && f(""), s[n] = e)
					});
					else
						for (var l = 0; l < e.dimensionsDetectedCount; l++) a.push({
							index: l
						});
					var u = Lf(r, md),
						h = (t.__isBuiltIn && (n.getRawDataItem = function(t) {
							return u(i, o, a, t)
						}, n.getRawData = pt(fg, null, e)), n.cloneRawData = pt(gg, null, e), Nf(r,
							md)),
						c = (n.count = pt(h, null, i, o, a), Bf(r)),
						p = (n.retrieveValue = function(t, e) {
							t = u(i, o, a, t);
							return p(t, e)
						}, n.retrieveValueFromItem = function(t, e) {
							var n;
							return null != t && (n = a[e]) ? c(t, e, n.name) : void 0
						});
					return n.getDimensionInfo = pt(yg, null, a, s), n.cloneAllDimensionInfo = pt(mg,
						null, a), n
				}));
			return F(Ro(d.transform({
				upstream: e[0],
				upstreamList: e,
				config: _(t.config)
			})), function(t, e) {
				L(t) || f(""), t.data || f(""), xg(xf(t.data)) || f("");
				var n = i[0],
					e = n && 0 === e && !t.dimensions ? ((e = n.startIndex) && (t.data = n.data.slice(0,
						e).concat(t.data)), {
						seriesLayoutBy: md,
						sourceHeader: e,
						dimensions: n.metaRawOption.dimensions
					}) : {
						seriesLayoutBy: md,
						sourceHeader: 0,
						dimensions: t.dimensions
					};
				return vf(t.data, e, null)
			})
		}(n[i], e), i !== r - 1 && (e.length = Math.max(e.length, 1));
		return e
	}

	function xg(t) {
		return t === pd || t === dd
	}
	var wg, fc = "undefined",
		bg = typeof Uint32Array == fc ? Array : Uint32Array,
		Sg = typeof Uint16Array == fc ? Array : Uint16Array,
		Mg = typeof Int32Array == fc ? Array : Int32Array,
		gp = typeof Float64Array == fc ? Array : Float64Array,
		Tg = {
			float: gp,
			int: Mg,
			ordinal: Array,
			number: Array,
			time: gp
		};

	function Cg(t) {
		return 65535 < t ? bg : Sg
	}

	function Ig() {
		return [1 / 0, -1 / 0]
	}

	function kg(t, e, n, i, r) {
		n = Tg[n || "float"];
		if (r) {
			var o = t[e],
				a = o && o.length;
			if (a !== i) {
				for (var s = new n(i), l = 0; l < a; l++) s[l] = o[l];
				t[e] = s
			}
		} else t[e] = new n(i)
	}
	l.prototype.initData = function(t, e, n) {
		this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
		var i = t.getSource(),
			r = this.defaultDimValueGetter = wg[i.sourceFormat];
		this._dimValueGetter = n || r, this._rawExtent = [], Sf(i), this._dimensions = F(e, function(t) {
			return {
				type: t.type,
				property: t.property
			}
		}), this._initDataFromProvider(0, t.count())
	}, l.prototype.getProvider = function() {
		return this._provider
	}, l.prototype.getSource = function() {
		return this._provider.getSource()
	}, l.prototype.ensureCalculationDimension = function(t, e) {
		var n = this._calcDimNameToIdx,
			i = this._dimensions,
			r = n.get(t);
		if (null != r) {
			if (i[r].type === e) return r
		} else r = i.length;
		return i[r] = {
			type: e
		}, n.set(t, r), this._chunks[r] = new Tg[e || "float"](this._rawCount), this._rawExtent[r] = Ig(), r
	}, l.prototype.collectOrdinalMeta = function(t, e) {
		var n = this._chunks[t],
			i = this._dimensions[t],
			r = this._rawExtent,
			o = i.ordinalOffset || 0,
			a = n.length;
		0 === o && (r[t] = Ig());
		for (var s = r[t], l = o; l < a; l++) {
			var u = n[l] = e.parseAndCollect(n[l]);
			isNaN(u) || (s[0] = Math.min(u, s[0]), s[1] = Math.max(u, s[1]))
		}
		i.ordinalMeta = e, i.ordinalOffset = a, i.type = "ordinal"
	}, l.prototype.getOrdinalMeta = function(t) {
		return this._dimensions[t].ordinalMeta
	}, l.prototype.getDimensionProperty = function(t) {
		t = this._dimensions[t];
		return t && t.property
	}, l.prototype.appendData = function(t) {
		var e = this._provider,
			n = this.count(),
			t = (e.appendData(t), e.count());
		return e.persistent || (t += n), n < t && this._initDataFromProvider(n, t, !0), [n, t]
	}, l.prototype.appendValues = function(t, e) {
		for (var n = this._chunks, i = this._dimensions, r = i.length, o = this._rawExtent, a = this.count(),
				s = a + Math.max(t.length, e || 0), l = 0; l < r; l++) kg(n, l, (d = i[l]).type, s, !0);
		for (var u = [], h = a; h < s; h++)
			for (var c = h - a, p = 0; p < r; p++) {
				var d = i[p],
					f = wg.arrayRows.call(this, t[c] || u, d.property, c, p),
					g = (n[p][h] = f, o[p]);
				f < g[0] && (g[0] = f), f > g[1] && (g[1] = f)
			}
		return {
			start: a,
			end: this._rawCount = this._count = s
		}
	}, l.prototype._initDataFromProvider = function(t, e, n) {
		for (var i = this._provider, r = this._chunks, o = this._dimensions, a = o.length, s = this._rawExtent,
				l = F(o, function(t) {
					return t.property
				}), u = 0; u < a; u++) {
			var h = o[u];
			s[u] || (s[u] = Ig()), kg(r, u, h.type, e, n)
		}
		if (i.fillStorage) i.fillStorage(t, e, r, s);
		else
			for (var c = [], p = t; p < e; p++)
				for (var c = i.getItem(p, c), d = 0; d < a; d++) {
					var f = r[d],
						g = this._dimValueGetter(c, l[d], p, d),
						f = (f[p] = g, s[d]);
					g < f[0] && (f[0] = g), g > f[1] && (f[1] = g)
				}!i.persistent && i.clean && i.clean(), this._rawCount = this._count = e, this._extent = []
	}, l.prototype.count = function() {
		return this._count
	}, l.prototype.get = function(t, e) {
		return 0 <= e && e < this._count && (t = this._chunks[t]) ? t[this.getRawIndex(e)] : NaN
	}, l.prototype.getValues = function(t, e) {
		var n = [],
			i = [];
		if (null == e) {
			e = t, t = [];
			for (var r = 0; r < this._dimensions.length; r++) i.push(r)
		} else i = t;
		for (var r = 0, o = i.length; r < o; r++) n.push(this.get(i[r], e));
		return n
	}, l.prototype.getByRawIndex = function(t, e) {
		return 0 <= e && e < this._rawCount && (t = this._chunks[t]) ? t[e] : NaN
	}, l.prototype.getSum = function(t) {
		var e = 0;
		if (this._chunks[t])
			for (var n = 0, i = this.count(); n < i; n++) {
				var r = this.get(t, n);
				isNaN(r) || (e += r)
			}
		return e
	}, l.prototype.getMedian = function(t) {
		var e = [],
			t = (this.each([t], function(t) {
				isNaN(t) || e.push(t)
			}), e.sort(function(t, e) {
				return t - e
			})),
			n = this.count();
		return 0 === n ? 0 : n % 2 == 1 ? t[(n - 1) / 2] : (t[n / 2] + t[n / 2 - 1]) / 2
	}, l.prototype.indexOfRawIndex = function(t) {
		if (!(t >= this._rawCount || t < 0)) {
			if (!this._indices) return t;
			var e = this._indices,
				n = e[t];
			if (null != n && n < this._count && n === t) return t;
			for (var i = 0, r = this._count - 1; i <= r;) {
				var o = (i + r) / 2 | 0;
				if (e[o] < t) i = 1 + o;
				else {
					if (!(e[o] > t)) return o;
					r = o - 1
				}
			}
		}
		return -1
	}, l.prototype.indicesOfNearest = function(t, e, n) {
		var i = this._chunks[t],
			r = [];
		if (i) {
			null == n && (n = 1 / 0);
			for (var o = 1 / 0, a = -1, s = 0, l = 0, u = this.count(); l < u; l++) {
				var h = e - i[this.getRawIndex(l)],
					c = Math.abs(h);
				c <= n && ((c < o || c === o && 0 <= h && a < 0) && (o = c, a = h, s = 0), h === a) && (r[s++] =
					l)
			}
			r.length = s
		}
		return r
	}, l.prototype.getIndices = function() {
		var t = this._indices;
		if (t) {
			var e = t.constructor,
				n = this._count;
			if (e === Array)
				for (var i = new e(n), r = 0; r < n; r++) i[r] = t[r];
			else i = new e(t.buffer, 0, n)
		} else
			for (i = new(e = Cg(this._rawCount))(this.count()), r = 0; r < i.length; r++) i[r] = r;
		return i
	}, l.prototype.filter = function(t, e) {
		if (!this._count) return this;
		for (var n = this.clone(), i = n.count(), r = new(Cg(n._rawCount))(i), o = [], a = t.length, s = 0, l =
				t[0], u = n._chunks, h = 0; h < i; h++) {
			var c = void 0,
				p = n.getRawIndex(h);
			if (0 === a) c = e(h);
			else if (1 === a) c = e(u[l][p], h);
			else {
				for (var d = 0; d < a; d++) o[d] = u[t[d]][p];
				o[d] = h, c = e.apply(null, o)
			}
			c && (r[s++] = p)
		}
		return s < i && (n._indices = r), n._count = s, n._extent = [], n._updateGetRawIdx(), n
	}, l.prototype.selectRange = function(t) {
		var e = this.clone(),
			n = e._count;
		if (!n) return this;
		var i = R(t),
			r = i.length;
		if (!r) return this;
		var o = e.count(),
			a = new(Cg(e._rawCount))(o),
			s = 0,
			l = i[0],
			u = t[l][0],
			h = t[l][1],
			c = e._chunks,
			l = !1;
		if (!e._indices) {
			var p = 0;
			if (1 === r) {
				for (var d = c[i[0]], f = 0; f < n; f++)((v = d[f]) >= u && v <= h || isNaN(v)) && (a[s++] = p),
					p++;
				l = !0
			} else if (2 === r) {
				for (var d = c[i[0]], g = c[i[1]], y = t[i[1]][0], m = t[i[1]][1], f = 0; f < n; f++) {
					var v = d[f],
						_ = g[f];
					(u <= v && v <= h || isNaN(v)) && (y <= _ && _ <= m || isNaN(_)) && (a[s++] = p), p++
				}
				l = !0
			}
		}
		if (!l)
			if (1 === r)
				for (f = 0; f < o; f++) {
					var x = e.getRawIndex(f);
					((v = c[i[0]][x]) >= u && v <= h || isNaN(v)) && (a[s++] = x)
				} else
					for (f = 0; f < o; f++) {
						for (var w = !0, b = (x = e.getRawIndex(f), 0); b < r; b++) {
							var S = i[b];
							((v = c[S][x]) < t[S][0] || v > t[S][1]) && (w = !1)
						}
						w && (a[s++] = e.getRawIndex(f))
					}
		return s < o && (e._indices = a), e._count = s, e._extent = [], e._updateGetRawIdx(), e
	}, l.prototype.map = function(t, e) {
		var n = this.clone(t);
		return this._updateDims(n, t, e), n
	}, l.prototype.modify = function(t, e) {
		this._updateDims(this, t, e)
	}, l.prototype._updateDims = function(t, e, n) {
		for (var i = t._chunks, r = [], o = e.length, a = t.count(), s = [], l = t._rawExtent, u = 0; u < e
			.length; u++) l[e[u]] = Ig();
		for (var h = 0; h < a; h++) {
			for (var c = t.getRawIndex(h), p = 0; p < o; p++) s[p] = i[e[p]][c];
			s[o] = h;
			var d = n && n.apply(null, s);
			if (null != d)
				for ("object" != typeof d && (r[0] = d, d = r), u = 0; u < d.length; u++) {
					var f = e[u],
						g = d[u],
						y = l[f],
						f = i[f];
					f && (f[c] = g), g < y[0] && (y[0] = g), g > y[1] && (y[1] = g)
				}
		}
	}, l.prototype.lttbDownSample = function(t, e) {
		var n, i = this.clone([t], !0),
			r = i._chunks[t],
			o = this.count(),
			a = 0,
			s = Math.floor(1 / e),
			l = this.getRawIndex(0),
			u = new(Cg(this._rawCount))(Math.min(2 * (Math.ceil(o / s) + 2), o));
		u[a++] = l;
		for (var h = 1; h < o - 1; h += s) {
			for (var c = Math.min(h + s, o - 1), p = Math.min(h + 2 * s, o), d = (p + c) / 2, f = 0, g = c; g <
				p; g++) {
				var y = r[M = this.getRawIndex(g)];
				isNaN(y) || (f += y)
			}
			f /= p - c;
			for (var c = h, m = Math.min(h + s, o), v = h - 1, _ = r[l], x = -1, w = c, b = -1, S = 0, g =
					c; g < m; g++) {
				var M, y = r[M = this.getRawIndex(g)];
				isNaN(y) ? (S++, b < 0 && (b = M)) : (n = Math.abs((v - d) * (y - _) - (v - g) * (f - _))) >
					x && (x = n, w = M)
			}
			0 < S && S < m - c && (u[a++] = Math.min(b, w), w = Math.max(b, w)), l = u[a++] = w
		}
		return u[a++] = this.getRawIndex(o - 1), i._count = a, i._indices = u, i.getRawIndex = this._getRawIdx,
			i
	}, l.prototype.downSample = function(t, e, n, i) {
		for (var r = this.clone([t], !0), o = r._chunks, a = [], s = Math.floor(1 / e), l = o[t], u = this
				.count(), h = r._rawExtent[t] = Ig(), c = new(Cg(this._rawCount))(Math.ceil(u / s)), p = 0, d =
				0; d < u; d += s) {
			u - d < s && (a.length = s = u - d);
			for (var f = 0; f < s; f++) {
				var g = this.getRawIndex(d + f);
				a[f] = l[g]
			}
			var y = n(a),
				m = this.getRawIndex(Math.min(d + i(a, y) || 0, u - 1));
			(l[m] = y) < h[0] && (h[0] = y), y > h[1] && (h[1] = y), c[p++] = m
		}
		return r._count = p, r._indices = c, r._updateGetRawIdx(), r
	}, l.prototype.each = function(t, e) {
		if (this._count)
			for (var n = t.length, i = this._chunks, r = 0, o = this.count(); r < o; r++) {
				var a = this.getRawIndex(r);
				switch (n) {
					case 0:
						e(r);
						break;
					case 1:
						e(i[t[0]][a], r);
						break;
					case 2:
						e(i[t[0]][a], i[t[1]][a], r);
						break;
					default:
						for (var s = 0, l = []; s < n; s++) l[s] = i[t[s]][a];
						l[s] = r, e.apply(null, l)
				}
			}
	}, l.prototype.getDataExtent = function(t) {
		var e = this._chunks[t],
			n = Ig();
		if (!e) return n;
		var i, r = this.count();
		if (!this._indices) return this._rawExtent[t].slice();
		if (i = this._extent[t]) return i.slice();
		for (var o = (i = n)[0], a = i[1], s = 0; s < r; s++) {
			var l = e[this.getRawIndex(s)];
			l < o && (o = l), a < l && (a = l)
		}
		return this._extent[t] = i = [o, a]
	}, l.prototype.getRawDataItem = function(t) {
		var e = this.getRawIndex(t);
		if (this._provider.persistent) return this._provider.getItem(e);
		for (var n = [], i = this._chunks, r = 0; r < i.length; r++) n.push(i[r][e]);
		return n
	}, l.prototype.clone = function(t, e) {
		var n, i, r = new l,
			o = this._chunks,
			a = t && ht(t, function(t, e) {
				return t[e] = !0, t
			}, {});
		if (a)
			for (var s = 0; s < o.length; s++) r._chunks[s] = a[s] ? (n = o[s], i = void 0, (i = n
				.constructor) === Array ? n.slice() : new i(n)) : o[s];
		else r._chunks = o;
		return this._copyCommonProps(r), e || (r._indices = this._cloneIndices()), r._updateGetRawIdx(), r
	}, l.prototype._copyCommonProps = function(t) {
		t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this
			._dimensions, t._extent = _(this._extent), t._rawExtent = _(this._rawExtent)
	}, l.prototype._cloneIndices = function() {
		if (this._indices) {
			var t = this._indices.constructor,
				e = void 0;
			if (t === Array)
				for (var n = this._indices.length, e = new t(n), i = 0; i < n; i++) e[i] = this._indices[i];
			else e = new t(this._indices);
			return e
		}
		return null
	}, l.prototype._getRawIdxIdentity = function(t) {
		return t
	}, l.prototype._getRawIdx = function(t) {
		return t < this._count && 0 <= t ? this._indices[t] : -1
	}, l.prototype._updateGetRawIdx = function() {
		this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity
	}, l.internalField = void(wg = {
		arrayRows: Ag,
		objectRows: function(t, e, n, i) {
			return ng(t[e], this._dimensions[i])
		},
		keyedColumns: Ag,
		original: function(t, e, n, i) {
			t = t && (null == t.value ? t : t.value);
			return ng(t instanceof Array ? t[i] : t, this._dimensions[i])
		},
		typedArray: function(t, e, n, i) {
			return t[i]
		}
	});
	var Dg = l;

	function l() {
		this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this
			._calcDimNameToIdx = z()
	}

	function Ag(t, e, n, i) {
		return ng(t[i], this._dimensions[i])
	}
	Lg.prototype.dirty = function() {
		this._setLocalSource([], []), this._storeList = [], this._dirty = !0
	}, Lg.prototype._setLocalSource = function(t, e) {
		this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, 9e10 < this
			._versionSignBase && (this._versionSignBase = 0)
	}, Lg.prototype._getVersionSign = function() {
		return this._sourceHost.uid + "_" + this._versionSignBase
	}, Lg.prototype.prepareSource = function() {
		this._isDirty() && (this._createSource(), this._dirty = !1)
	}, Lg.prototype._createSource = function() {
		this._setLocalSource([], []);
		var t, e, n, i, r, o, a, s = this._sourceHost,
			l = this._getUpstreamSourceManagers(),
			u = !!l.length;
		Rg(s) ? (i = s, r = t = o = void 0, e = u ? ((e = l[0]).prepareSource(), o = (r = e.getSource()).data,
				t = r.sourceFormat, [e._getVersionSign()]) : (t = yt(o = i.get("data", !0)) ? gd : cd, []),
			i = this._getSourceMetaRawOption() || {}, r = r && r.metaRawOption || {}, a = N(i
				.seriesLayoutBy, r.seriesLayoutBy) || null, n = N(i.sourceHeader, r.sourceHeader), i = N(i
				.dimensions, r.dimensions), r = a !== r.seriesLayoutBy || !!n != !!r.sourceHeader || i ? [
				vf(o, {
					seriesLayoutBy: a,
					sourceHeader: n,
					dimensions: i
				}, t)
			] : []) : (o = s, e = u ? (r = (a = this._applyTransform(l)).sourceList, a.upstreamSignList) : (
			r = [vf(o.get("source", !0), this._getSourceMetaRawOption(), null)], [])), this._setLocalSource(
			r, e)
	}, Lg.prototype._applyTransform = function(t) {
		var e, n = this._sourceHost,
			i = n.get("transform", !0),
			r = n.get("fromTransformResult", !0),
			o = (null != r && 1 !== t.length && Ng(""), []),
			a = [];
		return E(t, function(t) {
			t.prepareSource();
			var e = t.getSource(r || 0);
			null == r || e || Ng(""), o.push(e), a.push(t._getVersionSign())
		}), i ? e = _g(i, o, n.componentIndex) : null != r && (e = [new yf({
			data: (t = o[0]).data,
			sourceFormat: t.sourceFormat,
			seriesLayoutBy: t.seriesLayoutBy,
			dimensionsDefine: _(t.dimensionsDefine),
			startIndex: t.startIndex,
			dimensionsDetectedCount: t.dimensionsDetectedCount
		})]), {
			sourceList: e,
			upstreamSignList: a
		}
	}, Lg.prototype._isDirty = function() {
		if (this._dirty) return !0;
		for (var t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) {
			var n = t[e];
			if (n._isDirty() || this._upstreamSignList[e] !== n._getVersionSign()) return !0
		}
	}, Lg.prototype.getSource = function(t) {
		var e = this._sourceList[t = t || 0];
		return e || (e = this._getUpstreamSourceManagers())[0] && e[0].getSource(t)
	}, Lg.prototype.getSharedDataStore = function(t) {
		var e = t.makeStoreSchema();
		return this._innerGetDataStore(e.dimensions, t.source, e.hash)
	}, Lg.prototype._innerGetDataStore = function(t, e, n) {
		var i, r = this._storeList,
			o = r[0],
			r = (o = o || (r[0] = {}))[n];
		return r || (i = this._getUpstreamSourceManagers()[0], Rg(this._sourceHost) && i ? r = i
			._innerGetDataStore(t, e, n) : (r = new Dg).initData(new If(e, t.length), t), o[n] = r), r
	}, Lg.prototype._getUpstreamSourceManagers = function() {
		var t, e = this._sourceHost;
		return Rg(e) ? (t = Sd(e)) ? [t.getSourceManager()] : [] : F((t = e).get("transform", !0) || t.get(
			"fromTransformResult", !0) ? $o(t.ecModel, "dataset", {
			index: t.get("fromDatasetIndex", !0),
			id: t.get("fromDatasetId", !0)
		}, Ko).models : [], function(t) {
			return t.getSourceManager()
		})
	}, Lg.prototype._getSourceMetaRawOption = function() {
		var t, e, n, i = this._sourceHost;
		return Rg(i) ? (t = i.get("seriesLayoutBy", !0), e = i.get("sourceHeader", !0), n = i.get("dimensions",
			!0)) : this._getUpstreamSourceManagers().length || (t = (i = i).get("seriesLayoutBy", !0), e = i
			.get("sourceHeader", !0), n = i.get("dimensions", !0)), {
			seriesLayoutBy: t,
			sourceHeader: e,
			dimensions: n
		}
	};
	var Pg = Lg;

	function Lg(t) {
		this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this
			._dirty = !0, this._sourceHost = t
	}

	function Og(t) {
		t.option.transform && Dt(t.option.transform)
	}

	function Rg(t) {
		return "series" === t.mainType
	}

	function Ng(t) {
		throw new Error(t)
	}
	var Eg = "line-height:1";

	function zg(t, e) {
		var n = t.color || "#6e7079",
			i = t.fontSize || 12,
			r = t.fontWeight || "400",
			o = t.color || "#464646",
			a = t.fontSize || 14,
			t = t.fontWeight || "900";
		return "html" === e ? {
			nameStyle: "font-size:" + xe(i + "") + "px;color:" + xe(n) + ";font-weight:" + xe(r + ""),
			valueStyle: "font-size:" + xe(a + "") + "px;color:" + xe(o) + ";font-weight:" + xe(t + "")
		} : {
			nameStyle: {
				fontSize: i,
				fill: n,
				fontWeight: r
			},
			valueStyle: {
				fontSize: a,
				fill: o,
				fontWeight: t
			}
		}
	}
	var Bg = [0, 10, 20, 30],
		Fg = ["", "\n", "\n\n", "\n\n\n"];

	function Vg(t, e) {
		return e.type = t, e
	}

	function Hg(t) {
		return "section" === t.type
	}

	function Gg(t) {
		return Hg(t) ? Wg : Ug
	}

	function Wg(i, r, t, o) {
		var n, e = r.noHeader,
			a = (l = function n(t) {
				var i, e, r;
				return Hg(t) ? (i = 0, e = t.blocks.length, r = 1 < e || 0 < e && !t.noHeader, E(t.blocks,
					function(t) {
						var e = n(t);
						i <= e && (i = e + +(r && (!e || Hg(t) && !t.noHeader)))
					}), i) : 0
			}(r), {
				html: Bg[l],
				richText: Fg[l]
			}),
			s = [],
			l = r.blocks || [],
			u = (Ct(!l || V(l)), l = l || [], i.orderMode),
			h = (r.sortBlocks && u && (l = l.slice(), Ft(h = {
				valueAsc: "asc",
				valueDesc: "desc"
			}, u) ? (n = new sg(h[u], null), l.sort(function(t, e) {
				return n.evaluate(t.sortParam, e.sortParam)
			})) : "seriesDesc" === u && l.reverse()), E(l, function(t, e) {
				var n = r.valueFormatter,
					n = Gg(t)(n ? O(O({}, i), {
						valueFormatter: n
					}) : i, t, 0 < e ? a.html : 0, o);
				null != n && s.push(n)
			}), "richText" === i.renderMode ? s.join(a.richText) : Yg(s.join(""), e ? t : a.html));
		return e ? h : (u = Vp(r.header, "ordinal", i.useUTC), l = zg(o, i.renderMode).nameStyle, "richText" === i
			.renderMode ? qg(i, u, l) + a.richText + h : Yg('<div style="' + l + ";" + Eg + ';">' + xe(u) +
				"</div>" + h, t))
	}

	function Ug(t, e, n, i) {
		var r, o, a, s, l = t.renderMode,
			u = e.noName,
			h = e.noValue,
			c = !e.markerType,
			p = e.name,
			d = t.useUTC,
			f = e.valueFormatter || t.valueFormatter || function(t) {
				return F(t = V(t) ? t : [t], function(t, e) {
					return Vp(t, V(o) ? o[e] : o, d)
				})
			};
		if (!u || !h) return r = c ? "" : t.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor ||
				"#333", l), p = u ? "" : Vp(p, "ordinal", d), o = e.valueType, f = h ? [] : f(e.value), e = !
			c || !u, a = !c && u, i = zg(i, l), s = i.nameStyle, i = i.valueStyle, "richText" === l ? (c ? "" :
				r) + (u ? "" : qg(t, p, s)) + (h ? "" : function(t, e, n, i, r) {
				r = [r], i = i ? 10 : 20;
				return n && r.push({
					padding: [0, 0, 0, i],
					align: "right"
				}), t.markupStyleCreator.wrapRichTextStyle(V(e) ? e.join("  ") : e, r)
			}(t, f, e, a, i)) : Yg((c ? "" : r) + (u ? "" : '<span style="' + s + ";" + (!c ?
				"margin-left:2px" : "") + '">' + xe(p) + "</span>") + (h ? "" : function(t, e, n, i) {
				e = e ? "float:right;margin-left:" + (n ? "10px" : "20px") : "";
				return t = V(t) ? t : [t], '<span style="' + e + ";" + i + '">' + F(t, xe).join(
					"&nbsp;&nbsp;") + "</span>"
			}(f, e, a, i)), n)
	}

	function Xg(t, e, n, i, r, o) {
		if (t) return Gg(t)({
			useUTC: r,
			renderMode: n,
			orderMode: i,
			markupStyleCreator: e,
			valueFormatter: t.valueFormatter
		}, t, 0, o)
	}

	function Yg(t, e) {
		return '<div style="margin: ' + e + "px 0 0;" + Eg + ';">' + t + '<div style="clear:both"></div></div>'
	}

	function qg(t, e, n) {
		return t.markupStyleCreator.wrapRichTextStyle(e, n)
	}

	function jg(t, e) {
		t = t.get("padding");
		return null != t ? t : "richText" === e ? [8, 10] : 10
	}
	Kg.prototype._generateStyleName = function() {
		return "__EC_aUTo_" + this._nextStyleNameId++
	}, Kg.prototype.makeTooltipMarker = function(t, e, n) {
		var i = "richText" === n ? this._generateStyleName() : null,
			e = Up({
				color: e,
				type: t,
				renderMode: n,
				markerId: i
			});
		return H(e) ? e : (this.richTextStyles[i] = e.style, e.content)
	}, Kg.prototype.wrapRichTextStyle = function(t, e) {
		var n = {},
			e = (V(e) ? E(e, function(t) {
				return O(n, t)
			}) : O(n, e), this._generateStyleName());
		return this.richTextStyles[e] = n, "{" + e + "|" + t + "}"
	};
	var Zg = Kg;

	function Kg() {
		this.richTextStyles = {}, this._nextStyleNameId = Do()
	}

	function $g(t) {
		var e, n, i, r, o, a, s, l, u, h, c, p = t.series,
			d = t.dataIndex,
			t = t.multipleSeries,
			f = p.getData(),
			g = f.mapDimensionsAll("defaultedTooltip"),
			y = g.length,
			m = p.getRawValue(d),
			v = V(m),
			_ = (_ = d, Xp((w = p).getData().getItemVisual(_, "style")[w.visualDrawType]));

		function x(t, e) {
			e = s.getDimensionInfo(e);
			e && !1 !== e.otherDims.tooltip && (l ? c.push(Vg("nameValue", {
				markerType: "subItem",
				markerColor: a,
				name: e.displayName,
				value: t,
				valueType: e.type
			})) : (u.push(t), h.push(e.type)))
		}
		1 < y || v && !y ? (w = m, r = d, o = g, a = _, s = p.getData(), l = ht(w, function(t, e, n) {
			n = s.getDimensionInfo(n);
			return t || n && !1 !== n.tooltip && null != n.displayName
		}, !1), u = [], h = [], c = [], o.length ? E(o, function(t) {
			x(Vf(s, r, t), t)
		}) : E(w, x), e = (o = {
			inlineValues: u,
			inlineValueTypes: h,
			blocks: c
		}).inlineValueTypes, n = o.blocks, i = (o = o.inlineValues)[0]) : y ? (w = f.getDimensionInfo(g[0]), i =
			o = Vf(f, d, g[0]), e = w.type) : i = o = v ? m[0] : m;
		var y = Go(p),
			g = y && p.name || "",
			w = f.getName(d),
			v = t ? g : w;
		return Vg("section", {
			header: g,
			noHeader: t || !y,
			sortParam: i,
			blocks: [Vg("nameValue", {
				markerType: "item",
				markerColor: _,
				name: v,
				noName: !It(v),
				value: o,
				valueType: e
			})].concat(n || [])
		})
	}
	var Qg = Yo();

	function Jg(t, e) {
		return t.getName(e) || t.getId(e)
	}
	u(h, ty = g), h.prototype.init = function(t, e, n) {
		this.seriesIndex = this.componentIndex, this.dataTask = Uf({
			count: iy,
			reset: ry
		}), this.dataTask.context = {
			model: this
		}, this.mergeDefaultAndTheme(t, n), (Qg(this).sourceManager = new Pg(this)).prepareSource();
		t = this.getInitialData(t, n);
		ay(t, this), this.dataTask.context.data = t, Qg(this).dataBeforeProcessed = t, ny(this), this
			._initSelectedMapFromData(t)
	}, h.prototype.mergeDefaultAndTheme = function(t, e) {
		var n = Jp(this),
			i = n ? ed(t) : {},
			r = this.subType;
		g.hasClass(r), d(t, e.getTheme().get(this.subType)), d(t, this.getDefaultOption()), No(t, "label", [
			"show"
		]), this.fillDataTextStyle(t.data), n && td(t, i, n)
	}, h.prototype.mergeOption = function(t, e) {
		t = d(this.option, t, !0), this.fillDataTextStyle(t.data);
		var n = Jp(this),
			n = (n && td(this.option, t, n), Qg(this).sourceManager),
			n = (n.dirty(), n.prepareSource(), this.getInitialData(t, e));
		ay(n, this), this.dataTask.dirty(), this.dataTask.context.data = n, Qg(this).dataBeforeProcessed = n,
			ny(this), this._initSelectedMapFromData(n)
	}, h.prototype.fillDataTextStyle = function(t) {
		if (t && !yt(t))
			for (var e = ["show"], n = 0; n < t.length; n++) t[n] && t[n].label && No(t[n], "label", e)
	}, h.prototype.getInitialData = function(t, e) {}, h.prototype.appendData = function(t) {
		this.getRawData().appendData(t.data)
	}, h.prototype.getData = function(t) {
		var e = ly(this);
		return e ? (e = e.context.data, null == t ? e : e.getLinkedData(t)) : Qg(this).data
	}, h.prototype.getAllData = function() {
		var t = this.getData();
		return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{
			data: t
		}]
	}, h.prototype.setData = function(t) {
		var e, n = ly(this);
		n && ((e = n.context).outputData = t, n !== this.dataTask) && (e.data = t), Qg(this).data = t
	}, h.prototype.getEncode = function() {
		var t = this.get("encode", !0);
		if (t) return z(t)
	}, h.prototype.getSourceManager = function() {
		return Qg(this).sourceManager
	}, h.prototype.getSource = function() {
		return this.getSourceManager().getSource()
	}, h.prototype.getRawData = function() {
		return Qg(this).dataBeforeProcessed
	}, h.prototype.getColorBy = function() {
		return this.get("colorBy") || "series"
	}, h.prototype.isColorBySeries = function() {
		return "series" === this.getColorBy()
	}, h.prototype.getBaseAxis = function() {
		var t = this.coordinateSystem;
		return t && t.getBaseAxis && t.getBaseAxis()
	}, h.prototype.formatTooltip = function(t, e, n) {
		return $g({
			series: this,
			dataIndex: t,
			multipleSeries: e
		})
	}, h.prototype.isAnimationEnabled = function() {
		var t = this.ecModel;
		return !!(!b.node || t && t.ssr) && !!(t = (t = this.getShallow("animation")) && this.getData()
			.count() > this.getShallow("animationThreshold") ? !1 : t)
	}, h.prototype.restoreData = function() {
		this.dataTask.dirty()
	}, h.prototype.getColorFromPalette = function(t, e, n) {
		var i = this.ecModel;
		return kd.prototype.getColorFromPalette.call(this, t, e, n) || i.getColorFromPalette(t, e, n)
	}, h.prototype.coordDimToDataDim = function(t) {
		return this.getRawData().mapDimensionsAll(t)
	}, h.prototype.getProgressive = function() {
		return this.get("progressive")
	}, h.prototype.getProgressiveThreshold = function() {
		return this.get("progressiveThreshold")
	}, h.prototype.select = function(t, e) {
		this._innerSelect(this.getData(e), t)
	}, h.prototype.unselect = function(t, e) {
		var n = this.option.selectedMap;
		if (n) {
			var i = this.option.selectedMode,
				r = this.getData(e);
			if ("series" === i || "all" === n) this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
			else
				for (var o = 0; o < t.length; o++) {
					var a = Jg(r, t[o]);
					n[a] = !1, this._selectedDataIndicesMap[a] = -1
				}
		}
	}, h.prototype.toggleSelect = function(t, e) {
		for (var n = [], i = 0; i < t.length; i++) n[0] = t[i], this.isSelected(t[i], e) ? this.unselect(n, e) :
			this.select(n, e)
	}, h.prototype.getSelectedDataIndices = function() {
		if ("all" === this.option.selectedMap) return [].slice.call(this.getData().getIndices());
		for (var t = this._selectedDataIndicesMap, e = R(t), n = [], i = 0; i < e.length; i++) {
			var r = t[e[i]];
			0 <= r && n.push(r)
		}
		return n
	}, h.prototype.isSelected = function(t, e) {
		var n = this.option.selectedMap;
		return !!n && (e = this.getData(e), "all" === n || n[Jg(e, t)]) && !e.getItemModel(t).get(["select",
			"disabled"
		])
	}, h.prototype.isUniversalTransitionEnabled = function() {
		var t;
		return !!this.__universalTransitionEnabled || !!(t = this.option.universalTransition) && (!0 === t ||
			t && t.enabled)
	}, h.prototype._innerSelect = function(t, e) {
		var n, i = this.option,
			r = i.selectedMode,
			o = e.length;
		if (r && o)
			if ("series" === r) i.selectedMap = "all";
			else if ("multiple" === r) {
			L(i.selectedMap) || (i.selectedMap = {});
			for (var a = i.selectedMap, s = 0; s < o; s++) {
				var l = e[s];
				a[n = Jg(t, l)] = !0, this._selectedDataIndicesMap[n] = t.getRawIndex(l)
			}
		} else "single" !== r && !0 !== r || (n = Jg(t, r = e[o - 1]), i.selectedMap = ((i = {})[n] = !0, i),
			this._selectedDataIndicesMap = ((i = {})[n] = t.getRawIndex(r), i))
	}, h.prototype._initSelectedMapFromData = function(n) {
		var i;
		this.option.selectedMap || (i = [], n.hasItemOption && n.each(function(t) {
			var e = n.getRawDataItem(t);
			e && e.selected && i.push(t)
		}), 0 < i.length && this._innerSelect(n, i))
	}, h.registerClass = function(t) {
		return g.registerClass(t)
	}, h.protoInitialize = ((Xc = h.prototype).type = "series.__base__", Xc.seriesIndex = 0, Xc
		.ignoreStyleOnData = !1, Xc.hasSymbolVisual = !1, Xc.defaultSymbol = "circle", Xc
		.visualStyleAccessPath = "itemStyle", void(Xc.visualDrawType = "fill"));
	var ty, ey = h;

	function h() {
		var t = null !== ty && ty.apply(this, arguments) || this;
		return t._selectedDataIndicesMap = {}, t
	}

	function ny(t) {
		var e, n, i = t.name;
		Go(t) || (t.name = (t = (e = (t = t).getRawData()).mapDimensionsAll("seriesName"), n = [], E(t, function(
			t) {
			t = e.getDimensionInfo(t);
			t.displayName && n.push(t.displayName)
		}), n.join(" ") || i))
	}

	function iy(t) {
		return t.model.getRawData().count()
	}

	function ry(t) {
		t = t.model;
		return t.setData(t.getRawData().cloneShallow()), oy
	}

	function oy(t, e) {
		e.outputData && t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData)
	}

	function ay(e, n) {
		E(Et(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(t) {
			e.wrapMethod(t, dt(sy, n))
		})
	}

	function sy(t, e) {
		t = ly(t);
		return t && t.setOutputEnd((e || this).count()), e
	}

	function ly(t) {
		var e, n = (t.ecModel || {}).scheduler,
			n = n && n.getPipeline(t.uid);
		if (n) return (n = n.currentTask) && (e = n.agentStubMap) ? e.get(t.uid) : n
	}
	lt(ey, Zc), lt(ey, kd), oa(ey, g);
	hy.prototype.init = function(t, e) {}, hy.prototype.render = function(t, e, n, i) {}, hy.prototype.dispose =
		function(t, e) {}, hy.prototype.updateView = function(t, e, n, i) {}, hy.prototype.updateLayout = function(
			t, e, n, i) {}, hy.prototype.updateVisual = function(t, e, n, i) {}, hy.prototype.toggleBlurSeries =
		function(t, e, n) {}, hy.prototype.eachRendered = function(t) {
			var e = this.group;
			e && e.traverse(t)
		};
	var uy = hy;

	function hy() {
		this.group = new no, this.uid = ep("viewComponent")
	}

	function cy() {
		var o = Yo();
		return function(t) {
			var e = o(t),
				t = t.pipelineContext,
				n = !!e.large,
				i = !!e.progressiveRender,
				r = e.large = !(!t || !t.large),
				e = e.progressiveRender = !(!t || !t.progressiveRender);
			return !(n == r && i == e) && "reset"
		}
	}
	ra(uy), ua(uy);
	var py = Yo(),
		dy = cy(),
		fy = (gy.prototype.init = function(t, e) {}, gy.prototype.render = function(t, e, n, i) {}, gy.prototype
			.highlight = function(t, e, n, i) {
				t = t.getData(i && i.dataType);
				t && my(t, i, "emphasis")
			}, gy.prototype.downplay = function(t, e, n, i) {
				t = t.getData(i && i.dataType);
				t && my(t, i, "normal")
			}, gy.prototype.remove = function(t, e) {
				this.group.removeAll()
			}, gy.prototype.dispose = function(t, e) {}, gy.prototype.updateView = function(t, e, n, i) {
				this.render(t, e, n, i)
			}, gy.prototype.updateLayout = function(t, e, n, i) {
				this.render(t, e, n, i)
			}, gy.prototype.updateVisual = function(t, e, n, i) {
				this.render(t, e, n, i)
			}, gy.prototype.eachRendered = function(t) {
				Tc(this.group, t)
			}, gy.markUpdateMethod = function(t, e) {
				py(t).updateMethod = e
			}, gy.protoInitialize = void(gy.prototype.type = "chart"), gy);

	function gy() {
		this.group = new no, this.uid = ep("viewChart"), this.renderTask = Uf({
			plan: vy,
			reset: _y
		}), this.renderTask.context = {
			view: this
		}
	}

	function yy(t, e, n) {
		t && ou(t) && ("emphasis" === e ? Gl : Wl)(t, n)
	}

	function my(e, t, n) {
		var i, r = Xo(e, t),
			o = t && null != t.highlightKey ? (t = t.highlightKey, i = null == (i = cl[t]) && hl <= 32 ? cl[t] =
				hl++ : i) : null;
		null != r ? E(Ro(r), function(t) {
			yy(e.getItemGraphicEl(t), n, o)
		}) : e.eachItemGraphicEl(function(t) {
			yy(t, n, o)
		})
	}

	function vy(t) {
		return dy(t.model)
	}

	function _y(t) {
		var e = t.model,
			n = t.ecModel,
			i = t.api,
			r = t.payload,
			o = e.pipelineContext.progressiveRender,
			t = t.view,
			a = r && py(r).updateMethod,
			o = o ? "incrementalPrepareRender" : a && t[a] ? a : "render";
		return "render" !== o && t[o](e, n, i, r), xy[o]
	}
	ra(fy), ua(fy);
	var xy = {
			incrementalPrepareRender: {
				progress: function(t, e) {
					e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload)
				}
			},
			render: {
				forceFirstProgress: !0,
				progress: function(t, e) {
					e.view.render(e.model, e.ecModel, e.api, e.payload)
				}
			}
		},
		wy = "\0__throttleOriginMethod",
		by = "\0__throttleRate",
		Sy = "\0__throttleType";

	function My(t, r, o) {
		var a, s, l, u, h, c = 0,
			p = 0,
			d = null;

		function f() {
			p = (new Date).getTime(), d = null, t.apply(l, u || [])
		}
		r = r || 0;

		function e() {
			for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
			a = (new Date).getTime(), l = this, u = t;
			var n = h || r,
				i = h || o;
			h = null, s = a - (i ? c : p) - n, clearTimeout(d), i ? d = setTimeout(f, n) : 0 <= s ? f() : d =
				setTimeout(f, -s), c = a
		}
		return e.clear = function() {
			d && (clearTimeout(d), d = null)
		}, e.debounceNextCall = function(t) {
			h = t
		}, e
	}

	function Ty(t, e, n, i) {
		var r = t[e];
		if (r) {
			var o = r[wy] || r,
				a = r[Sy];
			if (r[by] !== n || a !== i) {
				if (null == n || !i) return t[e] = o;
				(r = t[e] = My(o, n, "debounce" === i))[wy] = o, r[Sy] = i, r[by] = n
			}
		}
	}

	function Cy(t, e) {
		var n = t[e];
		n && n[wy] && (n.clear && n.clear(), t[e] = n[wy])
	}
	var Iy = Yo(),
		ky = {
			itemStyle: ha(qc, !0),
			lineStyle: ha(Wc, !0)
		},
		Dy = {
			lineStyle: "stroke",
			itemStyle: "fill"
		};

	function Ay(t, e) {
		return t.visualStyleMapper || ky[e] || (console.warn("Unknown style type '" + e + "'."), ky.itemStyle)
	}

	function Py(t, e) {
		return t.visualDrawType || Dy[e] || (console.warn("Unknown style type '" + e + "'."), "fill")
	}
	var pa = {
			createOnAllSeries: !0,
			performRawSeries: !0,
			reset: function(r, t) {
				var e = r.getData(),
					n = r.visualStyleAccessPath || "itemStyle",
					i = r.getModel(n),
					o = Ay(r, n)(i),
					i = i.getShallow("decal"),
					a = (i && (e.setVisual("decal", i), i.dirty = !0), Py(r, n)),
					i = o[a],
					s = S(i) ? i : null,
					n = "auto" === o.fill || "auto" === o.stroke;
				if (o[a] && !s && !n || (i = r.getColorFromPalette(r.name, null, t.getSeriesCount()), o[a] || (
						o[a] = i, e.setVisual("colorFromPalette", !0)), o.fill = "auto" === o.fill || S(o
						.fill) ? i : o.fill, o.stroke = "auto" === o.stroke || S(o.stroke) ? i : o.stroke), e
					.setVisual("style", o), e.setVisual("drawType", a), !t.isSeriesFiltered(r) && s) return e
					.setVisual("colorFromPalette", !1), {
						dataEach: function(t, e) {
							var n = r.getDataParams(e),
								i = O({}, o);
							i[a] = s(n), t.setItemVisual(e, "style", i)
						}
					}
			}
		},
		Ly = new Qc,
		fc = {
			createOnAllSeries: !0,
			performRawSeries: !0,
			reset: function(t, e) {
				var i, r, o;
				if (!t.ignoreStyleOnData && !e.isSeriesFiltered(t)) return e = t.getData(), i = t
					.visualStyleAccessPath || "itemStyle", r = Ay(t, i), o = e.getVisual("drawType"), {
						dataEach: e.hasItemOption ? function(t, e) {
							var n = t.getRawDataItem(e);
							n && n[i] && (Ly.option = n[i], n = r(Ly), O(t.ensureUniqueItemVisual(e,
									"style"), n), Ly.option.decal && (t.setItemVisual(e, "decal", Ly
									.option.decal), Ly.option.decal.dirty = !0), o in n) && t
								.setItemVisual(e, "colorFromPalette", !1)
						} : null
					}
			}
		},
		gp = {
			performRawSeries: !0,
			overallReset: function(e) {
				var i = z();
				e.eachSeries(function(t) {
					var e, n = t.getColorBy();
					t.isColorBySeries() || (n = t.type + "-" + n, (e = i.get(n)) || i.set(n, e = {}),
						Iy(t).scope = e)
				}), e.eachSeries(function(i) {
					var r, o, a, s, t, l;
					i.isColorBySeries() || e.isSeriesFiltered(i) || (r = i.getRawData(), o = {}, a = i
						.getData(), s = Iy(i).scope, t = i.visualStyleAccessPath || "itemStyle", l =
						Py(i, t), a.each(function(t) {
							var e = a.getRawIndex(t);
							o[e] = t
						}), r.each(function(t) {
							var e, n = o[t];
							a.getItemVisual(n, "colorFromPalette") && (n = a
								.ensureUniqueItemVisual(n, "style"), t = r.getName(t) || t +
								"", e = r.count(), n[l] = i.getColorFromPalette(t, s, e))
						}))
				})
			}
		},
		Oy = Math.PI;
	Ny.prototype.restoreData = function(t, e) {
		t.restoreData(e), this._stageTaskMap.each(function(t) {
			t = t.overallTask;
			t && t.dirty()
		})
	}, Ny.prototype.getPerformArgs = function(t, e) {
		var n, i;
		if (t.__pipeline) return i = (n = this._pipelineMap.get(t.__pipeline.id)).context, {
			step: e = !e && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n
				.blockIndex ? n.step : null,
			modBy: null != (t = i && i.modDataCount) ? Math.ceil(t / e) : null,
			modDataCount: t
		}
	}, Ny.prototype.getPipeline = function(t) {
		return this._pipelineMap.get(t)
	}, Ny.prototype.updateStreamModes = function(t, e) {
		var n = this._pipelineMap.get(t.uid),
			i = t.getData().count(),
			e = n.progressiveEnabled && e.incrementalPrepareRender && i >= n.threshold,
			r = t.get("large") && i >= t.get("largeThreshold"),
			i = "mod" === t.get("progressiveChunkMode") ? i : null;
		t.pipelineContext = n.context = {
			progressiveRender: e,
			modDataCount: i,
			large: r
		}
	}, Ny.prototype.restorePipelines = function(t) {
		var i = this,
			r = i._pipelineMap = z();
		t.eachSeries(function(t) {
			var e = t.getProgressive(),
				n = t.uid;
			r.set(n, {
				id: n,
				head: null,
				tail: null,
				threshold: t.getProgressiveThreshold(),
				progressiveEnabled: e && !(t.preventIncremental && t.preventIncremental()),
				blockIndex: -1,
				step: Math.round(e || 700),
				count: 0
			}), i._pipe(t, t.dataTask)
		})
	}, Ny.prototype.prepareStageTasks = function() {
		var n = this._stageTaskMap,
			i = this.api.getModel(),
			r = this.api;
		E(this._allHandlers, function(t) {
			var e = n.get(t.uid) || n.set(t.uid, {});
			Ct(!(t.reset && t.overallReset), ""), t.reset && this._createSeriesStageTask(t, e, i, r), t
				.overallReset && this._createOverallStageTask(t, e, i, r)
		}, this)
	}, Ny.prototype.prepareView = function(t, e, n, i) {
		var r = t.renderTask,
			o = r.context;
		o.model = e, o.ecModel = n, o.api = i, r.__block = !t.incrementalPrepareRender, this._pipe(e, r)
	}, Ny.prototype.performDataProcessorTasks = function(t, e) {
		this._performStageTasks(this._dataProcessorHandlers, t, e, {
			block: !0
		})
	}, Ny.prototype.performVisualTasks = function(t, e, n) {
		this._performStageTasks(this._visualHandlers, t, e, n)
	}, Ny.prototype._performStageTasks = function(t, s, l, u) {
		u = u || {};
		var h = !1,
			c = this;

		function p(t, e) {
			return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id))
		}
		E(t, function(i, t) {
			var e, n, r, o, a;
			u.visualType && u.visualType !== i.visualType || (e = (n = c._stageTaskMap.get(i.uid))
				.seriesTaskMap, (n = n.overallTask) ? ((o = n.agentStubMap).each(function(t) {
						p(u, t) && (t.dirty(), r = !0)
					}), r && n.dirty(), c.updatePayload(n, l), a = c.getPerformArgs(n, u.block), o
					.each(function(t) {
						t.perform(a)
					}), n.perform(a) && (h = !0)) : e && e.each(function(t, e) {
					p(u, t) && t.dirty();
					var n = c.getPerformArgs(t, u.block);
					n.skip = !i.performRawSeries && s.isSeriesFiltered(t.context.model), c
						.updatePayload(t, l), t.perform(n) && (h = !0)
				}))
		}), this.unfinished = h || this.unfinished
	}, Ny.prototype.performSeriesTasks = function(t) {
		var e;
		t.eachSeries(function(t) {
			e = t.dataTask.perform() || e
		}), this.unfinished = e || this.unfinished
	}, Ny.prototype.plan = function() {
		this._pipelineMap.each(function(t) {
			var e = t.tail;
			do {
				if (e.__block) {
					t.blockIndex = e.__idxInPipeline;
					break
				}
			} while (e = e.getUpstream())
		})
	}, Ny.prototype.updatePayload = function(t, e) {
		"remain" !== e && (t.context.payload = e)
	}, Ny.prototype._createSeriesStageTask = function(n, t, i, r) {
		var o = this,
			a = t.seriesTaskMap,
			s = t.seriesTaskMap = z(),
			t = n.seriesType,
			e = n.getTargetSeries;

		function l(t) {
			var e = t.uid,
				e = s.set(e, a && a.get(e) || Uf({
					plan: Vy,
					reset: Hy,
					count: Uy
				}));
			e.context = {
				model: t,
				ecModel: i,
				api: r,
				useClearVisual: n.isVisual && !n.isLayout,
				plan: n.plan,
				reset: n.reset,
				scheduler: o
			}, o._pipe(t, e)
		}
		n.createOnAllSeries ? i.eachRawSeries(l) : t ? i.eachRawSeriesByType(t, l) : e && e(i, r).each(l)
	}, Ny.prototype._createOverallStageTask = function(t, e, n, i) {
		var r = this,
			o = e.overallTask = e.overallTask || Uf({
				reset: Ey
			}),
			a = (o.context = {
				ecModel: n,
				api: i,
				overallReset: t.overallReset,
				scheduler: r
			}, o.agentStubMap),
			s = o.agentStubMap = z(),
			e = t.seriesType,
			l = t.getTargetSeries,
			u = !0,
			h = !1;

		function c(t) {
			var e = t.uid,
				e = s.set(e, a && a.get(e) || (h = !0, Uf({
					reset: zy,
					onDirty: Fy
				})));
			e.context = {
				model: t,
				overallProgress: u
			}, e.agent = o, e.__block = u, r._pipe(t, e)
		}
		Ct(!t.createOnAllSeries, ""), e ? n.eachRawSeriesByType(e, c) : l ? l(n, i).each(c) : (u = !1, E(n
			.getSeries(), c)), h && o.dirty()
	}, Ny.prototype._pipe = function(t, e) {
		t = t.uid, t = this._pipelineMap.get(t);
		t.head || (t.head = e), t.tail && t.tail.pipe(e), (t.tail = e).__idxInPipeline = t.count++, e
			.__pipeline = t
	}, Ny.wrapStageHandler = function(t, e) {
		return (t = S(t) ? {
			overallReset: t,
			seriesType: function(t) {
				Xy = null;
				try {
					t(Yy, qy)
				} catch (t) {}
				return Xy
			}(t)
		} : t).uid = ep("stageHandler"), e && (t.visualType = e), t
	};
	var Ry = Ny;

	function Ny(t, e, n, i) {
		this._stageTaskMap = z(), this.ecInstance = t, this.api = e, n = this._dataProcessorHandlers = n.slice(),
			i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i)
	}

	function Ey(t) {
		t.overallReset(t.ecModel, t.api, t.payload)
	}

	function zy(t) {
		return t.overallProgress && By
	}

	function By() {
		this.agent.dirty(), this.getDownstream().dirty()
	}

	function Fy() {
		this.agent && this.agent.dirty()
	}

	function Vy(t) {
		return t.plan ? t.plan(t.model, t.ecModel, t.api, t.payload) : null
	}

	function Hy(t) {
		t.useClearVisual && t.data.clearAllVisual();
		t = t.resetDefines = Ro(t.reset(t.model, t.ecModel, t.api, t.payload));
		return 1 < t.length ? F(t, function(t, e) {
			return Wy(e)
		}) : Gy
	}
	var Gy = Wy(0);

	function Wy(o) {
		return function(t, e) {
			var n = e.data,
				i = e.resetDefines[o];
			if (i && i.dataEach)
				for (var r = t.start; r < t.end; r++) i.dataEach(n, r);
			else i && i.progress && i.progress(t, n)
		}
	}

	function Uy(t) {
		return t.data.count()
	}
	var Xy, Yy = {},
		qy = {};

	function jy(t, e) {
		for (var n in e.prototype) t[n] = Vt
	}
	jy(Yy, Nd), jy(qy, Fd), Yy.eachSeriesByType = Yy.eachRawSeriesByType = function(t) {
		Xy = t
	}, Yy.eachComponent = function(t) {
		"series" === t.mainType && t.subType && (Xy = t.subType)
	};

	function Zy() {
		return {
			axisLine: {
				lineStyle: {
					color: Ky
				}
			},
			splitLine: {
				lineStyle: {
					color: "#484753"
				}
			},
			splitArea: {
				areaStyle: {
					color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
				}
			},
			minorSplitLine: {
				lineStyle: {
					color: "#20203B"
				}
			}
		}
	}
	var Xc = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1",
			"#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"
		],
		Zc = {
			color: Xc,
			colorLayer: [
				["#37A2DA", "#ffd85c", "#fd7b5f"],
				["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"],
				["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA",
					"#96BFFF"
				], Xc
			]
		},
		Ky = "#B9B8CE",
		qc = "#100C2A",
		Wc = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"],
		Xc = {
			darkMode: !0,
			color: Wc,
			backgroundColor: qc,
			axisPointer: {
				lineStyle: {
					color: "#817f91"
				},
				crossStyle: {
					color: "#817f91"
				},
				label: {
					color: "#fff"
				}
			},
			legend: {
				textStyle: {
					color: Ky
				}
			},
			textStyle: {
				color: Ky
			},
			title: {
				textStyle: {
					color: "#EEF1FA"
				},
				subtextStyle: {
					color: "#B9B8CE"
				}
			},
			toolbox: {
				iconStyle: {
					borderColor: Ky
				}
			},
			dataZoom: {
				borderColor: "#71708A",
				textStyle: {
					color: Ky
				},
				brushStyle: {
					color: "rgba(135,163,206,0.3)"
				},
				handleStyle: {
					color: "#353450",
					borderColor: "#C5CBE3"
				},
				moveHandleStyle: {
					color: "#B0B6C3",
					opacity: .3
				},
				fillerColor: "rgba(135,163,206,0.2)",
				emphasis: {
					handleStyle: {
						borderColor: "#91B7F2",
						color: "#4D587D"
					},
					moveHandleStyle: {
						color: "#636D9A",
						opacity: .7
					}
				},
				dataBackground: {
					lineStyle: {
						color: "#71708A",
						width: 1
					},
					areaStyle: {
						color: "#71708A"
					}
				},
				selectedDataBackground: {
					lineStyle: {
						color: "#87A3CE"
					},
					areaStyle: {
						color: "#87A3CE"
					}
				}
			},
			visualMap: {
				textStyle: {
					color: Ky
				}
			},
			timeline: {
				lineStyle: {
					color: Ky
				},
				label: {
					color: Ky
				},
				controlStyle: {
					color: Ky,
					borderColor: Ky
				}
			},
			calendar: {
				itemStyle: {
					color: qc
				},
				dayLabel: {
					color: Ky
				},
				monthLabel: {
					color: Ky
				},
				yearLabel: {
					color: Ky
				}
			},
			timeAxis: Zy(),
			logAxis: Zy(),
			valueAxis: Zy(),
			categoryAxis: Zy(),
			line: {
				symbol: "circle"
			},
			graph: {
				color: Wc
			},
			gauge: {
				title: {
					color: Ky
				},
				axisLine: {
					lineStyle: {
						color: [
							[1, "rgba(207,212,219,0.2)"]
						]
					}
				},
				axisLabel: {
					color: Ky
				},
				detail: {
					color: "#EEF1FA"
				}
			},
			candlestick: {
				itemStyle: {
					color: "#f64e56",
					color0: "#54ea92",
					borderColor: "#f64e56",
					borderColor0: "#54ea92"
				}
			}
		},
		$y = (Xc.categoryAxis.splitLine.show = !1, Qy.prototype.normalizeQuery = function(t) {
			var e, a, s, l = {},
				u = {},
				h = {};
			return H(t) ? (e = ia(t), l.mainType = e.main || null, l.subType = e.sub || null) : (a = ["Index",
				"Name", "Id"
			], s = {
				name: 1,
				dataIndex: 1,
				dataType: 1
			}, E(t, function(t, e) {
				for (var n = !1, i = 0; i < a.length; i++) {
					var r = a[i],
						o = e.lastIndexOf(r);
					0 < o && o === e.length - r.length && "data" !== (o = e.slice(0, o)) && (l
						.mainType = o, l[r.toLowerCase()] = t, n = !0)
				}
				s.hasOwnProperty(e) && (u[e] = t, n = !0), n || (h[e] = t)
			})), {
				cptQuery: l,
				dataQuery: u,
				otherQuery: h
			}
		}, Qy.prototype.filter = function(t, e) {
			var n, i, r, o, a, s = this.eventInfo;
			return !s || (n = s.targetEl, i = s.packedEvent, r = s.model, s = s.view, !r) || !s || (o = e
				.cptQuery, a = e.dataQuery, l(o, r, "mainType") && l(o, r, "subType") && l(o, r, "index",
					"componentIndex") && l(o, r, "name") && l(o, r, "id") && l(a, i, "name") && l(a, i,
					"dataIndex") && l(a, i, "dataType") && (!s.filterForExposedEvent || s
					.filterForExposedEvent(t, e.otherQuery, n, i)));

			function l(t, e, n, i) {
				return null == t[n] || e[i || n] === t[n]
			}
		}, Qy.prototype.afterTrigger = function() {
			this.eventInfo = null
		}, Qy);

	function Qy() {}
	var Jy = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"],
		tm = Jy.concat(["symbolKeepAspect"]),
		qc = {
			createOnAllSeries: !0,
			performRawSeries: !0,
			reset: function(a, t) {
				var e = a.getData();
				if (a.legendIcon && e.setVisual("legendIcon", a.legendIcon), a.hasSymbolVisual) {
					for (var s, n = {}, l = {}, i = !1, r = 0; r < Jy.length; r++) {
						var o = Jy[r],
							u = a.get(o);
						S(u) ? (i = !0, l[o] = u) : n[o] = u
					}
					if (n.symbol = n.symbol || a.defaultSymbol, e.setVisual(O({
							legendIcon: a.legendIcon || n.symbol,
							symbolKeepAspect: a.get("symbolKeepAspect")
						}, n)), !t.isSeriesFiltered(a)) return s = R(l), {
						dataEach: i ? function(t, e) {
							for (var n = a.getRawValue(e), i = a.getDataParams(e), r = 0; r < s
								.length; r++) {
								var o = s[r];
								t.setItemVisual(e, o, l[o](n, i))
							}
						} : null
					}
				}
			}
		},
		Wc = {
			createOnAllSeries: !0,
			performRawSeries: !0,
			reset: function(t, e) {
				if (t.hasSymbolVisual && !e.isSeriesFiltered(t)) return {
					dataEach: t.getData().hasItemOption ? function(t, e) {
						for (var n = t.getItemModel(e), i = 0; i < tm.length; i++) {
							var r = tm[i],
								o = n.getShallow(r, !0);
							null != o && t.setItemVisual(e, r, o)
						}
					} : null
				}
			}
		};

	function em(o, t) {
		E([
			[o + "ToggleSelect", "toggleSelect"],
			[o + "Select", "select"],
			[o + "UnSelect", "unselect"]
		], function(r) {
			t(r[0], function(t, e, n) {
				var i;
				t = O({}, t), n.dispatchAction(O(t, {
					type: r[1],
					seriesIndex: (n = t, i = [], e.eachComponent({
						mainType: "series",
						subType: o,
						query: n
					}, function(t) {
						i.push(t.seriesIndex)
					}), i)
				}))
			})
		})
	}

	function nm(t, e, s, n, l) {
		var u = t + e;
		s.isSilent(u) || n.eachComponent({
			mainType: "series",
			subType: "pie"
		}, function(t) {
			for (var e, n, i = t.seriesIndex, r = t.option.selectedMap, o = l.selected, a = 0; a < o
				.length; a++) o[a].seriesIndex === i && (n = Xo(e = t.getData(), l.fromActionPayload), s
				.trigger(u, {
					type: u,
					seriesId: t.id,
					name: V(n) ? e.getName(n[0]) : e.getName(n),
					selected: H(r) ? r : O({}, r)
				}))
		})
	}

	function im(t, e, n) {
		for (var i; t && (!e(t) || (i = t, !n));) t = t.__hostTarget || t.parent;
		return i
	}
	var rm = Math.round(9 * Math.random()),
		om = "function" == typeof Object.defineProperty,
		am = (sm.prototype.get = function(t) {
			return this._guard(t)[this._id]
		}, sm.prototype.set = function(t, e) {
			t = this._guard(t);
			return om ? Object.defineProperty(t, this._id, {
				value: e,
				enumerable: !1,
				configurable: !0
			}) : t[this._id] = e, this
		}, sm.prototype.delete = function(t) {
			return !!this.has(t) && (delete this._guard(t)[this._id], !0)
		}, sm.prototype.has = function(t) {
			return !!this._guard(t)[this._id]
		}, sm.prototype._guard = function(t) {
			if (t !== Object(t)) throw TypeError("Value of WeakMap is not a non-null object.");
			return t
		}, sm);

	function sm() {
		this._id = "__ec_inner_" + rm++
	}
	var lm = Z.extend({
			type: "triangle",
			shape: {
				cx: 0,
				cy: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var n = e.cx,
					i = e.cy,
					r = e.width / 2,
					e = e.height / 2;
				t.moveTo(n, i - e), t.lineTo(n + r, i + e), t.lineTo(n - r, i + e), t.closePath()
			}
		}),
		um = Z.extend({
			type: "diamond",
			shape: {
				cx: 0,
				cy: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var n = e.cx,
					i = e.cy,
					r = e.width / 2,
					e = e.height / 2;
				t.moveTo(n, i - e), t.lineTo(n + r, i), t.lineTo(n, i + e), t.lineTo(n - r, i), t
					.closePath()
			}
		}),
		hm = Z.extend({
			type: "pin",
			shape: {
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var n = e.x,
					i = e.y,
					r = e.width / 5 * 3,
					e = Math.max(r, e.height),
					r = r / 2,
					o = r * r / (e - r),
					e = i - e + r + o,
					a = Math.asin(o / r),
					s = Math.cos(a) * r,
					l = Math.sin(a),
					u = Math.cos(a),
					h = .6 * r,
					c = .7 * r;
				t.moveTo(n - s, e + o), t.arc(n, e, r, Math.PI - a, 2 * Math.PI + a), t.bezierCurveTo(n +
					s - l * h, e + o + u * h, n, i - c, n, i), t.bezierCurveTo(n, i - c, n - s + l * h,
					e + o + u * h, n - s, e + o), t.closePath()
			}
		}),
		cm = Z.extend({
			type: "arrow",
			shape: {
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			buildPath: function(t, e) {
				var n = e.height,
					i = e.width,
					r = e.x,
					e = e.y,
					i = i / 3 * 2;
				t.moveTo(r, e), t.lineTo(r + i, e + n), t.lineTo(r, e + n / 4 * 3), t.lineTo(r - i, e + n),
					t.lineTo(r, e), t.closePath()
			}
		}),
		pm = {
			line: function(t, e, n, i, r) {
				r.x1 = t, r.y1 = e + i / 2, r.x2 = t + n, r.y2 = e + i / 2
			},
			rect: function(t, e, n, i, r) {
				r.x = t, r.y = e, r.width = n, r.height = i
			},
			roundRect: function(t, e, n, i, r) {
				r.x = t, r.y = e, r.width = n, r.height = i, r.r = Math.min(n, i) / 4
			},
			square: function(t, e, n, i, r) {
				n = Math.min(n, i);
				r.x = t, r.y = e, r.width = n, r.height = n
			},
			circle: function(t, e, n, i, r) {
				r.cx = t + n / 2, r.cy = e + i / 2, r.r = Math.min(n, i) / 2
			},
			diamond: function(t, e, n, i, r) {
				r.cx = t + n / 2, r.cy = e + i / 2, r.width = n, r.height = i
			},
			pin: function(t, e, n, i, r) {
				r.x = t + n / 2, r.y = e + i / 2, r.width = n, r.height = i
			},
			arrow: function(t, e, n, i, r) {
				r.x = t + n / 2, r.y = e + i / 2, r.width = n, r.height = i
			},
			triangle: function(t, e, n, i, r) {
				r.cx = t + n / 2, r.cy = e + i / 2, r.width = n, r.height = i
			}
		},
		dm = {},
		fm = (E({
			line: fh,
			rect: Xs,
			roundRect: Xs,
			square: Xs,
			circle: Du,
			diamond: um,
			pin: hm,
			arrow: cm,
			triangle: lm
		}, function(t, e) {
			dm[e] = new t
		}), Z.extend({
			type: "symbol",
			shape: {
				symbolType: "",
				x: 0,
				y: 0,
				width: 0,
				height: 0
			},
			calculateTextPosition: function(t, e, n) {
				var t = Wr(t, e, n),
					i = this.shape;
				return i && "pin" === i.symbolType && "inside" === e.position && (t.y = n.y + .4 * n
					.height), t
			},
			buildPath: function(t, e, n) {
				var i, r = e.symbolType;
				"none" !== r && (i = (i = dm[r]) || dm[r = "rect"], pm[r](e.x, e.y, e.width, e.height, i
					.shape), i.buildPath(t, i.shape, n))
			}
		}));

	function gm(t, e) {
		var n;
		"image" !== this.type && (n = this.style, this.__isEmptyBrush ? (n.stroke = t, n.fill = e || "#fff", n
				.lineWidth = 2) : "line" === this.shape.symbolType ? n.stroke = t : n.fill = t, this
			.markRedraw())
	}

	function ym(t, e, n, i, r, o, a) {
		var s = 0 === t.indexOf("empty");
		return (a = 0 === (t = s ? t.substr(5, 1).toLowerCase() + t.substr(6) : t).indexOf("image://") ? uc(t.slice(
			8), new U(e, n, i, r), a ? "center" : "cover") : 0 === t.indexOf("path://") ? lc(t.slice(7), {},
			new U(e, n, i, r), a ? "center" : "cover") : new fm({
			shape: {
				symbolType: t,
				x: e,
				y: n,
				width: i,
				height: r
			}
		})).__isEmptyBrush = s, a.setColor = gm, o && a.setColor(o), a
	}

	function mm(t, e) {
		if (null != t) return [fo((t = V(t) ? t : [t, t])[0], e[0]) || 0, fo(N(t[1], t[0]), e[1]) || 0]
	}

	function vm(t) {
		return isFinite(t)
	}

	function _m(t, e, n) {
		for (var i, r, o, a, s, l, u, h, c, p = "radial" === e.type ? (i = t, r = e, a = (o = n).width, s = o
				.height, l = Math.min(a, s), u = null == r.x ? .5 : r.x, h = null == r.y ? .5 : r.y, c = null ==
				r.r ? .5 : r.r, r.global || (u = u * a + o.x, h = h * s + o.y, c *= l), u = vm(u) ? u : .5, h =
				vm(h) ? h : .5, c = 0 <= c && vm(c) ? c : .5, i.createRadialGradient(u, h, 0, u, h, c)) : (r =
				t, a = n, o = null == (s = e).x ? 0 : s.x, l = null == s.x2 ? 1 : s.x2, i = null == s.y ? 0 : s
				.y, u = null == s.y2 ? 0 : s.y2, s.global || (o = o * a.width + a.x, l = l * a.width + a.x, i =
					i * a.height + a.y, u = u * a.height + a.y), o = vm(o) ? o : 0, l = vm(l) ? l : 1, i = vm(
					i) ? i : 0, u = vm(u) ? u : 0, r.createLinearGradient(o, i, l, u)), d = e.colorStops, f = 0; f <
			d
			.length; f++) p.addColorStop(d[f].offset, d[f].color);
		return p
	}

	function xm(t) {
		return parseInt(t, 10)
	}

	function wm(t, e, n) {
		var i = ["width", "height"][e],
			r = ["clientWidth", "clientHeight"][e],
			o = ["paddingLeft", "paddingTop"][e],
			e = ["paddingRight", "paddingBottom"][e];
		return null != n[i] && "auto" !== n[i] ? parseFloat(n[i]) : (n = document.defaultView.getComputedStyle(t), (
			t[r] || xm(n[i]) || xm(t.style[i])) - (xm(n[o]) || 0) - (xm(n[e]) || 0) | 0)
	}

	function bm(t) {
		var e, n = t.style,
			i = n.lineDash && 0 < n.lineWidth && (r = n.lineDash, i = n.lineWidth, r && "solid" !== r && 0 < i ?
				"dashed" === r ? [4 * i, 2 * i] : "dotted" === r ? [i] : G(r) ? [r] : V(r) ? r : null : null),
			r = n.lineDashOffset;
		return i && (e = n.strokeNoScale && t.getLineScale ? t.getLineScale() : 1) && 1 !== e && (i = F(i, function(
			t) {
			return t / e
		}), r /= e), [i, r]
	}
	var Sm = new cs(!0);

	function Mm(t) {
		var e = t.stroke;
		return !(null == e || "none" === e || !(0 < t.lineWidth))
	}

	function Tm(t) {
		return "string" == typeof t && "none" !== t
	}

	function Cm(t) {
		t = t.fill;
		return null != t && "none" !== t
	}

	function Im(t, e) {
		var n;
		null != e.fillOpacity && 1 !== e.fillOpacity ? (n = t.globalAlpha, t.globalAlpha = e.fillOpacity * e
			.opacity, t.fill(), t.globalAlpha = n) : t.fill()
	}

	function km(t, e) {
		var n;
		null != e.strokeOpacity && 1 !== e.strokeOpacity ? (n = t.globalAlpha, t.globalAlpha = e.strokeOpacity * e
			.opacity, t.stroke(), t.globalAlpha = n) : t.stroke()
	}

	function Dm(t, e, n) {
		var n = ga(e.image, e.__image, n);
		if (ma(n)) return t = t.createPattern(n, e.repeat || "repeat"), "function" == typeof DOMMatrix && t && t
			.setTransform && ((n = new DOMMatrix).translateSelf(e.x || 0, e.y || 0), n.rotateSelf(0, 0, (e
				.rotation || 0) * Ht), n.scaleSelf(e.scaleX || 1, e.scaleY || 1), t.setTransform(n)), t
	}
	var Am = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"],
		Pm = [
			["lineCap", "butt"],
			["lineJoin", "miter"],
			["miterLimit", 10]
		];

	function Lm(t, e, n, i, r) {
		var o, a = !1;
		if (!i && e === (n = n || {})) return !1;
		!i && e.opacity === n.opacity || (Fm(t, r), a = !0, o = Math.max(Math.min(e.opacity, 1), 0), t.globalAlpha =
			isNaN(o) ? Pa.opacity : o), !i && e.blend === n.blend || (a || (Fm(t, r), a = !0), t
			.globalCompositeOperation = e.blend || Pa.blend);
		for (var s = 0; s < Am.length; s++) {
			var l = Am[s];
			!i && e[l] === n[l] || (a || (Fm(t, r), a = !0), t[l] = t.dpr * (e[l] || 0))
		}
		return !i && e.shadowColor === n.shadowColor || (a || (Fm(t, r), a = !0), t.shadowColor = e.shadowColor ||
			Pa.shadowColor), a
	}

	function Om(t, e, n, i, r) {
		var o = Vm(e, r.inHover),
			a = i ? null : n && Vm(n, r.inHover) || {};
		if (o !== a) {
			var s = Lm(t, o, a, i, r);
			(i || o.fill !== a.fill) && (s || (Fm(t, r), s = !0), Tm(o.fill)) && (t.fillStyle = o.fill), (i || o
				.stroke !== a.stroke) && (s || (Fm(t, r), s = !0), Tm(o.stroke)) && (t.strokeStyle = o.stroke), !i
				&&
				o.opacity === a.opacity || (s || (Fm(t, r), s = !0), t.globalAlpha = null == o.opacity ? 1 : o
					.opacity), e.hasStroke() && (n = o.lineWidth / (o.strokeNoScale && e.getLineScale ? e
					.getLineScale() : 1), t.lineWidth !== n) && (s || (Fm(t, r), s = !0), t.lineWidth = n);
			for (var l = 0; l < Pm.length; l++) {
				var u = Pm[l],
					h = u[0];
				!i && o[h] === a[h] || (s || (Fm(t, r), s = !0), t[h] = o[h] || u[1])
			}
		}
	}

	function Rm(t, e) {
		var e = e.transform,
			n = t.dpr || 1;
		e ? t.setTransform(n * e[0], n * e[1], n * e[2], n * e[3], n * e[4], n * e[5]) : t.setTransform(n, 0, 0, n,
			0, 0)
	}
	var Nm = 1,
		Em = 2,
		zm = 3,
		Bm = 4;

	function Fm(t, e) {
		e.batchFill && t.fill(), e.batchStroke && t.stroke(), e.batchFill = "", e.batchStroke = ""
	}

	function Vm(t, e) {
		return e && t.__hoverStyle || t.style
	}

	function Hm(t, e) {
		Gm(t, e, {
			inHover: !1,
			viewWidth: 0,
			viewHeight: 0
		}, !0)
	}

	function Gm(t, e, n, E) {
		var i = e.transform;
		if (!e.shouldBePainted(n.viewWidth, n.viewHeight, !1, !1)) return e.__dirty &= ~vn, e.__isRendered = !1;
		var r, o, a, s, l, u, h, c, p, d, f, g, y, m, v, _, x, w, b, S, M, T, C, I = e.__clipPaths,
			k = n.prevElClipPaths,
			D = !1,
			A = !1;
		if (!k || function(t, e) {
				if (t !== e && (t || e)) {
					if (!t || !e || t.length !== e.length) return 1;
					for (var n = 0; n < t.length; n++)
						if (t[n] !== e[n]) return 1
				}
			}(I, k)) {
			if (k && k.length && (Fm(t, n), t.restore(), A = D = !0, n.prevElClipPaths = null, n.allClipped = !1, n
					.prevEl = null), I && I.length) {
				Fm(t, n), t.save();
				var z = I,
					B = t;
				k = n;
				for (var F = !1, V = 0; V < z.length; V++) {
					var H = z[V],
						F = F || H.isZeroArea();
					Rm(B, H), B.beginPath(), H.buildPath(B, H.shape), B.clip()
				}
				k.allClipped = F, D = !0
			}
			n.prevElClipPaths = I
		}
		if (n.allClipped) e.__isRendered = !1;
		else {
			e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
			var k = n.prevEl,
				P = (k || (A = D = !0), e instanceof Z && e.autoBatch && (I = e.style, P = Cm(I), C = Mm(I), !(I
					.lineDash || !(+P ^ +C) || P && "string" != typeof I.fill || C && "string" != typeof I
					.stroke || I.strokePercent < 1 || I.strokeOpacity < 1 || I.fillOpacity < 1))),
				D = (D || (C = i, I = k.transform, C && I ? C[0] !== I[0] || C[1] !== I[1] || C[2] !== I[2] || C[
					3] !== I[3] || C[4] !== I[4] || C[5] !== I[5] : C || I) ? (Fm(t, n), Rm(t, e)) : P || Fm(t,
					n), Vm(e, n.inHover));
			if (e instanceof Z) n.lastDrawType !== Nm && (A = !0, n.lastDrawType = Nm), Om(t, e, k, A, n), P && (n
					.batchFill || n.batchStroke) || t.beginPath(), i = t, I = e, O = P, y = Mm(a = D), m = Cm(a),
				v = a.strokePercent, _ = v < 1, x = !I.path, I.silent && !_ || !x || I.createPathProxy(), w = I
				.path || Sm, b = I.__dirty, O || (s = a.fill, T = a.stroke, l = m && !!s.colorStops, u = y && !!T
					.colorStops, h = m && !!s.image, c = y && !!T.image, M = g = f = d = p = void 0, (l || u) && (
						M = I.getBoundingRect()), l && (p = b ? _m(i, s, M) : I.__canvasFillGradient, I
						.__canvasFillGradient = p), u && (d = b ? _m(i, T, M) : I.__canvasStrokeGradient, I
						.__canvasStrokeGradient = d), h && (f = b || !I.__canvasFillPattern ? Dm(i, s, I) : I
						.__canvasFillPattern, I.__canvasFillPattern = f), c && (g = b || !I.__canvasStrokePattern ?
						Dm(i, T, I) : I.__canvasStrokePattern, I.__canvasStrokePattern = f), l ? i.fillStyle = p :
					h && (f ? i.fillStyle = f : m = !1), u ? i.strokeStyle = d : c && (g ? i.strokeStyle = g : y = !
						1)), M = I.getGlobalScale(), w.setScale(M[0], M[1], I.segmentIgnoreThreshold), i
				.setLineDash && a.lineDash && (S = (s = bm(I))[0], L = s[1]), T = !0, (x || b & _n) && (w.setDPR(i
					.dpr), _ ? w.setContext(null) : (w.setContext(i), T = !1), w.reset(), I.buildPath(w, I
					.shape, O), w.toStatic(), I.pathUpdated()), T && w.rebuildPath(i, _ ? v : 1), S && (i
					.setLineDash(S), i.lineDashOffset = L), O || (a.strokeFirst ? (y && km(i, a), m && Im(i, a)) : (
					m && Im(i, a), y && km(i, a))), S && i.setLineDash([]), P && (n.batchFill = D.fill || "", n
					.batchStroke = D.stroke || "");
			else if (e instanceof Ps) n.lastDrawType !== zm && (A = !0, n.lastDrawType = zm), Om(t, e, k, A, n), l =
				t, p = e, null != (f = (h = D).text) && (f += ""), f && (l.font = h.font || K, l.textAlign = h
					.textAlign, l.textBaseline = h.textBaseline, d = u = void 0, l.setLineDash && h.lineDash && (u =
						(p = bm(p))[0], d = p[1]), u && (l.setLineDash(u), l.lineDashOffset = d), h.strokeFirst ? (
						Mm(h) && l.strokeText(f, h.x, h.y), Cm(h) && l.fillText(f, h.x, h.y)) : (Cm(h) && l
						.fillText(f, h.x, h.y), Mm(h) && l.strokeText(f, h.x, h.y)), u) && l.setLineDash([]);
			else if (e instanceof Es) n.lastDrawType !== Em && (A = !0, n.lastDrawType = Em), c = k, g = A, Lm(t,
				Vm(e, (M = n).inHover), c && Vm(c, M.inHover), g, M), s = t, x = D, (I = (b = e).__image = ga(x
				.image, b.__image, b, b.onload)) && ma(I) && (T = x.x || 0, w = x.y || 0, _ = b.getWidth(), b =
				b.getHeight(), v = I.width / I.height, null == _ && null != b ? _ = b * v : null == b && null !=
				_ ? b = _ / v : null == _ && null == b && (_ = I.width, b = I.height), x.sWidth && x.sHeight ? (
					r = x.sx || 0, o = x.sy || 0, s.drawImage(I, r, o, x.sWidth, x.sHeight, T, w, _, b)) : x
				.sx && x.sy ? (v = _ - (r = x.sx), x = b - (o = x.sy), s.drawImage(I, r, o, v, x, T, w, _, b)) :
				s.drawImage(I, T, w, _, b));
			else if (e.getTemporalDisplayables) {
				n.lastDrawType !== Bm && (A = !0, n.lastDrawType = Bm); {
					var G = t;
					var L = e;
					var O = n;
					var W = L.getDisplayables(),
						U = L.getTemporalDisplayables();
					G.save();
					var R, X, Y = {
						prevElClipPaths: null,
						prevEl: null,
						allClipped: !1,
						viewWidth: O.viewWidth,
						viewHeight: O.viewHeight,
						inHover: O.inHover
					};
					for (R = L.getCursor(), X = W.length; R < X; R++)(N = W[R]).beforeBrush && N.beforeBrush(), N
						.innerBeforeBrush(), Gm(G, N, Y, R === X - 1), N.innerAfterBrush(), N.afterBrush && N
						.afterBrush(), Y.prevEl = N;
					for (var N, q = 0, j = U.length; q < j; q++)(N = U[q]).beforeBrush && N.beforeBrush(), N
						.innerBeforeBrush(), Gm(G, N, Y, q === j - 1), N.innerAfterBrush(), N.afterBrush && N
						.afterBrush(), Y.prevEl = N;
					L.clearTemporalDisplayables(), L.notClear = !0, G.restore()
				}
			}
			P && E && Fm(t, n), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), (n.prevEl = e).__dirty = 0, e
				.__isRendered = !0
		}
	}
	var Wm = new am,
		Um = new ei(100),
		Xm = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY",
			"maxTileWidth", "maxTileHeight"
		];

	function Ym(t, e) {
		if ("none" === t) return null;
		var n = e.getDevicePixelRatio(),
			i = e.getZr(),
			r = "svg" === i.painter.type,
			e = (t.dirty && Wm.delete(t), Wm.get(t));
		if (e) return e;
		for (var o, a = B(t, {
				symbol: "rect",
				symbolSize: 1,
				symbolKeepAspect: !0,
				color: "rgba(0, 0, 0, 0.2)",
				backgroundColor: null,
				dashArrayX: 5,
				dashArrayY: 5,
				rotation: 0,
				maxTileWidth: 512,
				maxTileHeight: 512
			}), e = ("none" === a.backgroundColor && (a.backgroundColor = null), {
				repeat: "repeat"
			}), s = e, l = [n], u = !0, h = 0; h < Xm.length; ++h) {
			var c = a[Xm[h]];
			if (null != c && !V(c) && !H(c) && !G(c) && "boolean" != typeof c) {
				u = !1;
				break
			}
			l.push(c)
		}
		u && (o = l.join(",") + (r ? "-svg" : ""), v = Um.get(o)) && (r ? s.svgElement = v : s.image = v);
		var p, d = function t(e) {
				if (!e || 0 === e.length) return [
					[0, 0]
				];
				if (G(e)) return [
					[o = Math.ceil(e), o]
				];
				for (var n = !0, i = 0; i < e.length; ++i)
					if (!G(e[i])) {
						n = !1;
						break
					} if (n) return t([e]);
				var r = [];
				for (i = 0; i < e.length; ++i) {
					var o;
					G(e[i]) ? (o = Math.ceil(e[i]), r.push([o, o])) : (o = F(e[i], function(t) {
						return Math.ceil(t)
					})).length % 2 == 1 ? r.push(o.concat(o)) : r.push(o)
				}
				return r
			}(a.dashArrayX),
			f = function(t) {
				if (!t || "object" == typeof t && 0 === t.length) return [0, 0];
				if (G(t)) return [e = Math.ceil(t), e];
				var e = F(t, function(t) {
					return Math.ceil(t)
				});
				return t.length % 2 ? e.concat(e) : e
			}(a.dashArrayY),
			g = function t(e) {
				if (!e || 0 === e.length) return [
					["rect"]
				];
				if (H(e)) return [
					[e]
				];
				for (var n = !0, i = 0; i < e.length; ++i)
					if (!H(e[i])) {
						n = !1;
						break
					} if (n) return t([e]);
				var r = [];
				for (i = 0; i < e.length; ++i) H(e[i]) ? r.push([e[i]]) : r.push(e[i]);
				return r
			}(a.symbol),
			y = F(d, qm),
			m = qm(f),
			v = !r && X.createCanvas(),
			_ = r && {
				tag: "g",
				attrs: {},
				key: "dcl",
				children: []
			},
			x = function() {
				for (var t = 1, e = 0, n = y.length; e < n; ++e) t = Ao(t, y[e]);
				for (var i = 1, e = 0, n = g.length; e < n; ++e) i = Ao(i, g[e].length);
				t *= i;
				var r = m * y.length * g.length;
				return {
					width: Math.max(1, Math.min(t, a.maxTileWidth)),
					height: Math.max(1, Math.min(r, a.maxTileHeight))
				}
			}();
		v && (v.width = x.width * n, v.height = x.height * n, p = v.getContext("2d")), p && (p.clearRect(0, 0, v
			.width, v.height), a.backgroundColor) && (p.fillStyle = a.backgroundColor, p.fillRect(0, 0, v.width,
			v.height));
		for (var w = 0, b = 0; b < f.length; ++b) w += f[b];
		if (!(w <= 0))
			for (var S, M = -m, T = 0, C = 0, I = 0; M < x.height;) {
				if (T % 2 == 0) {
					for (var k = C / 2 % g.length, D = 0, A = 0, P = 0; D < 2 * x.width;) {
						for (var L, O, R, E, N, z = 0, b = 0; b < d[I].length; ++b) z += d[I][b];
						if (z <= 0) break;
						A % 2 == 0 && (O = .5 * (1 - a.symbolSize), L = D + d[I][A] * O, O = M + f[T] * O, R = d[I][
							A
						] * a.symbolSize, E = f[T] * a.symbolSize, N = P / 2 % g[k].length, L = L, N = g[k][
							N
						], S = void 0, N = ym(N, L * (S = r ? 1 : n), O * S, R * S, E * S, a.color, a
							.symbolKeepAspect), r ? (L = i.painter.renderOneToVNode(N)) && _.children.push(
							L) : Hm(p, N)), D += d[I][A], ++P, ++A === d[I].length && (A = 0)
					}++I === d.length && (I = 0)
				}
				M += f[T], ++C, ++T === f.length && (T = 0)
			}
		return u && Um.put(o, v || _), s.image = v, s.svgElement = _, s.svgWidth = x.width, s.svgHeight = x.height,
			e.rotation = a.rotation, e.scaleX = e.scaleY = r ? 1 : 1 / n, Wm.set(t, e), t.dirty = !1, e
	}

	function qm(t) {
		for (var e = 0, n = 0; n < t.length; ++n) e += t[n];
		return t.length % 2 == 1 ? 2 * e : e
	}
	var jm = new ue,
		Zm = {};
	var um = {
			PROCESSOR: {
				FILTER: 1e3,
				SERIES_FILTER: 800,
				STATISTIC: 5e3
			},
			VISUAL: {
				LAYOUT: 1e3,
				PROGRESSIVE_LAYOUT: 1100,
				GLOBAL: 2e3,
				CHART: 3e3,
				POST_CHART_LAYOUT: 4600,
				COMPONENT: 4e3,
				BRUSH: 5e3,
				CHART_ITEM: 4500,
				ARIA: 6e3,
				DECAL: 7e3
			}
		},
		Km = "__flagInMainProcess",
		$m = "__pendingUpdate",
		Qm = "__needsUpdateStatus",
		Jm = /^[a-zA-Z0-9_]+$/,
		t0 = "__connectUpdateStatus";

	function e0(n) {
		return function() {
			for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
			if (!this.isDisposed()) return i0(this, n, t);
			this.id
		}
	}

	function n0(n) {
		return function() {
			for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
			return i0(this, n, t)
		}
	}

	function i0(t, e, n) {
		return n[0] = n[0] && n[0].toLowerCase(), ue.prototype[e].apply(t, n)
	}
	u(M0, b0 = ue);
	var r0, o0, a0, s0, l0, u0, h0, c0, p0, d0, f0, g0, y0, m0, v0, _0, x0, w0, b0, S0 = M0,
		hm = S0.prototype;

	function M0() {
		return null !== b0 && b0.apply(this, arguments) || this
	}
	hm.on = n0("on"), hm.off = n0("off");
	u(c, T0 = ue), c.prototype._onframe = function() {
		if (!this._disposed) {
			w0(this);
			var t = this._scheduler;
			if (this[$m]) {
				var e = this[$m].silent;
				this[Km] = !0;
				try {
					r0(this), s0.update.call(this, null, this[$m].updateParams)
				} catch (t) {
					throw this[Km] = !1, this[$m] = null, t
				}
				this._zr.flush(), this[Km] = !1, this[$m] = null, c0.call(this, e), p0.call(this, e)
			} else if (t.unfinished) {
				var n = 1,
					i = this._model,
					r = this._api;
				t.unfinished = !1;
				do {
					var o = +new Date
				} while (t.performSeriesTasks(i), t.performDataProcessorTasks(i), u0(this, i), t
					.performVisualTasks(i), m0(this, this._model, r, "remain", {}), 0 < (n -= +new Date - o) &&
					t.unfinished);
				t.unfinished || this._zr.flush()
			}
		}
	}, c.prototype.getDom = function() {
		return this._dom
	}, c.prototype.getId = function() {
		return this.id
	}, c.prototype.getZr = function() {
		return this._zr
	}, c.prototype.isSSR = function() {
		return this._ssr
	}, c.prototype.setOption = function(t, e, n) {
		if (!this[Km])
			if (this._disposed) this.id;
			else {
				L(e) && (n = e.lazyUpdate, i = e.silent, r = e.replaceMerge, o = e.transition, e = e.notMerge),
					this[Km] = !0, this._model && !e || (e = new Xd(this._api), a = this._theme, (s = this
						._model = new Nd).scheduler = this._scheduler, s.ssr = this._ssr, s.init(null, null,
						null, a, this._locale, e)), this._model.setOption(t, {
						replaceMerge: r
					}, E0);
				var i, r, o, a, s = {
					seriesTransition: o,
					optionChanged: !0
				};
				if (n) this[$m] = {
					silent: i,
					updateParams: s
				}, this[Km] = !1, this.getZr().wakeUp();
				else {
					try {
						r0(this), s0.update.call(this, null, s)
					} catch (t) {
						throw this[$m] = null, this[Km] = !1, t
					}
					this._ssr || this._zr.flush(), this[$m] = null, this[Km] = !1, c0.call(this, i), p0.call(
						this, i)
				}
			}
	}, c.prototype.setTheme = function() {}, c.prototype.getModel = function() {
		return this._model
	}, c.prototype.getOption = function() {
		return this._model && this._model.getOption()
	}, c.prototype.getWidth = function() {
		return this._zr.getWidth()
	}, c.prototype.getHeight = function() {
		return this._zr.getHeight()
	}, c.prototype.getDevicePixelRatio = function() {
		return this._zr.painter.dpr || b.hasGlobalWindow && window.devicePixelRatio || 1
	}, c.prototype.getRenderedCanvas = function(t) {
		return this.renderToCanvas(t)
	}, c.prototype.renderToCanvas = function(t) {
		return this._zr.painter.getRenderedCanvas({
			backgroundColor: (t = t || {}).backgroundColor || this._model.get("backgroundColor"),
			pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
		})
	}, c.prototype.renderToSVGString = function(t) {
		return this._zr.painter.renderToString({
			useViewBox: (t = t || {}).useViewBox
		})
	}, c.prototype.getSvgDataURL = function() {
		var t;
		if (b.svgSupported) return E((t = this._zr).storage.getDisplayList(), function(t) {
			t.stopAnimation(null, !0)
		}), t.painter.toDataURL()
	}, c.prototype.getDataURL = function(t) {
		var e, n, i, r;
		if (!this._disposed) return r = (t = t || {}).excludeComponents, e = this._model, n = [], i = this, E(r,
				function(t) {
					e.eachComponent({
						mainType: t
					}, function(t) {
						t = i._componentsMap[t.__viewId];
						t.group.ignore || (n.push(t), t.group.ignore = !0)
					})
				}), r = "svg" === this._zr.painter.getType() ? this.getSvgDataURL() : this.renderToCanvas(t)
			.toDataURL("image/" + (t && t.type || "png")), E(n, function(t) {
				t.group.ignore = !1
			}), r;
		this.id
	}, c.prototype.getConnectedDataURL = function(i) {
		var r, o, a, s, l, u, h, c, p, e, t, n, d, f, g;
		if (!this._disposed) return r = "svg" === i.type, o = this.group, a = Math.min, s = Math.max, H0[o] ? (
				u = l = 1 / 0, c = h = -1 / 0, p = [], e = i && i.pixelRatio || this.getDevicePixelRatio(),
				E(V0, function(t, e) {
					var n;
					t.group === o && (n = r ? t.getZr().painter.getSvgDom().innerHTML : t
						.renderToCanvas(_(i)), t = t.getDom().getBoundingClientRect(), l = a(t.left,
							l), u = a(t.top, u), h = s(t.right, h), c = s(t.bottom, c), p.push({
							dom: n,
							left: t.left,
							top: t.top
						}))
				}), t = (h *= e) - (l *= e), n = (c *= e) - (u *= e), d = X.createCanvas(), (f = lo(d, {
					renderer: r ? "svg" : "canvas"
				})).resize({
					width: t,
					height: n
				}), r ? (g = "", E(p, function(t) {
						var e = t.left - l,
							n = t.top - u;
						g += '<g transform="translate(' + e + "," + n + ')">' + t.dom + "</g>"
					}), f.painter.getSvgRoot().innerHTML = g, i.connectedBackgroundColor && f.painter
					.setBackgroundColor(i.connectedBackgroundColor), f.refreshImmediately(), f.painter
					.toDataURL()) : (i.connectedBackgroundColor && f.add(new Xs({
					shape: {
						x: 0,
						y: 0,
						width: t,
						height: n
					},
					style: {
						fill: i.connectedBackgroundColor
					}
				})), E(p, function(t) {
					t = new Es({
						style: {
							x: t.left * e - l,
							y: t.top * e - u,
							image: t.dom
						}
					});
					f.add(t)
				}), f.refreshImmediately(), d.toDataURL("image/" + (i && i.type || "png")))) : this
			.getDataURL(i);
		this.id
	}, c.prototype.convertToPixel = function(t, e) {
		return l0(this, "convertToPixel", t, e)
	}, c.prototype.convertFromPixel = function(t, e) {
		return l0(this, "convertFromPixel", t, e)
	}, c.prototype.containPixel = function(t, i) {
		var r;
		if (!this._disposed) return E(jo(this._model, t), function(t, n) {
			0 <= n.indexOf("Models") && E(t, function(t) {
				var e = t.coordinateSystem;
				e && e.containPoint ? r = r || !!e.containPoint(i) : "seriesModels" === n &&
					(e = this._chartsMap[t.__viewId]) && e.containPoint && (r = r || e
						.containPoint(i, t))
			}, this)
		}, this), !!r;
		this.id
	}, c.prototype.getVisual = function(t, e) {
		var t = jo(this._model, t, {
				defaultMainType: "series"
			}),
			n = t.seriesModel.getData(),
			t = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? n
			.indexOfRawIndex(t.dataIndex) : null;
		if (null != t) {
			var i = n,
				r = t,
				o = e;
			switch (o) {
				case "color":
					return i.getItemVisual(r, "style")[i.getVisual("drawType")];
				case "opacity":
					return i.getItemVisual(r, "style").opacity;
				case "symbol":
				case "symbolSize":
				case "liftZ":
					return i.getItemVisual(r, o)
			}
		} else {
			var a = n,
				s = e;
			switch (s) {
				case "color":
					return a.getVisual("style")[a.getVisual("drawType")];
				case "opacity":
					return a.getVisual("style").opacity;
				case "symbol":
				case "symbolSize":
				case "liftZ":
					return a.getVisual(s)
			}
		}
	}, c.prototype.getViewOfComponentModel = function(t) {
		return this._componentsMap[t.__viewId]
	}, c.prototype.getViewOfSeriesModel = function(t) {
		return this._chartsMap[t.__viewId]
	}, c.prototype._initEvents = function() {
		var t, n, i, s = this;
		E(L0, function(a) {
			function t(t) {
				var n, e, i, r = s.getModel(),
					o = t.target;
				"globalout" === a ? n = {} : o && im(o, function(t) {
					var e, t = k(t);
					return t && null != t.dataIndex ? (e = t.dataModel || r.getSeriesByIndex(t
						.seriesIndex), n = e && e.getDataParams(t.dataIndex, t.dataType,
						o) || {}, 1) : t.eventData && (n = O({}, t.eventData), 1)
				}, !0), n && (e = n.componentType, i = n.componentIndex, "markLine" !== e &&
					"markPoint" !== e && "markArea" !== e || (e = "series", i = n.seriesIndex), i =
					(e = e && null != i && r.getComponent(e, i)) && s["series" === e.mainType ?
						"_chartsMap" : "_componentsMap"][e.__viewId], n.event = t, n.type = a, s
					._$eventProcessor.eventInfo = {
						targetEl: o,
						packedEvent: n,
						model: e,
						view: i
					}, s.trigger(a, n))
			}
			t.zrEventfulCallAtLast = !0, s._zr.on(a, t, s)
		}), E(R0, function(t, e) {
			s._messageCenter.on(e, function(t) {
				this.trigger(e, t)
			}, s)
		}), E(["selectchanged"], function(e) {
			s._messageCenter.on(e, function(t) {
				this.trigger(e, t)
			}, s)
		}), t = this._messageCenter, i = (n = this)._api, t.on("selectchanged", function(t) {
			var e = i.getModel();
			t.isFromClick ? (nm("map", "selectchanged", n, e, t), nm("pie", "selectchanged", n, e, t)) :
				"select" === t.fromAction ? (nm("map", "selected", n, e, t), nm("pie", "selected", n, e,
					t)) : "unselect" === t.fromAction && (nm("map", "unselected", n, e, t), nm("pie",
					"unselected", n, e, t))
		})
	}, c.prototype.isDisposed = function() {
		return this._disposed
	}, c.prototype.clear = function() {
		this._disposed ? this.id : this.setOption({
			series: []
		}, !0)
	}, c.prototype.dispose = function() {
		var t, e, n;
		this._disposed ? this.id : (this._disposed = !0, this.getDom() && Qo(this.getDom(), U0, ""), e = (t =
				this)._api, n = t._model, E(t._componentsViews, function(t) {
				t.dispose(n, e)
			}), E(t._chartsViews, function(t) {
				t.dispose(n, e)
			}), t._zr.dispose(), t._dom = t._model = t._chartsMap = t._componentsMap = t._chartsViews = t
			._componentsViews = t._scheduler = t._api = t._zr = t._throttledZrFlush = t._theme = t
			._coordSysMgr = t._messageCenter = null, delete V0[t.id])
	}, c.prototype.resize = function(t) {
		if (!this[Km])
			if (this._disposed) this.id;
			else {
				this._zr.resize(t);
				var e = this._model;
				if (this._loadingFX && this._loadingFX.resize(), e) {
					var e = e.resetOption("media"),
						n = t && t.silent;
					this[$m] && (null == n && (n = this[$m].silent), e = !0, this[$m] = null), this[Km] = !0;
					try {
						e && r0(this), s0.update.call(this, {
							type: "resize",
							animation: O({
								duration: 0
							}, t && t.animation)
						})
					} catch (t) {
						throw this[Km] = !1, t
					}
					this[Km] = !1, c0.call(this, n), p0.call(this, n)
				}
			}
	}, c.prototype.showLoading = function(t, e) {
		this._disposed ? this.id : (L(t) && (e = t, t = ""), t = t || "default", this.hideLoading(), F0[t] && (
			t = F0[t](this._api, e), e = this._zr, this._loadingFX = t, e.add(t)))
	}, c.prototype.hideLoading = function() {
		this._disposed ? this.id : (this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null)
	}, c.prototype.makeActionFromEvent = function(t) {
		var e = O({}, t);
		return e.type = R0[t.type], e
	}, c.prototype.dispatchAction = function(t, e) {
		var n;
		this._disposed ? this.id : (L(e) || (e = {
			silent: !!e
		}), O0[t.type] && this._model && (this[Km] ? this._pendingActions.push(t) : (n = e.silent, h0
			.call(this, t, n), (t = e.flush) ? this._zr.flush() : !1 !== t && b.browser.weChat &&
			this._throttledZrFlush(), c0.call(this, n), p0.call(this, n))))
	}, c.prototype.updateLabelLayout = function() {
		jm.trigger("series:layoutlabels", this._model, this._api, {
			updatedSeries: []
		})
	}, c.prototype.appendData = function(t) {
		var e;
		this._disposed ? this.id : (e = t.seriesIndex, this.getModel().getSeriesByIndex(e).appendData(t), this
			._scheduler.unfinished = !0, this.getZr().wakeUp())
	}, c.internalField = (r0 = function(t) {
		var e = t._scheduler;
		e.restorePipelines(t._model), e.prepareStageTasks(), o0(t, !0), o0(t, !1), e.plan()
	}, o0 = function(t, r) {
		for (var o = t._model, a = t._scheduler, s = r ? t._componentsViews : t._chartsViews, l = r ? t
				._componentsMap : t._chartsMap, u = t._zr, h = t._api, e = 0; e < s.length; e++) s[e]
			.__alive = !1;

		function n(t) {
			var e, n = t.__requireNewView,
				i = (t.__requireNewView = !1, "_ec_" + t.id + "_" + t.type),
				n = !n && l[i];
			n || (e = ia(t.type), (n = new(r ? uy.getClass(e.main, e.sub) : fy.getClass(e.sub))).init(o, h),
					l[i] = n, s.push(n), u.add(n.group)), t.__viewId = n.__id = i, n.__alive = !0, n
				.__model = t, n.group.__ecComponentInfo = {
					mainType: t.mainType,
					index: t.componentIndex
				}, r || a.prepareView(n, t, o, h)
		}
		for (r ? o.eachComponent(function(t, e) {
				"series" !== t && n(e)
			}) : o.eachSeries(n), e = 0; e < s.length;) {
			var i = s[e];
			i.__alive ? e++ : (r || i.renderTask.dispose(), u.remove(i.group), i.dispose(o, h), s.splice(e,
				1), l[i.__id] === i && delete l[i.__id], i.__id = i.group.__ecComponentInfo = null)
		}
	}, a0 = function(p, e, d, n, t) {
		var i, f, r = p._model;

		function o(t) {
			t && t.__alive && t[e] && t[e](t.__model, r, p._api, d)
		}
		r.setUpdatePayload(d), n ? ((i = {})[n + "Id"] = d[n + "Id"], i[n + "Index"] = d[n + "Index"], i[n +
			"Name"] = d[n + "Name"], i = {
			mainType: n,
			query: i
		}, t && (i.subType = t), null != (t = d.excludeSeriesId) && (f = z(), E(Ro(t), function(t) {
			t = Ho(t, null);
			null != t && f.set(t, !0)
		})), r && r.eachComponent(i, function(t) {
			if (!f || null == f.get(t.id))
				if (su(d))
					if (t instanceof ey) {
						if (d.type === _l && !d.notBlur && !t.get(["emphasis", "disabled"])) {
							var e = t,
								n = d,
								i = p._api,
								r = e.seriesIndex,
								o = e.getData(n.dataType);
							if (o) {
								var n = (V(n = Xo(o, n)) ? n[0] : n) || 0,
									a = o.getItemGraphicEl(n);
								if (!a)
									for (var s = o.count(), l = 0; !a && l < s;) a = o
										.getItemGraphicEl(l++);
								a ? Zl(r, (n = k(a)).focus, n.blurScope, i) : (n = e.get([
										"emphasis", "focus"
									]), e = e.get(["emphasis", "blurScope"]), null != n &&
									Zl(r, n, e, i))
							}
						}
					} else n = (r = $l(t.mainType, t.componentIndex, d.name, p._api)).focusSelf,
						e = r.dispatchers, d.type === _l && n && !d.notBlur && Kl(t.mainType, t
							.componentIndex, p._api), e && E(e, function(t) {
							(d.type === _l ? Gl : Wl)(t)
						});
			else au(d) && t instanceof ey && (i = t, u = d, p._api, au(u) && (h = u.dataType, V(
					c = Xo(i.getData(h), u)) || (c = [c]), i[u.type === Sl ?
					"toggleSelect" : u.type === wl ? "select" : "unselect"](c, h)), Ql(t),
				x0(p));
			var u, h, c
		}, p), r && r.eachComponent(i, function(t) {
			f && null != f.get(t.id) || o(p["series" === n ? "_chartsMap" : "_componentsMap"][t
				.__viewId
			])
		}, p)) : E([].concat(p._componentsViews).concat(p._chartsViews), o)
	}, s0 = {
		prepareAndUpdate: function(t) {
			r0(this), s0.update.call(this, t, {
				optionChanged: null != t.newOption
			})
		},
		update: function(t, e) {
			var n = this._model,
				i = this._api,
				r = this._zr,
				o = this._coordSysMgr,
				a = this._scheduler;
			n && (n.setUpdatePayload(t), a.restoreData(n, t), a.performSeriesTasks(n), o.create(n, i), a
				.performDataProcessorTasks(n, t), u0(this, n), o.update(n, i), I0(n), a
				.performVisualTasks(n, t), g0(this, n, i, t, e), o = n.get("backgroundColor") ||
				"transparent", a = n.get("darkMode"), r.setBackgroundColor(o), null != a &&
				"auto" !== a && r.setDarkMode(a), jm.trigger("afterupdate", n, i))
		},
		updateTransform: function(n) {
			var i, r, o = this,
				a = this._model,
				s = this._api;
			a && (a.setUpdatePayload(n), i = [], a.eachComponent(function(t, e) {
				"series" !== t && (t = o.getViewOfComponentModel(e)) && t.__alive && (!t
					.updateTransform || (e = t.updateTransform(e, a, s, n)) && e.update
				) && i.push(t)
			}), r = z(), a.eachSeries(function(t) {
				var e = o._chartsMap[t.__viewId];
				(!e.updateTransform || (e = e.updateTransform(t, a, s, n)) && e.update) && r
					.set(t.uid, 1)
			}), I0(a), this._scheduler.performVisualTasks(a, n, {
				setDirty: !0,
				dirtyMap: r
			}), m0(this, a, s, n, {}, r), jm.trigger("afterupdate", a, s))
		},
		updateView: function(t) {
			var e = this._model;
			e && (e.setUpdatePayload(t), fy.markUpdateMethod(t, "updateView"), I0(e), this._scheduler
				.performVisualTasks(e, t, {
					setDirty: !0
				}), g0(this, e, this._api, t, {}), jm.trigger("afterupdate", e, this._api))
		},
		updateVisual: function(n) {
			var i = this,
				r = this._model;
			r && (r.setUpdatePayload(n), r.eachSeries(function(t) {
					t.getData().clearAllVisual()
				}), fy.markUpdateMethod(n, "updateVisual"), I0(r), this._scheduler
				.performVisualTasks(r, n, {
					visualType: "visual",
					setDirty: !0
				}), r.eachComponent(function(t, e) {
					"series" !== t && (t = i.getViewOfComponentModel(e)) && t.__alive && t
						.updateVisual(e, r, i._api, n)
				}), r.eachSeries(function(t) {
					i._chartsMap[t.__viewId].updateVisual(t, r, i._api, n)
				}), jm.trigger("afterupdate", r, this._api))
		},
		updateLayout: function(t) {
			s0.update.call(this, t)
		}
	}, l0 = function(t, e, n, i) {
		if (t._disposed) t.id;
		else
			for (var r = t._model, o = t._coordSysMgr.getCoordinateSystems(), a = jo(r, n), s = 0; s < o
				.length; s++) {
				var l = o[s];
				if (l[e] && null != (l = l[e](r, a, i))) return l
			}
	}, u0 = function(t, e) {
		var n = t._chartsMap,
			i = t._scheduler;
		e.eachSeries(function(t) {
			i.updateStreamModes(t, n[t.__viewId])
		})
	}, h0 = function(i, t) {
		var r = this,
			e = this.getModel(),
			n = i.type,
			o = i.escapeConnect,
			a = O0[n],
			s = a.actionInfo,
			l = (s.update || "update").split(":"),
			u = l.pop(),
			h = null != l[0] && ia(l[0]),
			l = (this[Km] = !0, [i]),
			c = !1;
		i.batch && (c = !0, l = F(i.batch, function(t) {
			return (t = B(O({}, t), i)).batch = null, t
		}));
		var p = [],
			d = au(i),
			f = su(i);
		if (f && jl(this._api), E(l, function(t) {
				var e, n;
				(y = (y = a.action(t, r._model, r._api)) || O({}, t)).type = s.event || y.type, p.push(
					y), f ? (e = (n = Zo(i)).queryOptionMap, n = n.mainTypeSpecified ? e.keys()[0] :
					"series", a0(r, u, t, n), x0(r)) : d ? (a0(r, u, t, "series"), x0(r)) : h && a0(
					r, u, t, h.main, h.sub)
			}), "none" !== u && !f && !d && !h) try {
			this[$m] ? (r0(this), s0.update.call(this, i), this[$m] = null) : s0[u].call(this, i)
		} catch (i) {
			throw this[Km] = !1, i
		}
		var g, y = c ? {
			type: s.event || n,
			escapeConnect: o,
			batch: p
		} : p[0];
		this[Km] = !1, t || ((l = this._messageCenter).trigger(y.type, y), d && (c = {
			type: "selectchanged",
			escapeConnect: o,
			selected: (g = [], e.eachSeries(function(n) {
				E(n.getAllData(), function(t) {
					t.data;
					var t = t.type,
						e = n.getSelectedDataIndices();
					0 < e.length && (e = {
						dataIndex: e,
						seriesIndex: n.seriesIndex
					}, null != t && (e.dataType = t), g.push(e))
				})
			}), g),
			isFromClick: i.isFromClick || !1,
			fromAction: i.type,
			fromActionPayload: i
		}, l.trigger(c.type, c)))
	}, c0 = function(t) {
		for (var e = this._pendingActions; e.length;) {
			var n = e.shift();
			h0.call(this, n, t)
		}
	}, p0 = function(t) {
		t || this.trigger("updated")
	}, d0 = function(e, n) {
		e.on("rendered", function(t) {
			n.trigger("rendered", t), !e.animation.isFinished() || n[$m] || n._scheduler
				.unfinished || n._pendingActions.length || n.trigger("finished")
		})
	}, f0 = function(t, a) {
		t.on("mouseover", function(t) {
			var e, n, i, r, o = im(t.target, ou);
			o && (o = o, e = t, t = a._api, n = k(o), i = (r = $l(n.componentMainType, n
					.componentIndex, n.componentHighDownName, t)).dispatchers, r = r.focusSelf,
				i ? (r && Kl(n.componentMainType, n.componentIndex, t), E(i, function(t) {
					return Vl(t, e)
				})) : (Zl(n.seriesIndex, n.focus, n.blurScope, t), "self" === n.focus && Kl(n
					.componentMainType, n.componentIndex, t), Vl(o, e)), x0(a))
		}).on("mouseout", function(t) {
			var e, n, i = im(t.target, ou);
			i && (i = i, e = t, jl(t = a._api), (n = $l((n = k(i)).componentMainType, n
				.componentIndex, n.componentHighDownName, t).dispatchers) ? E(n, function(
				t) {
				return Hl(t, e)
			}) : Hl(i, e), x0(a))
		}).on("click", function(t) {
			var e, t = im(t.target, function(t) {
				return null != k(t).dataIndex
			}, !0);
			t && (e = t.selected ? "unselect" : "select", t = k(t), a._api.dispatchAction({
				type: e,
				dataType: t.dataType,
				dataIndexInside: t.dataIndex,
				seriesIndex: t.seriesIndex,
				isFromClick: !0
			}))
		})
	}, g0 = function(t, e, n, i, r) {
		var o, a, s, l, u, h, c;
		u = [], c = !(h = []), (o = e).eachComponent(function(t, e) {
			var n = e.get("zlevel") || 0,
				i = e.get("z") || 0,
				r = e.getZLevelKey();
			c = c || !!r, ("series" === t ? h : u).push({
				zlevel: n,
				z: i,
				idx: e.componentIndex,
				type: t,
				key: r
			})
		}), c && (mn(l = u.concat(h), function(t, e) {
			return t.zlevel === e.zlevel ? t.z - e.z : t.zlevel - e.zlevel
		}), E(l, function(t) {
			var e = o.getComponent(t.type, t.idx),
				n = t.zlevel,
				t = t.key;
			null != a && (n = Math.max(a, n)), t ? (n === a && t !== s && n++, s = t) : s && (
				n === a && n++, s = ""), a = n, e.setZLevel(n)
		})), y0(t, e, n, i, r), E(t._chartsViews, function(t) {
			t.__alive = !1
		}), m0(t, e, n, i, r), E(t._chartsViews, function(t) {
			t.__alive || t.remove(e, n)
		})
	}, y0 = function(t, n, i, r, e, o) {
		E(o || t._componentsViews, function(t) {
			var e = t.__model;
			A0(0, t), t.render(e, n, i, r), D0(e, t), P0(e, t)
		})
	}, m0 = function(r, t, e, o, n, a) {
		var i, s, l, u, h = r._scheduler,
			c = (n = O(n || {}, {
				updatedSeries: t.getSeries()
			}), jm.trigger("series:beforeupdate", t, e, n), !1);
		t.eachSeries(function(t) {
			var e, n = r._chartsMap[t.__viewId],
				i = (n.__alive = !0, n.renderTask);
			h.updatePayload(i, o), A0(0, n), a && a.get(t.uid) && i.dirty(), i.perform(h
					.getPerformArgs(i)) && (c = !0), n.group.silent = !!t.get("silent"), i = n, e =
				t.get("blendMode") || null, i.eachRendered(function(t) {
					t.isGroup || (t.style.blend = e)
				}), Ql(t)
		}), h.unfinished = c || h.unfinished, jm.trigger("series:layoutlabels", t, e, n), jm.trigger(
			"series:transition", t, e, n), t.eachSeries(function(t) {
			var e = r._chartsMap[t.__viewId];
			D0(t, e), P0(t, e)
		}), s = t, l = (i = r)._zr.storage, u = 0, l.traverse(function(t) {
			t.isGroup || u++
		}), u > s.get("hoverLayerThreshold") && !b.node && !b.worker && s.eachSeries(function(t) {
			t.preventUsingHoverLayer || (t = i._chartsMap[t.__viewId]).__alive && t.eachRendered(
				function(t) {
					t.states.emphasis && (t.states.emphasis.hoverLayer = !0)
				})
		}), jm.trigger("series:afterupdate", t, e, n)
	}, x0 = function(t) {
		t[Qm] = !0, t.getZr().wakeUp()
	}, w0 = function(t) {
		t[Qm] && (t.getZr().storage.traverse(function(t) {
			Zh(t) || k0(t)
		}), t[Qm] = !1)
	}, v0 = function(n) {
		return u(t, e = Fd), t.prototype.getCoordinateSystems = function() {
			return n._coordSysMgr.getCoordinateSystems()
		}, t.prototype.getComponentByElement = function(t) {
			for (; t;) {
				var e = t.__ecComponentInfo;
				if (null != e) return n._model.getComponent(e.mainType, e.index);
				t = t.parent
			}
		}, t.prototype.enterEmphasis = function(t, e) {
			Gl(t, e), x0(n)
		}, t.prototype.leaveEmphasis = function(t, e) {
			Wl(t, e), x0(n)
		}, t.prototype.enterBlur = function(t) {
			Nl(t, Al), x0(n)
		}, t.prototype.leaveBlur = function(t) {
			Ul(t), x0(n)
		}, t.prototype.enterSelect = function(t) {
			Xl(t), x0(n)
		}, t.prototype.leaveSelect = function(t) {
			Yl(t), x0(n)
		}, t.prototype.getModel = function() {
			return n.getModel()
		}, t.prototype.getViewOfComponentModel = function(t) {
			return n.getViewOfComponentModel(t)
		}, t.prototype.getViewOfSeriesModel = function(t) {
			return n.getViewOfSeriesModel(t)
		}, new t(n);

		function t() {
			return null !== e && e.apply(this, arguments) || this
		}
		var e
	}, void(_0 = function(i) {
		function r(t, e) {
			for (var n = 0; n < t.length; n++) t[n][t0] = e
		}
		E(R0, function(t, e) {
			i._messageCenter.on(e, function(t) {
				var e, n;
				!H0[i.group] || 0 === i[t0] || t && t.escapeConnect || (e = i
					.makeActionFromEvent(t), n = [], E(V0, function(t) {
						t !== i && t.group === i.group && n.push(t)
					}), r(n, 0), E(n, function(t) {
						1 !== t[t0] && t.dispatchAction(e)
					}), r(n, 2))
			})
		})
	}));
	var T0, C0 = c,
		cm = C0.prototype;

	function c(t, e, n) {
		var i = T0.call(this, new $y) || this,
			t = (i._chartsViews = [], i._chartsMap = {}, i._componentsViews = [], i._componentsMap = {}, i
				._pendingActions = [], n = n || {}, H(e) && (e = B0[e]), i._dom = t, i._zr = lo(t, {
					renderer: n.renderer || "canvas",
					devicePixelRatio: n.devicePixelRatio,
					width: n.width,
					height: n.height,
					ssr: n.ssr,
					useDirtyRect: N(n.useDirtyRect, !1),
					useCoarsePointer: N(n.useCoarsePointer, "auto"),
					pointerSize: n.pointerSize
				})),
			n = (i._ssr = n.ssr, i._throttledZrFlush = My(pt(t.flush, t), 17), (e = _(e)) && pf(e, !0), i._theme =
				e, i._locale = H(e = n.locale || lp) ? (n = ap[e.toUpperCase()] || {}, e === ip || e === rp ? _(n) :
					d(_(n), _(ap[op]), !1)) : d(_(e), _(ap[op]), !1), i._coordSysMgr = new Gd, i._api = v0(i));

		function r(t, e) {
			return t.__prio - e.__prio
		}
		return mn(z0, r), mn(N0, r), i._scheduler = new Ry(i, n, N0, z0), i._messageCenter = new S0, i
			._initEvents(), i.resize = pt(i.resize, i), t.animation.on("frame", i._onframe, i), d0(t, i), f0(t, i),
			Dt(
				i), i
	}

	function I0(t) {
		t.clearColorPalette(), t.eachSeries(function(t) {
			t.clearColorPalette()
		})
	}

	function k0(t) {
		for (var e = [], n = t.currentStates, i = 0; i < n.length; i++) {
			var r = n[i];
			"emphasis" !== r && "blur" !== r && "select" !== r && e.push(r)
		}
		t.selected && t.states.select && e.push("select"), t.hoverState === yl && t.states.emphasis ? e.push(
			"emphasis") : t.hoverState === gl && t.states.blur && e.push("blur"), t.useStates(e)
	}

	function D0(t, e) {
		var n, i;
		t.preventAutoZ || (n = t.get("z") || 0, i = t.get("zlevel") || 0, e.eachRendered(function(t) {
			return function t(e, n, i, r) {
				var o = e.getTextContent(),
					a = e.getTextGuideLine();
				if (e.isGroup)
					for (var s = e.childrenRef(), l = 0; l < s.length; l++) r = Math.max(t(s[l], n,
						i, r), r);
				else e.z = n, e.zlevel = i, r = Math.max(e.z2, r);
				o && (o.z = n, o.zlevel = i, isFinite(r)) && (o.z2 = r + 2), a && (o = e
					.textGuideLineConfig, a.z = n, a.zlevel = i, isFinite(r)) && (a.z2 = r + (
					o && o.showAbove ? 1 : -1));
				return r
			}(t, n, i, -1 / 0), !0
		}))
	}

	function A0(t, e) {
		e.eachRendered(function(t) {
			var e, n;
			Zh(t) || (e = t.getTextContent(), n = t.getTextGuideLine(), t.stateTransition && (t
					.stateTransition = null), e && e.stateTransition && (e.stateTransition = null), n &&
				n.stateTransition && (n.stateTransition = null), t.hasState() ? (t.prevStates = t
					.currentStates, t.clearStates()) : t.prevStates && (t.prevStates = null))
		})
	}

	function P0(t, e) {
		var n = t.getModel("stateAnimation"),
			r = t.isAnimationEnabled(),
			t = n.get("duration"),
			o = 0 < t ? {
				duration: t,
				delay: n.get("delay"),
				easing: n.get("easing")
			} : null;
		e.eachRendered(function(t) {
			var e, n, i;
			t.states && t.states.emphasis && (Zh(t) || (t instanceof Z && ((i = pl(n = t)).normalFill = n
					.style.fill, i.normalStroke = n.style.stroke, n = n.states.select || {}, i
					.selectFill = n.style && n.style.fill || null, i.selectStroke = n.style && n
					.style.stroke || null), t.__dirty && (i = t.prevStates) && t.useStates(i), r &&
				(t.stateTransition = o, n = t.getTextContent(), e = t.getTextGuideLine(), n && (n
					.stateTransition = o), e) && (e.stateTransition = o), t.__dirty && k0(t)))
		})
	}
	cm.on = e0("on"), cm.off = e0("off"), cm.one = function(i, r, t) {
		var o = this;
		this.on.call(this, i, function t() {
			for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
			r && r.apply && r.apply(this, e), o.off(i, t)
		}, t)
	};
	var L0 = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout",
		"contextmenu"
	];
	var O0 = {},
		R0 = {},
		N0 = [],
		E0 = [],
		z0 = [],
		B0 = {},
		F0 = {},
		V0 = {},
		H0 = {},
		G0 = +new Date,
		W0 = +new Date,
		U0 = "_echarts_instance_";

	function X0(t) {
		H0[t] = !1
	}
	lm = X0;

	function Y0(t) {
		return V0[e = U0, (t = t).getAttribute ? t.getAttribute(e) : t[e]];
		var e
	}

	function q0(t, e) {
		B0[t] = e
	}

	function j0(t) {
		I(E0, t) < 0 && E0.push(t)
	}

	function Z0(t, e) {
		rv(N0, t, e, 2e3)
	}

	function K0(t) {
		Q0("afterinit", t)
	}

	function $0(t) {
		Q0("afterupdate", t)
	}

	function Q0(t, e) {
		jm.on(t, e)
	}

	function J0(t, e, n) {
		S(e) && (n = e, e = "");
		var i = L(t) ? t.type : [t, t = {
			event: e
		}][0];
		t.event = (t.event || i).toLowerCase(), e = t.event, R0[e] || (Ct(Jm.test(i) && Jm.test(e)), O0[i] || (O0[
			i] = {
			action: n,
			actionInfo: t
		}), R0[e] = i)
	}

	function tv(t, e) {
		Gd.register(t, e)
	}

	function ev(t, e) {
		rv(z0, t, e, 1e3, "layout")
	}

	function nv(t, e) {
		rv(z0, t, e, 3e3, "visual")
	}
	var iv = [];

	function rv(t, e, n, i, r) {
		(S(e) || L(e)) && (n = e, e = i), 0 <= I(iv, n) || (iv.push(n), (i = Ry.wrapStageHandler(n, r)).__prio = e,
			i.__raw = n, t.push(i))
	}

	function ov(t, e) {
		F0[t] = e
	}

	function av(t, e, n) {
		var i = Zm.registerMap;
		i && i(t, e, n)
	}

	function sv(t) {
		var e = (t = _(t)).type,
			n = (e || f(""), e.split(":")),
			i = (2 !== n.length && f(""), !1);
		"echarts" === n[0] && (e = n[1], i = !0), t.__isBuiltIn = i, vg.set(e, t)
	}
	nv(2e3, pa), nv(4500, fc), nv(4500, gp), nv(2e3, qc), nv(4500, Wc), nv(7e3, function(e, i) {
		e.eachRawSeries(function(t) {
			var n;
			!e.isSeriesFiltered(t) && ((n = t.getData()).hasItemVisual() && n.each(function(t) {
				var e = n.getItemVisual(t, "decal");
				e && (n.ensureUniqueItemVisual(t, "style").decal = Ym(e, i))
			}), t = n.getVisual("decal")) && (n.getVisual("style").decal = Ym(t, i))
		})
	}), j0(pf), Z0(900, function(t) {
		var i = z();
		t.eachSeries(function(t) {
			var e, n = t.get("stack");
			n && (n = i.get(n) || i.set(n, []), (t = {
				stackResultDimension: (e = t.getData()).getCalculationInfo(
					"stackResultDimension"),
				stackedOverDimension: e.getCalculationInfo("stackedOverDimension"),
				stackedDimension: e.getCalculationInfo("stackedDimension"),
				stackedByDimension: e.getCalculationInfo("stackedByDimension"),
				isStackedByIndex: e.getCalculationInfo("isStackedByIndex"),
				data: e,
				seriesModel: t
			}).stackedDimension) && (t.isStackedByIndex || t.stackedByDimension) && (n.length &&
				e.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(t))
		}), i.each(df)
	}), ov("default", function(i, r) {
		B(r = r || {}, {
			text: "loading",
			textColor: "#000",
			fontSize: 12,
			fontWeight: "normal",
			fontStyle: "normal",
			fontFamily: "sans-serif",
			maskColor: "rgba(255, 255, 255, 0.8)",
			showSpinner: !0,
			color: "#5470c6",
			spinnerRadius: 10,
			lineWidth: 5,
			zlevel: 0
		});
		var t = new no,
			o = new Xs({
				style: {
					fill: r.maskColor
				},
				zlevel: r.zlevel,
				z: 1e4
			});
		t.add(o);
		var a, s = new Ks({
				style: {
					text: r.text,
					fill: r.textColor,
					fontSize: r.fontSize,
					fontWeight: r.fontWeight,
					fontStyle: r.fontStyle,
					fontFamily: r.fontFamily
				},
				zlevel: r.zlevel,
				z: 10001
			}),
			l = new Xs({
				style: {
					fill: "none"
				},
				textContent: s,
				textConfig: {
					position: "right",
					distance: 10
				},
				zlevel: r.zlevel,
				z: 10001
			});
		return t.add(l), r.showSpinner && ((a = new Mh({
			shape: {
				startAngle: -Oy / 2,
				endAngle: -Oy / 2 + .1,
				r: r.spinnerRadius
			},
			style: {
				stroke: r.color,
				lineCap: "round",
				lineWidth: r.lineWidth
			},
			zlevel: r.zlevel,
			z: 10001
		})).animateShape(!0).when(1e3, {
			endAngle: 3 * Oy / 2
		}).start("circularInOut"), a.animateShape(!0).when(1e3, {
			startAngle: 3 * Oy / 2
		}).delay(300).start("circularInOut"), t.add(a)), t.resize = function() {
			var t = s.getBoundingRect().width,
				e = r.showSpinner ? r.spinnerRadius : 0,
				t = (i.getWidth() - 2 * e - (r.showSpinner && t ? 10 : 0) - t) / 2 - (r.showSpinner &&
					t ? 0 : 5 + t / 2) + (r.showSpinner ? 0 : t / 2) + (t ? 0 : e),
				n = i.getHeight() / 2;
			r.showSpinner && a.setShape({
				cx: t,
				cy: n
			}), l.setShape({
				x: t - e,
				y: n - e,
				width: 2 * e,
				height: 2 * e
			}), o.setShape({
				x: 0,
				y: 0,
				width: i.getWidth(),
				height: i.getHeight()
			})
		}, t.resize(), t
	}), J0({
		type: _l,
		event: _l,
		update: _l
	}, Vt), J0({
		type: xl,
		event: xl,
		update: xl
	}, Vt), J0({
		type: wl,
		event: wl,
		update: wl
	}, Vt), J0({
		type: bl,
		event: bl,
		update: bl
	}, Vt), J0({
		type: Sl,
		event: Sl,
		update: Sl
	}, Vt), q0("light", Zc), q0("dark", Xc);

	function lv(t) {
		return null == t ? 0 : t.length || 1
	}

	function uv(t) {
		return t
	}
	cv.prototype.add = function(t) {
		return this._add = t, this
	}, cv.prototype.update = function(t) {
		return this._update = t, this
	}, cv.prototype.updateManyToOne = function(t) {
		return this._updateManyToOne = t, this
	}, cv.prototype.updateOneToMany = function(t) {
		return this._updateOneToMany = t, this
	}, cv.prototype.updateManyToMany = function(t) {
		return this._updateManyToMany = t, this
	}, cv.prototype.remove = function(t) {
		return this._remove = t, this
	}, cv.prototype.execute = function() {
		this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]()
	}, cv.prototype._executeOneToOne = function() {
		var t = this._old,
			e = this._new,
			n = {},
			i = new Array(t.length),
			r = new Array(e.length);
		this._initIndexMap(t, null, i, "_oldKeyGetter"), this._initIndexMap(e, n, r, "_newKeyGetter");
		for (var o = 0; o < t.length; o++) {
			var a, s = i[o],
				l = n[s],
				u = lv(l);
			1 < u ? (a = l.shift(), 1 === l.length && (n[s] = l[0]), this._update && this._update(a, o)) : 1 ===
				u ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o)
		}
		this._performRestAdd(r, n)
	}, cv.prototype._executeMultiple = function() {
		var t = this._old,
			e = this._new,
			n = {},
			i = {},
			r = [],
			o = [];
		this._initIndexMap(t, n, r, "_oldKeyGetter"), this._initIndexMap(e, i, o, "_newKeyGetter");
		for (var a = 0; a < r.length; a++) {
			var s = r[a],
				l = n[s],
				u = i[s],
				h = lv(l),
				c = lv(u);
			if (1 < h && 1 === c) this._updateManyToOne && this._updateManyToOne(u, l), i[s] = null;
			else if (1 === h && 1 < c) this._updateOneToMany && this._updateOneToMany(u, l), i[s] = null;
			else if (1 === h && 1 === c) this._update && this._update(u, l), i[s] = null;
			else if (1 < h && 1 < c) this._updateManyToMany && this._updateManyToMany(u, l), i[s] = null;
			else if (1 < h)
				for (var p = 0; p < h; p++) this._remove && this._remove(l[p]);
			else this._remove && this._remove(l)
		}
		this._performRestAdd(o, i)
	}, cv.prototype._performRestAdd = function(t, e) {
		for (var n = 0; n < t.length; n++) {
			var i = t[n],
				r = e[i],
				o = lv(r);
			if (1 < o)
				for (var a = 0; a < o; a++) this._add && this._add(r[a]);
			else 1 === o && this._add && this._add(r);
			e[i] = null
		}
	}, cv.prototype._initIndexMap = function(t, e, n, i) {
		for (var r = this._diffModeMultiple, o = 0; o < t.length; o++) {
			var a, s, l = "_ec_" + this[i](t[o], o);
			r || (n[o] = l), e && (0 === (s = lv(a = e[l])) ? (e[l] = o, r && n.push(l)) : 1 === s ? e[l] = [a,
				o
			] : a.push(o))
		}
	};
	var hv = cv;

	function cv(t, e, n, i, r, o) {
		this._old = t, this._new = e, this._oldKeyGetter = n || uv, this._newKeyGetter = i || uv, this.context = r,
			this._diffModeMultiple = "multiple" === o
	}
	dv.prototype.get = function() {
		return {
			fullDimensions: this._getFullDimensionNames(),
			encode: this._encode
		}
	}, dv.prototype._getFullDimensionNames = function() {
		return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema
			.makeOutputDimensionNames() : []), this._cachedDimNames
	};
	var pv = dv;

	function dv(t, e) {
		this._encode = t, this._schema = e
	}

	function fv(o, t) {
		var e = {},
			a = e.encode = {},
			s = z(),
			l = [],
			u = [],
			h = {},
			i = (E(o.dimensions, function(t) {
				var e, n, i = o.getDimensionInfo(t),
					r = i.coordDim;
				r && (e = i.coordDimIndex, gv(a, r)[e] = t, i.isExtraCoord || (s.set(r, 1), "ordinal" !== (
						n = i.type) && "time" !== n && (l[0] = t), gv(h, r)[e] = o
					.getDimensionIndex(i.name)), i.defaultTooltip) && u.push(t), hd.each(function(t,
					e) {
					var n = gv(a, e),
						e = i.otherDims[e];
					null != e && !1 !== e && (n[e] = i.name)
				})
			}), []),
			r = {},
			n = (s.each(function(t, e) {
				var n = a[e];
				r[e] = n[0], i = i.concat(n)
			}), e.dataDimsOnCoord = i, e.dataDimIndicesOnCoord = F(i, function(t) {
				return o.getDimensionInfo(t).storeDimIndex
			}), e.encodeFirstDimNotExtra = r, a.label),
			n = (n && n.length && (l = n.slice()), a.tooltip);
		return n && n.length ? u = n.slice() : u.length || (u = l.slice()), a.defaultedLabel = l, a
			.defaultedTooltip = u, e.userOutput = new pv(h, t), e
	}

	function gv(t, e) {
		return t.hasOwnProperty(e) || (t[e] = []), t[e]
	}
	var yv = function(t) {
			this.otherDims = {}, null != t && O(this, t)
		},
		mv = Yo(),
		vv = {
			float: "f",
			int: "i",
			ordinal: "o",
			number: "n",
			time: "t"
		},
		_v = (xv.prototype.isDimensionOmitted = function() {
			return this._dimOmitted
		}, xv.prototype._updateDimOmitted = function(t) {
			!(this._dimOmitted = t) || this._dimNameMap || (this._dimNameMap = Sv(this.source))
		}, xv.prototype.getSourceDimensionIndex = function(t) {
			return N(this._dimNameMap.get(t), -1)
		}, xv.prototype.getSourceDimension = function(t) {
			var e = this.source.dimensionsDefine;
			if (e) return e[t]
		}, xv.prototype.makeStoreSchema = function() {
			for (var t = this._fullDimCount, e = Sf(this.source), n = !(30 < t), i = "", r = [], o = 0, a =
					0; o < t; o++) {
				var s, l = void 0,
					u = void 0,
					h = void 0,
					c = this.dimensions[a];
				c && c.storeDimIndex === o ? (l = e ? c.name : null, u = c.type, h = c.ordinalMeta, a++) : (s =
					this.getSourceDimension(o)) && (l = e ? s.name : null, u = s.type), r.push({
					property: l,
					type: u,
					ordinalMeta: h
				}), !e || null == l || c && c.isCalculationCoord || (i += n ? l.replace(/\`/g, "`1")
					.replace(/\$/g, "`2") : l), i = i + "$" + (vv[u] || "f"), h && (i += h.uid), i += "$"
			}
			var p = this.source;
			return {
				dimensions: r,
				hash: [p.seriesLayoutBy, p.startIndex, i].join("$$")
			}
		}, xv.prototype.makeOutputDimensionNames = function() {
			for (var t = [], e = 0, n = 0; e < this._fullDimCount; e++) {
				var i = void 0,
					r = this.dimensions[n];
				r && r.storeDimIndex === e ? (r.isCalculationCoord || (i = r.name), n++) : (r = this
					.getSourceDimension(e)) && (i = r.name), t.push(i)
			}
			return t
		}, xv.prototype.appendCalculationDimension = function(t) {
			this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0)
		}, xv);

	function xv(t) {
		this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this
			._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted)
	}

	function wv(t) {
		return t instanceof _v
	}

	function bv(t) {
		for (var e = z(), n = 0; n < (t || []).length; n++) {
			var i = t[n],
				i = L(i) ? i.name : i;
			null != i && null == e.get(i) && e.set(i, n)
		}
		return e
	}

	function Sv(t) {
		var e = mv(t);
		return e.dimNameMap || (e.dimNameMap = bv(t.dimensionsDefine))
	}
	var Mv, Tv, Cv, Iv, kv, Dv, Av, Pv = L,
		Lv = F,
		Ov = "undefined" == typeof Int32Array ? Array : Int32Array,
		Rv = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput",
			"_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"
		],
		Nv = ["_approximateExtent"],
		Ev = (p.prototype.getDimension = function(t) {
			var e;
			return null == (e = this._recognizeDimIndex(t)) ? t : (e = t, this._dimOmitted ? null != (t = this
					._dimIdxToName.get(e)) ? t : (t = this._schema.getSourceDimension(e)) ? t.name :
				void 0 : this.dimensions[e])
		}, p.prototype.getDimensionIndex = function(t) {
			var e = this._recognizeDimIndex(t);
			return null != e ? e : null == t ? -1 : (e = this._getDimInfo(t)) ? e.storeDimIndex : this
				._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1
		}, p.prototype._recognizeDimIndex = function(t) {
			if (G(t) || null != t && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema
					.getSourceDimensionIndex(t) < 0)) return +t
		}, p.prototype._getStoreDimIndex = function(t) {
			return this.getDimensionIndex(t)
		}, p.prototype.getDimensionInfo = function(t) {
			return this._getDimInfo(this.getDimension(t))
		}, p.prototype._initGetDimensionInfo = function(t) {
			var e = this._dimInfos;
			this._getDimInfo = t ? function(t) {
				return e.hasOwnProperty(t) ? e[t] : void 0
			} : function(t) {
				return e[t]
			}
		}, p.prototype.getDimensionsOnCoord = function() {
			return this._dimSummary.dataDimsOnCoord.slice()
		}, p.prototype.mapDimension = function(t, e) {
			var n = this._dimSummary;
			return null == e ? n.encodeFirstDimNotExtra[t] : (n = n.encode[t]) ? n[e] : null
		}, p.prototype.mapDimensionsAll = function(t) {
			return (this._dimSummary.encode[t] || []).slice()
		}, p.prototype.getStore = function() {
			return this._store
		}, p.prototype.initData = function(t, e, n) {
			var i, r, o = this;
			(i = t instanceof Dg ? t : i) || (r = this.dimensions, t = mf(t) || ut(t) ? new If(t, r.length) : t,
				i = new Dg, r = Lv(r, function(t) {
					return {
						type: o._dimInfos[t].type,
						property: t
					}
				}), i.initData(t, r, n)), this._store = i, this._nameList = (e || []).slice(), this
				._idList = [], this._nameRepeatCount = {}, this._doInit(0, i.count()), this._dimSummary = fv(
					this,
					this._schema), this.userOutput = this._dimSummary.userOutput
		}, p.prototype.appendData = function(t) {
			t = this._store.appendData(t);
			this._doInit(t[0], t[1])
		}, p.prototype.appendValues = function(t, e) {
			var t = this._store.appendValues(t, e.length),
				n = t.start,
				i = t.end,
				r = this._shouldMakeIdFromName();
			if (this._updateOrdinalMeta(), e)
				for (var o = n; o < i; o++) this._nameList[o] = e[o - n], r && Av(this, o)
		}, p.prototype._updateOrdinalMeta = function() {
			for (var t = this._store, e = this.dimensions, n = 0; n < e.length; n++) {
				var i = this._dimInfos[e[n]];
				i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta)
			}
		}, p.prototype._shouldMakeIdFromName = function() {
			var t = this._store.getProvider();
			return null == this._idDimIdx && t.getSource().sourceFormat !== gd && !t.fillStorage
		}, p.prototype._doInit = function(t, e) {
			if (!(e <= t)) {
				var n = this._store.getProvider(),
					i = (this._updateOrdinalMeta(), this._nameList),
					r = this._idList;
				if (n.getSource().sourceFormat === cd && !n.pure)
					for (var o = [], a = t; a < e; a++) {
						var s = n.getItem(a, o);
						this.hasItemOption || !L(l = s) || l instanceof Array || (this.hasItemOption = !0), s &&
							(l = s.name, null == i[a] && null != l && (i[a] = Ho(l, null)), s = s.id, null == r[
								a]) && null != s && (r[a] = Ho(s, null))
					}
				if (this._shouldMakeIdFromName())
					for (a = t; a < e; a++) Av(this, a);
				Mv(this)
			}
			var l
		}, p.prototype.getApproximateExtent = function(t) {
			return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t))
		}, p.prototype.setApproximateExtent = function(t, e) {
			e = this.getDimension(e), this._approximateExtent[e] = t.slice()
		}, p.prototype.getCalculationInfo = function(t) {
			return this._calculationInfo[t]
		}, p.prototype.setCalculationInfo = function(t, e) {
			Pv(t) ? O(this._calculationInfo, t) : this._calculationInfo[t] = e
		}, p.prototype.getName = function(t) {
			var t = this.getRawIndex(t),
				e = this._nameList[t];
			return e = null == (e = null == e && null != this._nameDimIdx ? Cv(this, this._nameDimIdx, t) : e) ?
				"" : e
		}, p.prototype._getCategory = function(t, e) {
			e = this._store.get(t, e), t = this._store.getOrdinalMeta(t);
			return t ? t.categories[e] : e
		}, p.prototype.getId = function(t) {
			return Tv(this, this.getRawIndex(t))
		}, p.prototype.count = function() {
			return this._store.count()
		}, p.prototype.get = function(t, e) {
			var n = this._store,
				t = this._dimInfos[t];
			if (t) return n.get(t.storeDimIndex, e)
		}, p.prototype.getByRawIndex = function(t, e) {
			var n = this._store,
				t = this._dimInfos[t];
			if (t) return n.getByRawIndex(t.storeDimIndex, e)
		}, p.prototype.getIndices = function() {
			return this._store.getIndices()
		}, p.prototype.getDataExtent = function(t) {
			return this._store.getDataExtent(this._getStoreDimIndex(t))
		}, p.prototype.getSum = function(t) {
			return this._store.getSum(this._getStoreDimIndex(t))
		}, p.prototype.getMedian = function(t) {
			return this._store.getMedian(this._getStoreDimIndex(t))
		}, p.prototype.getValues = function(t, e) {
			var n = this,
				i = this._store;
			return V(t) ? i.getValues(Lv(t, function(t) {
				return n._getStoreDimIndex(t)
			}), e) : i.getValues(t)
		}, p.prototype.hasValue = function(t) {
			for (var e = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = e.length; n < i; n++)
				if (isNaN(this._store.get(e[n], t))) return !1;
			return !0
		}, p.prototype.indexOfName = function(t) {
			for (var e = 0, n = this._store.count(); e < n; e++)
				if (this.getName(e) === t) return e;
			return -1
		}, p.prototype.getRawIndex = function(t) {
			return this._store.getRawIndex(t)
		}, p.prototype.indexOfRawIndex = function(t) {
			return this._store.indexOfRawIndex(t)
		}, p.prototype.rawIndexOf = function(t, e) {
			t = (t && this._invertedIndicesMap[t])[e];
			return null == t || isNaN(t) ? -1 : t
		}, p.prototype.indicesOfNearest = function(t, e, n) {
			return this._store.indicesOfNearest(this._getStoreDimIndex(t), e, n)
		}, p.prototype.each = function(t, e, n) {
			S(t) && (n = e, e = t, t = []);
			n = n || this, t = Lv(Iv(t), this._getStoreDimIndex, this);
			this._store.each(t, n ? pt(e, n) : e)
		}, p.prototype.filterSelf = function(t, e, n) {
			S(t) && (n = e, e = t, t = []);
			n = n || this, t = Lv(Iv(t), this._getStoreDimIndex, this);
			return this._store = this._store.filter(t, n ? pt(e, n) : e), this
		}, p.prototype.selectRange = function(n) {
			var i = this,
				r = {};
			return E(R(n), function(t) {
				var e = i._getStoreDimIndex(t);
				r[e] = n[t]
			}), this._store = this._store.selectRange(r), this
		}, p.prototype.mapArray = function(t, e, n) {
			S(t) && (n = e, e = t, t = []);
			var i = [];
			return this.each(t, function() {
				i.push(e && e.apply(this, arguments))
			}, n = n || this), i
		}, p.prototype.map = function(t, e, n, i) {
			n = n || i || this, i = Lv(Iv(t), this._getStoreDimIndex, this), t = Dv(this);
			return t._store = this._store.map(i, n ? pt(e, n) : e), t
		}, p.prototype.modify = function(t, e, n, i) {
			n = n || i || this, i = Lv(Iv(t), this._getStoreDimIndex, this);
			this._store.modify(i, n ? pt(e, n) : e)
		}, p.prototype.downSample = function(t, e, n, i) {
			var r = Dv(this);
			return r._store = this._store.downSample(this._getStoreDimIndex(t), e, n, i), r
		}, p.prototype.lttbDownSample = function(t, e) {
			var n = Dv(this);
			return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), n
		}, p.prototype.getRawDataItem = function(t) {
			return this._store.getRawDataItem(t)
		}, p.prototype.getItemModel = function(t) {
			var e = this.hostModel,
				t = this.getRawDataItem(t);
			return new Qc(t, e, e && e.ecModel)
		}, p.prototype.diff = function(e) {
			var n = this;
			return new hv(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(t) {
				return Tv(e, t)
			}, function(t) {
				return Tv(n, t)
			})
		}, p.prototype.getVisual = function(t) {
			var e = this._visual;
			return e && e[t]
		}, p.prototype.setVisual = function(t, e) {
			this._visual = this._visual || {}, Pv(t) ? O(this._visual, t) : this._visual[t] = e
		}, p.prototype.getItemVisual = function(t, e) {
			t = this._itemVisuals[t], t = t && t[e];
			return null == t ? this.getVisual(e) : t
		}, p.prototype.hasItemVisual = function() {
			return 0 < this._itemVisuals.length
		}, p.prototype.ensureUniqueItemVisual = function(t, e) {
			var n = this._itemVisuals,
				i = n[t],
				n = (i = i || (n[t] = {}))[e];
			return null == n && (V(n = this.getVisual(e)) ? n = n.slice() : Pv(n) && (n = O({}, n)), i[e] = n),
				n
		}, p.prototype.setItemVisual = function(t, e, n) {
			var i = this._itemVisuals[t] || {};
			this._itemVisuals[t] = i, Pv(e) ? O(i, e) : i[e] = n
		}, p.prototype.clearAllVisual = function() {
			this._visual = {}, this._itemVisuals = []
		}, p.prototype.setLayout = function(t, e) {
			Pv(t) ? O(this._layout, t) : this._layout[t] = e
		}, p.prototype.getLayout = function(t) {
			return this._layout[t]
		}, p.prototype.getItemLayout = function(t) {
			return this._itemLayouts[t]
		}, p.prototype.setItemLayout = function(t, e, n) {
			this._itemLayouts[t] = n ? O(this._itemLayouts[t] || {}, e) : e
		}, p.prototype.clearItemLayouts = function() {
			this._itemLayouts.length = 0
		}, p.prototype.setItemGraphicEl = function(t, e) {
			var n, i, r, o, a = this.hostModel && this.hostModel.seriesIndex;
			n = a, i = this.dataType, r = t, (a = e) && ((o = k(a)).dataIndex = r, o.dataType = i, o
				.seriesIndex = n, "group" === a.type) && a.traverse(function(t) {
				t = k(t);
				t.seriesIndex = n, t.dataIndex = r, t.dataType = i
			}), this._graphicEls[t] = e
		}, p.prototype.getItemGraphicEl = function(t) {
			return this._graphicEls[t]
		}, p.prototype.eachItemGraphicEl = function(n, i) {
			E(this._graphicEls, function(t, e) {
				t && n && n.call(i, t, e)
			})
		}, p.prototype.cloneShallow = function(t) {
			return t = t || new p(this._schema || Lv(this.dimensions, this._getDimInfo, this), this.hostModel),
				kv(t, this), t._store = this._store, t
		}, p.prototype.wrapMethod = function(t, e) {
			var n = this[t];
			S(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[
				t] = function() {
				var t = n.apply(this, arguments);
				return e.apply(this, [t].concat(Mt(arguments)))
			})
		}, p.internalField = (Mv = function(a) {
			var s = a._invertedIndicesMap;
			E(s, function(t, e) {
				var n = a._dimInfos[e],
					i = n.ordinalMeta,
					r = a._store;
				if (i) {
					t = s[e] = new Ov(i.categories.length);
					for (var o = 0; o < t.length; o++) t[o] = -1;
					for (o = 0; o < r.count(); o++) t[r.get(n.storeDimIndex, o)] = o
				}
			})
		}, Cv = function(t, e, n) {
			return Ho(t._getCategory(e, n), null)
		}, Tv = function(t, e) {
			var n = t._idList[e];
			return n = null == (n = null == n && null != t._idDimIdx ? Cv(t, t._idDimIdx, e) : n) ?
				"e\0\0" + e : n
		}, Iv = function(t) {
			return t = V(t) ? t : null != t ? [t] : []
		}, Dv = function(t) {
			var e = new p(t._schema || Lv(t.dimensions, t._getDimInfo, t), t.hostModel);
			return kv(e, t), e
		}, kv = function(e, n) {
			E(Rv.concat(n.__wrappedMethods || []), function(t) {
				n.hasOwnProperty(t) && (e[t] = n[t])
			}), e.__wrappedMethods = n.__wrappedMethods, E(Nv, function(t) {
				e[t] = _(n[t])
			}), e._calculationInfo = O({}, n._calculationInfo)
		}, void(Av = function(t, e) {
			var n = t._nameList,
				i = t._idList,
				r = t._nameDimIdx,
				o = t._idDimIdx,
				a = n[e],
				s = i[e];
			null == a && null != r && (n[e] = a = Cv(t, r, e)), null == s && null != o && (i[e] = s =
				Cv(t, o, e)), null == s && null != a && (s = a, 1 < (r = (n = t._nameRepeatCount)[
				a] = (n[a] || 0) + 1) && (s += "__ec__" + r), i[e] = s)
		})), p);

	function p(t, e) {
		this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this
			._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this
			._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this
			.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this
			.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
		var n = !(this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"]);
		wv(t) ? (r = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (n = !0, r = t);
		for (var i, r = r || ["x", "y"], o = {}, a = [], s = {}, l = !1, u = {}, h = 0; h < r.length; h++) {
			var c = r[h],
				c = H(c) ? new yv({
					name: c
				}) : c instanceof yv ? c : new yv(c),
				p = c.name,
				d = (c.type = c.type || "float", c.coordDim || (c.coordDim = p, c.coordDimIndex = 0), c.otherDims =
					c.otherDims || {});
			a.push(p), null != u[p] && (l = !0), (o[p] = c).createInvertedIndices && (s[p] = []), 0 === d
				.itemName && (this._nameDimIdx = h), 0 === d.itemId && (this._idDimIdx = h), n && (c.storeDimIndex =
					h)
		}
		this.dimensions = a, this._dimInfos = o, this._initGetDimensionInfo(l), this.hostModel = e, this
			._invertedIndicesMap = s, this._dimOmitted && (i = this._dimIdxToName = z(), E(a, function(t) {
				i.set(o[t].storeDimIndex, t)
			}))
	}

	function zv(t, e) {
		mf(t) || (t = _f(t));
		for (var n, i, r = (e = e || {}).coordDimensions || [], o = e.dimensionsDefine || t.dimensionsDefine || [],
				a = z(), s = [], l = (u = t, n = r, p = e.dimensionsCount, i = Math.max(u.dimensionsDetectedCount ||
					1, n.length, o.length, p || 0), E(n, function(t) {
					L(t) && (t = t.dimsDef) && (i = Math.max(i, t.length))
				}), i), u = e.canOmitUnusedDimensions && 30 < l, h = o === t.dimensionsDefine, c = h ? Sv(t) : bv(
					o), p = e.encodeDefine, d = z(p = !p && e.encodeDefaulter ? e.encodeDefaulter(t, l) : p), f =
				new Mg(l), g = 0; g < f.length; g++) f[g] = -1;

		function y(t) {
			var e, n, i, r = f[t];
			return r < 0 ? (e = L(e = o[t]) ? e : {
					name: e
				}, n = new yv, null != (i = e.name) && null != c.get(i) && (n.name = n.displayName = i), null !=
				e.type && (n.type = e.type), null != e.displayName && (n.displayName = e.displayName), f[t] = s
				.length, n.storeDimIndex = t, s.push(n), n) : s[r]
		}
		if (!u)
			for (g = 0; g < l; g++) y(g);
		d.each(function(t, n) {
			var i, t = Ro(t).slice();
			1 === t.length && !H(t[0]) && t[0] < 0 ? d.set(n, !1) : (i = d.set(n, []), E(t, function(t, e) {
				t = H(t) ? c.get(t) : t;
				null != t && t < l && v(y(i[e] = t), n, e)
			}))
		});
		var m = 0;

		function v(t, e, n) {
			null != hd.get(e) ? t.otherDims[e] = n : (t.coordDim = e, t.coordDimIndex = n, a.set(e, !0))
		}
		E(r, function(t) {
			H(t) ? (o = t, r = {}) : (o = (r = t).name, t = r.ordinalMeta, r.ordinalMeta = null, (r = O({},
					r)).ordinalMeta = t, n = r.dimsDef, i = r.otherDims, r.name = r.coordDim = r
				.coordDimIndex = r.dimsDef = r.otherDims = null);
			var n, i, r, o, e = d.get(o);
			if (!1 !== e) {
				if (!(e = Ro(e)).length)
					for (var a = 0; a < (n && n.length || 1); a++) {
						for (; m < l && null != y(m).coordDim;) m++;
						m < l && e.push(m++)
					}
				E(e, function(t, e) {
					t = y(t);
					h && null != r.type && (t.type = r.type), v(B(t, r), o, e), null == t.name &&
						n && (L(e = n[e]) || (e = {
								name: e
							}), t.name = t.displayName = e.name, t.defaultTooltip = e
							.defaultTooltip), i && B(t.otherDims, i)
				})
			}
		});
		var _ = e.generateCoord,
			x = null != (w = e.generateCoordCount),
			w = _ ? w || 1 : 0,
			b = _ || "value";

		function S(t) {
			null == t.name && (t.name = t.coordDim)
		}
		if (u) E(s, function(t) {
			S(t)
		}), s.sort(function(t, e) {
			return t.storeDimIndex - e.storeDimIndex
		});
		else
			for (var M = 0; M < l; M++) {
				var T = y(M);
				null == T.coordDim && (T.coordDim = function(t, e, n) {
						if (n || e.hasKey(t)) {
							for (var i = 0; e.hasKey(t + i);) i++;
							t += i
						}
						return e.set(t, !0), t
					}(b, a, x), T.coordDimIndex = 0, (!_ || w <= 0) && (T.isExtraCoord = !0), w--), S(T), null != T
					.type || Md(t, M) !== _d.Must && (!T.isExtraCoord || null == T.otherDims.itemName && null == T
						.otherDims.seriesName) || (T.type = "ordinal")
			}
		for (var C = s, I = z(), k = 0; k < C.length; k++) {
			var D = C[k],
				A = D.name,
				P = I.get(A) || 0;
			0 < P && (D.name = A + (P - 1)), P++, I.set(A, P)
		}
		return new _v({
			source: t,
			dimensions: s,
			fullDimensionCount: l,
			dimensionOmitted: u
		})
	}

	function Bv(t) {
		this.coordSysDims = [], this.axisMap = z(), this.categoryAxisMap = z(), this.coordSysName = t
	}
	var Fv = {
		cartesian2d: function(t, e, n, i) {
			var r = t.getReferringComponents("xAxis", Ko).models[0],
				t = t.getReferringComponents("yAxis", Ko).models[0];
			e.coordSysDims = ["x", "y"], n.set("x", r), n.set("y", t), Vv(r) && (i.set("x", r), e
				.firstCategoryDimIndex = 0), Vv(t) && (i.set("y", t), null == e
				.firstCategoryDimIndex) && (e.firstCategoryDimIndex = 1)
		},
		singleAxis: function(t, e, n, i) {
			t = t.getReferringComponents("singleAxis", Ko).models[0];
			e.coordSysDims = ["single"], n.set("single", t), Vv(t) && (i.set("single", t), e
				.firstCategoryDimIndex = 0)
		},
		polar: function(t, e, n, i) {
			var t = t.getReferringComponents("polar", Ko).models[0],
				r = t.findAxisModel("radiusAxis"),
				t = t.findAxisModel("angleAxis");
			e.coordSysDims = ["radius", "angle"], n.set("radius", r), n.set("angle", t), Vv(r) && (i.set(
				"radius", r), e.firstCategoryDimIndex = 0), Vv(t) && (i.set("angle", t), null == e
				.firstCategoryDimIndex) && (e.firstCategoryDimIndex = 1)
		},
		geo: function(t, e, n, i) {
			e.coordSysDims = ["lng", "lat"]
		},
		parallel: function(t, i, r, o) {
			var a = t.ecModel,
				t = a.getComponent("parallel", t.get("parallelIndex")),
				s = i.coordSysDims = t.dimensions.slice();
			E(t.parallelAxisIndex, function(t, e) {
				var t = a.getComponent("parallelAxis", t),
					n = s[e];
				r.set(n, t), Vv(t) && (o.set(n, t), null == i.firstCategoryDimIndex) && (i
					.firstCategoryDimIndex = e)
			})
		}
	};

	function Vv(t) {
		return "category" === t.get("type")
	}

	function Hv(t, e, n) {
		var i, r, o, a = (n = n || {}).byIndex,
			s = n.stackedCoordDimension;
		wv(e.schema) ? (r = e.schema, i = r.dimensions, o = e.store) : i = e;
		var l, u, h, c, p, d, f = !(!t || !t.get("stack"));
		return E(i, function(t, e) {
			H(t) && (i[e] = t = {
				name: t
			}), f && !t.isExtraCoord && (a || l || !t.ordinalMeta || (l = t), u || "ordinal" === t
				.type || "time" === t.type || s && s !== t.coordDim || (u = t))
		}), !u || a || l || (a = !0), u && (h = "__\0ecstackresult_" + t.id, c = "__\0ecstackedover_" + t.id,
			l && (l.createInvertedIndices = !0), p = u.coordDim, n = u.type, d = 0, E(i, function(t) {
				t.coordDim === p && d++
			}), e = {
				name: h,
				coordDim: p,
				coordDimIndex: d,
				type: n,
				isExtraCoord: !0,
				isCalculationCoord: !0,
				storeDimIndex: i.length
			}, t = {
				name: c,
				coordDim: c,
				coordDimIndex: d + 1,
				type: n,
				isExtraCoord: !0,
				isCalculationCoord: !0,
				storeDimIndex: i.length + 1
			}, r ? (o && (e.storeDimIndex = o.ensureCalculationDimension(c, n), t.storeDimIndex = o
					.ensureCalculationDimension(h, n)), r.appendCalculationDimension(e), r
				.appendCalculationDimension(t)) : (i.push(e), i.push(t))), {
			stackedDimension: u && u.name,
			stackedByDimension: l && l.name,
			isStackedByIndex: a,
			stackedOverDimension: c,
			stackResultDimension: h
		}
	}

	function Gv(t, e) {
		return !!e && e === t.getCalculationInfo("stackedDimension")
	}

	function Wv(t, e) {
		return Gv(t, e) ? t.getCalculationInfo("stackResultDimension") : e
	}

	function Uv(t, e, n) {
		n = n || {};
		var i, r, o, a, s, l, u = e.getSourceManager(),
			h = !1,
			t = (t ? (h = !0, i = _f(t)) : h = (i = u.getSource()).sourceFormat === cd, function(t) {
				var e = t.get("coordinateSystem"),
					n = new Bv(e);
				if (e = Fv[e]) return e(t, n, n.axisMap, n.categoryAxisMap), n
			}(e)),
			c = (l = t, c = (c = e).get("coordinateSystem"), c = Gd.get(c), p = (p = l && l.coordSysDims ? F(l
				.coordSysDims,
				function(t) {
					var e = {
							name: t
						},
						t = l.axisMap.get(t);
					return t && (t = t.get("type"), e.type = "category" === (t = t) ? "ordinal" : "time" ===
						t ? "time" : "float"), e
				}) : p) || c && (c.getDimensionsInfo ? c.getDimensionsInfo() : c.dimensions.slice()) || ["x",
				"y"
			]),
			p = n.useEncodeDefaulter,
			p = S(p) ? p : p ? dt(wd, c, e) : null,
			c = {
				coordDimensions: c,
				generateCoord: n.generateCoord,
				encodeDefine: e.getEncode(),
				encodeDefaulter: p,
				canOmitUnusedDimensions: !h
			},
			p = zv(i, c),
			d = (c = p.dimensions, r = n.createInvertedIndices, (o = t) && E(c, function(t, e) {
				var n = t.coordDim,
					n = o.categoryAxisMap.get(n);
				n && (null == a && (a = e), t.ordinalMeta = n.getOrdinalMeta(), r) && (t
					.createInvertedIndices = !0), null != t.otherDims.itemName && (s = !0)
			}), s || null == a || (c[a].otherDims.itemName = 0), a),
			n = h ? null : u.getSharedDataStore(p),
			t = Hv(e, {
				schema: p,
				store: n
			}),
			c = new Ev(p, e),
			p = (c.setCalculationInfo(t), null == d || (u = i).sourceFormat !== cd || V(zo(function(t) {
				for (var e = 0; e < t.length && null == t[e];) e++;
				return t[e]
			}(u.data || []))) ? null : function(t, e, n, i) {
				return i === d ? n : this.defaultDimValueGetter(t, e, n, i)
			});
		return c.hasItemOption = !1, c.initData(h ? i : n, null, p), c
	}
	Yv.prototype.getSetting = function(t) {
		return this._setting[t]
	}, Yv.prototype.unionExtent = function(t) {
		var e = this._extent;
		t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
	}, Yv.prototype.unionExtentFromData = function(t, e) {
		this.unionExtent(t.getApproximateExtent(e))
	}, Yv.prototype.getExtent = function() {
		return this._extent.slice()
	}, Yv.prototype.setExtent = function(t, e) {
		var n = this._extent;
		isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e)
	}, Yv.prototype.isInExtentRange = function(t) {
		return this._extent[0] <= t && this._extent[1] >= t
	}, Yv.prototype.isBlank = function() {
		return this._isBlank
	}, Yv.prototype.setBlank = function(t) {
		this._isBlank = t
	};
	var Xv = Yv;

	function Yv(t) {
		this._setting = t || {}, this._extent = [1 / 0, -1 / 0]
	}
	ua(Xv);
	var qv = 0,
		jv = (Zv.createByAxisModel = function(t) {
			var t = t.option,
				e = t.data,
				e = e && F(e, Kv);
			return new Zv({
				categories: e,
				needCollect: !e,
				deduplication: !1 !== t.dedplication
			})
		}, Zv.prototype.getOrdinal = function(t) {
			return this._getOrCreateMap().get(t)
		}, Zv.prototype.parseAndCollect = function(t) {
			var e, n, i = this._needCollect;
			return H(t) || i ? (i && !this._deduplication ? (e = this.categories.length, this.categories[e] =
				t) : null == (e = (n = this._getOrCreateMap()).get(t)) && (i ? (e = this.categories
				.length,
				this.categories[e] = t, n.set(t, e)) : e = NaN), e) : t
		}, Zv.prototype._getOrCreateMap = function() {
			return this._map || (this._map = z(this.categories))
		}, Zv);

	function Zv(t) {
		this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t
			.deduplication, this.uid = ++qv
	}

	function Kv(t) {
		return L(t) && null != t.value ? t.value : t + ""
	}

	function $v(t) {
		return "interval" === t.type || "log" === t.type
	}

	function Qv(t, e, n, i) {
		var r = {},
			o = t[1] - t[0],
			o = r.interval = Co(o / e, !0),
			e = (null != n && o < n && (o = r.interval = n), null != i && i < o && (o = r.interval = i), r
				.intervalPrecision = t_(o));
		return n = r.niceTickExtent = [go(Math.ceil(t[0] / o) * o, e), go(Math.floor(t[1] / o) * o, e)], i = t,
			isFinite(n[0]) || (n[0] = i[0]), isFinite(n[1]) || (n[1] = i[1]), e_(n, 0, i), e_(n, 1, i), n[0] > n[
				1] && (n[0] = n[1]), r
	}

	function Jv(t) {
		var e = Math.pow(10, To(t)),
			t = t / e;
		return t ? 2 === t ? t = 3 : 3 === t ? t = 5 : t *= 2 : t = 1, go(t * e)
	}

	function t_(t) {
		return yo(t) + 2
	}

	function e_(t, e, n) {
		t[e] = Math.max(Math.min(t[e], n[1]), n[0])
	}

	function n_(t, e) {
		return t >= e[0] && t <= e[1]
	}

	function i_(t, e) {
		return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
	}

	function r_(t, e) {
		return t * (e[1] - e[0]) + e[0]
	}
	u(s_, o_ = Xv), s_.prototype.parse = function(t) {
			return null == t ? NaN : H(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t)
		}, s_.prototype.contain = function(t) {
			return n_(t = this.parse(t), this._extent) && null != this._ordinalMeta.categories[t]
		}, s_.prototype.normalize = function(t) {
			return i_(t = this._getTickNumber(this.parse(t)), this._extent)
		}, s_.prototype.scale = function(t) {
			return t = Math.round(r_(t, this._extent)), this.getRawOrdinalNumber(t)
		}, s_.prototype.getTicks = function() {
			for (var t = [], e = this._extent, n = e[0]; n <= e[1];) t.push({
				value: n
			}), n++;
			return t
		}, s_.prototype.getMinorTicks = function(t) {}, s_.prototype.setSortInfo = function(t) {
			if (null != t) {
				for (var e = t.ordinalNumbers, n = this._ordinalNumbersByTick = [], i = this
						._ticksByOrdinalNumber = [], r = 0, o = this._ordinalMeta.categories.length, a = Math.min(o,
							e.length); r < a; ++r) {
					var s = e[r];
					i[n[r] = s] = r
				}
				for (var l = 0; r < o; ++r) {
					for (; null != i[l];) l++;
					n.push(l), i[l] = r
				}
			} else this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null
		}, s_.prototype._getTickNumber = function(t) {
			var e = this._ticksByOrdinalNumber;
			return e && 0 <= t && t < e.length ? e[t] : t
		}, s_.prototype.getRawOrdinalNumber = function(t) {
			var e = this._ordinalNumbersByTick;
			return e && 0 <= t && t < e.length ? e[t] : t
		}, s_.prototype.getLabel = function(t) {
			if (!this.isBlank()) return t = this.getRawOrdinalNumber(t.value), null == (t = this._ordinalMeta
				.categories[t]) ? "" : t + ""
		}, s_.prototype.count = function() {
			return this._extent[1] - this._extent[0] + 1
		}, s_.prototype.unionExtentFromData = function(t, e) {
			this.unionExtent(t.getApproximateExtent(e))
		}, s_.prototype.isInExtentRange = function(t) {
			return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t
		}, s_.prototype.getOrdinalMeta = function() {
			return this._ordinalMeta
		}, s_.prototype.calcNiceTicks = function() {}, s_.prototype.calcNiceExtent = function() {}, s_.type =
		"ordinal";
	var o_, a_ = s_;

	function s_(t) {
		var t = o_.call(this, t) || this,
			e = (t.type = "ordinal", t.getSetting("ordinalMeta"));
		return V(e = e || new jv({})) && (e = new jv({
			categories: F(e, function(t) {
				return L(t) ? t.value : t
			})
		})), t._ordinalMeta = e, t._extent = t.getSetting("extent") || [0, e.categories.length - 1], t
	}
	Xv.registerClass(a_);
	var l_, u_ = go,
		h_ = (u(c_, l_ = Xv), c_.prototype.parse = function(t) {
			return t
		}, c_.prototype.contain = function(t) {
			return n_(t, this._extent)
		}, c_.prototype.normalize = function(t) {
			return i_(t, this._extent)
		}, c_.prototype.scale = function(t) {
			return r_(t, this._extent)
		}, c_.prototype.setExtent = function(t, e) {
			var n = this._extent;
			isNaN(t) || (n[0] = parseFloat(t)), isNaN(e) || (n[1] = parseFloat(e))
		}, c_.prototype.unionExtent = function(t) {
			var e = this._extent;
			t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), this.setExtent(e[0], e[1])
		}, c_.prototype.getInterval = function() {
			return this._interval
		}, c_.prototype.setInterval = function(t) {
			this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = t_(t)
		}, c_.prototype.getTicks = function(t) {
			var e = this._interval,
				n = this._extent,
				i = this._niceExtent,
				r = this._intervalPrecision,
				o = [];
			if (e) {
				n[0] < i[0] && o.push(t ? {
					value: u_(i[0] - e, r)
				} : {
					value: n[0]
				});
				for (var a = i[0]; a <= i[1] && (o.push({
						value: a
					}), (a = u_(a + e, r)) !== o[o.length - 1].value);)
					if (1e4 < o.length) return [];
				var s = o.length ? o[o.length - 1].value : i[1];
				n[1] > s && o.push(t ? {
					value: u_(s + e, r)
				} : {
					value: n[1]
				})
			}
			return o
		}, c_.prototype.getMinorTicks = function(t) {
			for (var e = this.getTicks(!0), n = [], i = this.getExtent(), r = 1; r < e.length; r++) {
				for (var o = e[r], a = e[r - 1], s = 0, l = [], u = (o.value - a.value) / t; s < t - 1;) {
					var h = u_(a.value + (s + 1) * u);
					h > i[0] && h < i[1] && l.push(h), s++
				}
				n.push(l)
			}
			return n
		}, c_.prototype.getLabel = function(t, e) {
			return null == t ? "" : (null == (e = e && e.precision) ? e = yo(t.value) || 0 : "auto" === e && (
				e = this._intervalPrecision), zp(u_(t.value, e, !0)))
		}, c_.prototype.calcNiceTicks = function(t, e, n) {
			t = t || 5;
			var i = this._extent,
				r = i[1] - i[0];
			isFinite(r) && (r < 0 && i.reverse(), r = Qv(i, t, e, n), this._intervalPrecision = r
				.intervalPrecision, this._interval = r.interval, this._niceExtent = r.niceTickExtent)
		}, c_.prototype.calcNiceExtent = function(t) {
			var e = this._extent,
				n = (e[0] === e[1] && (0 !== e[0] ? (n = Math.abs(e[0]), t.fixMax || (e[1] += n / 2), e[0] -=
					n / 2) : e[1] = 1), e[1] - e[0]),
				n = (isFinite(n) || (e[0] = 0, e[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t
					.maxInterval), this._interval);
			t.fixMin || (e[0] = u_(Math.floor(e[0] / n) * n)), t.fixMax || (e[1] = u_(Math.ceil(e[1] / n) * n))
		}, c_.prototype.setNiceExtent = function(t, e) {
			this._niceExtent = [t, e]
		}, c_.type = "interval", c_);

	function c_() {
		var t = null !== l_ && l_.apply(this, arguments) || this;
		return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t
	}
	Xv.registerClass(h_);
	var p_ = "undefined" != typeof Float32Array,
		d_ = p_ ? Float32Array : Array;

	function f_(t) {
		return V(t) ? p_ ? new Float32Array(t) : t : new d_(t)
	}
	var g_ = "__ec_stack_";

	function y_(t) {
		return t.get("stack") || g_ + t.seriesIndex
	}

	function m_(t) {
		return t.dim + t.index
	}

	function v_(t, e) {
		var n = [];
		return e.eachSeriesByType(t, function(t) {
			w_(t) && n.push(t)
		}), n
	}

	function __(t) {
		var a, d, l = function(t) {
				var e, l = {},
					n = (E(t, function(t) {
						var e = t.coordinateSystem.getBaseAxis();
						if ("time" === e.type || "value" === e.type)
							for (var t = t.getData(), n = e.dim + "_" + e.index, i = t.getDimensionIndex(t
									.mapDimension(e.dim)), r = t.getStore(), o = 0, a = r.count(); o < a; ++
								o) {
								var s = r.get(i, o);
								l[n] ? l[n].push(s) : l[n] = [s]
							}
					}), {});
				for (e in l)
					if (l.hasOwnProperty(e)) {
						var i = l[e];
						if (i) {
							i.sort(function(t, e) {
								return t - e
							});
							for (var r = null, o = 1; o < i.length; ++o) {
								var a = i[o] - i[o - 1];
								0 < a && (r = null === r ? a : Math.min(r, a))
							}
							n[e] = r
						}
					} return n
			}(t),
			u = [];
		return E(t, function(t) {
			var e, n = t.coordinateSystem.getBaseAxis(),
				i = n.getExtent(),
				r = (e = "category" === n.type ? n.getBandWidth() : "value" === n.type || "time" === n
					.type ? (e = n.dim + "_" + n.index, e = l[e], r = Math.abs(i[1] - i[0]), o = n.scale
						.getExtent(), o = Math.abs(o[1] - o[0]), e ? r / o * e : r) : (o = t.getData(), Math
						.abs(i[1] - i[0]) / o.count()), fo(t.get("barWidth"), e)),
				i = fo(t.get("barMaxWidth"), e),
				o = fo(t.get("barMinWidth") || (b_(t) ? .5 : 1), e),
				a = t.get("barGap"),
				s = t.get("barCategoryGap");
			u.push({
				bandWidth: e,
				barWidth: r,
				barMaxWidth: i,
				barMinWidth: o,
				barGap: a,
				barCategoryGap: s,
				axisKey: m_(n),
				stackId: y_(t)
			})
		}), a = {}, E(u, function(t, e) {
			var n = t.axisKey,
				i = t.bandWidth,
				i = a[n] || {
					bandWidth: i,
					remainedWidth: i,
					autoWidthCount: 0,
					categoryGap: null,
					gap: "20%",
					stacks: {}
				},
				r = i.stacks,
				n = (a[n] = i, t.stackId),
				o = (r[n] || i.autoWidthCount++, r[n] = r[n] || {
					width: 0,
					maxWidth: 0
				}, t.barWidth),
				o = (o && !r[n].width && (r[n].width = o, o = Math.min(i.remainedWidth, o), i
					.remainedWidth -= o), t.barMaxWidth),
				o = (o && (r[n].maxWidth = o), t.barMinWidth),
				r = (o && (r[n].minWidth = o), t.barGap),
				n = (null != r && (i.gap = r), t.barCategoryGap);
			null != n && (i.categoryGap = n)
		}), d = {}, E(a, function(t, n) {
			d[n] = {};
			var e = t.stacks,
				i = t.bandWidth,
				r = t.categoryGap,
				o = (null == r && (o = R(e).length, r = Math.max(35 - 4 * o, 15) + "%"), fo(r, i)),
				a = fo(t.gap, 1),
				s = t.remainedWidth,
				l = t.autoWidthCount,
				u = (s - o) / (l + (l - 1) * a),
				u = Math.max(u, 0);
			E(e, function(t) {
				var e, n = t.maxWidth,
					i = t.minWidth;
				t.width ? (e = t.width, n && (e = Math.min(e, n)), i && (e = Math.max(e, i)), t
					.width = e, s -= e + a * e, l--) : (e = u, n && n < e && (e = Math.min(n,
					s)), (e = i && e < i ? i : e) !== u && (t.width = e, s -= e + a * e,
					l--))
			}), u = (s - o) / (l + (l - 1) * a), u = Math.max(u, 0);
			var h, c = 0,
				p = (E(e, function(t, e) {
					t.width || (t.width = u), c += (h = t).width * (1 + a)
				}), h && (c -= h.width * a), -c / 2);
			E(e, function(t, e) {
				d[n][e] = d[n][e] || {
					bandWidth: i,
					offset: p,
					width: t.width
				}, p += t.width * (1 + a)
			})
		}), d
	}

	function x_(t, e) {
		var t = v_(t, e),
			r = __(t);
		E(t, function(t) {
			var e = t.getData(),
				n = t.coordinateSystem.getBaseAxis(),
				t = y_(t),
				n = r[m_(n)][t],
				t = n.offset,
				i = n.width;
			e.setLayout({
				bandWidth: n.bandWidth,
				offset: t,
				size: i
			})
		})
	}

	function w_(t) {
		return t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
	}

	function b_(t) {
		return t.pipelineContext && t.pipelineContext.large
	}
	u(C_, S_ = h_), C_.prototype.getLabel = function(t) {
		var e = this.getSetting("useUTC");
		return wp(t.value, yp[function(t) {
			switch (t) {
				case "year":
				case "month":
					return "day";
				case "millisecond":
					return "millisecond";
				default:
					return "second"
			}
		}(xp(this._minLevelUnit))] || yp.second, e, this.getSetting("locale"))
	}, C_.prototype.getFormattedLabel = function(t, e, n) {
		var i = this.getSetting("useUTC"),
			r = this.getSetting("locale"),
			o = null;
		if (H(n)) o = n;
		else if (S(n)) o = n(t.value, e, {
			level: t.level
		});
		else {
			var a = O({}, fp);
			if (0 < t.level)
				for (var s = 0; s < mp.length; ++s) a[mp[s]] = "{primary|" + a[mp[s]] + "}";
			var l = n ? !1 === n.inherit ? n : B(n, a) : a,
				u = bp(t.value, i);
			if (l[u]) o = l[u];
			else if (l.inherit) {
				for (s = vp.indexOf(u) - 1; 0 <= s; --s)
					if (l[u]) {
						o = l[u];
						break
					} o = o || a.none
			}
			V(o) && (e = null == t.level ? 0 : 0 <= t.level ? t.level : o.length + t.level, o = o[e = Math.min(
				e, o.length - 1)])
		}
		return wp(new Date(t.value), o, i, r)
	}, C_.prototype.getTicks = function() {
		var t = this._interval,
			e = this._extent,
			n = [];
		return t && (n.push({
			value: e[0],
			level: 0
		}), t = this.getSetting("useUTC"), t = function(t, b, S, M) {
			var e = vp,
				n = 0;

			function i(t, e, n) {
				var i, r, o = [],
					a = !e.length;
				if (! function(t, e, n, i) {
						function r(t) {
							return Sp(c, t, i) === Sp(p, t, i)
						}

						function o() {
							return r("year")
						}

						function a() {
							return o() && r("month")
						}

						function s() {
							return a() && r("day")
						}

						function l() {
							return s() && r("hour")
						}

						function u() {
							return l() && r("minute")
						}

						function h() {
							return u() && r("second")
						}
						var c = So(e),
							p = So(n);
						switch (t) {
							case "year":
								return o();
							case "month":
								return a();
							case "day":
								return s();
							case "hour":
								return l();
							case "minute":
								return u();
							case "second":
								return h();
							case "millisecond":
								return h() && r("millisecond")
						}
					}(xp(t), M[0], M[1], S)) {
					a && (e = [{
						value: function(t, e, n) {
							var i = new Date(t);
							switch (xp(e)) {
								case "year":
								case "month":
									i[Pp(n)](0);
								case "day":
									i[Lp(n)](1);
								case "hour":
									i[Op(n)](0);
								case "minute":
									i[Rp(n)](0);
								case "second":
									i[Np(n)](0), i[Ep(n)](0)
							}
							return i.getTime()
						}(new Date(M[0]), t, S)
					}, {
						value: M[1]
					}]);
					for (var s = 0; s < e.length - 1; s++) {
						var l = e[s].value,
							u = e[s + 1].value;
						if (l !== u) {
							var h = void 0,
								c = void 0,
								p = void 0;
							switch (t) {
								case "year":
									h = Math.max(1, Math.round(b / dp / 365)), c = Mp(S), p = S ?
										"setUTCFullYear" : "setFullYear";
									break;
								case "half-year":
								case "quarter":
								case "month":
									r = b, h = 6 < (r /= 30 * dp) ? 6 : 3 < r ? 3 : 2 < r ? 2 : 1, c =
										Tp(S), p = Pp(S);
									break;
								case "week":
								case "half-week":
								case "day":
									r = b, h = 16 < (r /= dp) ? 16 : 7.5 < r ? 7 : 3.5 < r ? 4 : 1.5 <
										r ? 2 : 1, c = Cp(S), p = Lp(S);
									break;
								case "half-day":
								case "quarter-day":
								case "hour":
									i = b, h = 12 < (i /= pp) ? 12 : 6 < i ? 6 : 3.5 < i ? 4 : 2 < i ?
										2 : 1, c = Ip(S), p = Op(S);
									break;
								case "minute":
									h = I_(b, !0), c = kp(S), p = Rp(S);
									break;
								case "second":
									h = I_(b, !1), c = Dp(S), p = Np(S);
									break;
								case "millisecond":
									h = Co(b, !0), c = Ap(S), p = Ep(S)
							}
							w = x = _ = v = m = y = g = f = d = void 0;
							for (var d = h, f = l, g = u, y = c, m = p, v = o, _ = new Date(f), x = f,
									w = _[y](); x < g && x <= M[1];) v.push({
								value: x
							}), _[m](w += d), x = _.getTime();
							v.push({
								value: x,
								notAdd: !0
							}), "year" === t && 1 < n.length && 0 === s && n.unshift({
								value: n[0].value - h
							})
						}
					}
					for (s = 0; s < o.length; s++) n.push(o[s])
				}
			}
			for (var r = [], o = [], a = 0, s = 0, l = 0; l < e.length && n++ < 1e4; ++l) {
				var u = xp(e[l]);
				if (function(t) {
						return t === xp(t)
					}(e[l]) && (i(e[l], r[r.length - 1] || [], o), u !== (e[l + 1] ? xp(e[l + 1]) :
						null))) {
					if (o.length) {
						s = a, o.sort(function(t, e) {
							return t.value - e.value
						});
						for (var h = [], c = 0; c < o.length; ++c) {
							var p = o[c].value;
							0 !== c && o[c - 1].value === p || (h.push(o[c]), p >= M[0] && p <= M[1] &&
								a++)
						}
						u = (M[1] - M[0]) / b;
						if (1.5 * u < a && u / 1.5 < s) break;
						if (r.push(h), u < a || t === e[l]) break
					}
					o = []
				}
			}
			var d = ct(F(r, function(t) {
					return ct(t, function(t) {
						return t.value >= M[0] && t.value <= M[1] && !t.notAdd
					})
				}), function(t) {
					return 0 < t.length
				}),
				f = [],
				g = d.length - 1;
			for (l = 0; l < d.length; ++l)
				for (var y = d[l], m = 0; m < y.length; ++m) f.push({
					value: y[m].value,
					level: g - l
				});
			f.sort(function(t, e) {
				return t.value - e.value
			});
			var v = [];
			for (l = 0; l < f.length; ++l) 0 !== l && f[l].value === f[l - 1].value || v.push(f[l]);
			return v
		}(this._minLevelUnit, this._approxInterval, t, e), (n = n.concat(t)).push({
			value: e[1],
			level: 0
		})), n
	}, C_.prototype.calcNiceExtent = function(t) {
		var e, n = this._extent;
		n[0] === n[1] && (n[0] -= dp, n[1] += dp), n[1] === -1 / 0 && n[0] === 1 / 0 && (e = new Date, n[1] = +
			new Date(e.getFullYear(), e.getMonth(), e.getDate()), n[0] = n[1] - dp), this.calcNiceTicks(t
			.splitNumber, t.minInterval, t.maxInterval)
	}, C_.prototype.calcNiceTicks = function(t, e, n) {
		var i = this._extent,
			i = i[1] - i[0],
			i = (this._approxInterval = i / (t = t || 10), null != e && this._approxInterval < e && (this
					._approxInterval = e), null != n && this._approxInterval > n && (this._approxInterval = n),
				T_.length),
			t = Math.min(function(t, e, n, i) {
				for (; n < i;) {
					var r = n + i >>> 1;
					t[r][1] < e ? n = 1 + r : i = r
				}
				return n
			}(T_, this._approxInterval, 0, i), i - 1);
		this._interval = T_[t][1], this._minLevelUnit = T_[Math.max(t - 1, 0)][0]
	}, C_.prototype.parse = function(t) {
		return G(t) ? t : +So(t)
	}, C_.prototype.contain = function(t) {
		return n_(this.parse(t), this._extent)
	}, C_.prototype.normalize = function(t) {
		return i_(this.parse(t), this._extent)
	}, C_.prototype.scale = function(t) {
		return r_(t, this._extent)
	}, C_.type = "time";
	var S_, M_ = C_,
		T_ = [
			["second", hp],
			["minute", cp],
			["hour", pp],
			["quarter-day", 6 * pp],
			["half-day", 12 * pp],
			["day", 1.2 * dp],
			["half-week", 3.5 * dp],
			["week", 7 * dp],
			["month", 31 * dp],
			["quarter", 95 * dp],
			["half-year", aa / 2],
			["year", aa]
		];

	function C_(t) {
		t = S_.call(this, t) || this;
		return t.type = "time", t
	}

	function I_(t, e) {
		return 30 < (t /= e ? cp : hp) ? 30 : 20 < t ? 20 : 15 < t ? 15 : 10 < t ? 10 : 5 < t ? 5 : 2 < t ? 2 : 1
	}
	Xv.registerClass(M_);
	var k_, D_ = Xv.prototype,
		A_ = h_.prototype,
		P_ = go,
		L_ = Math.floor,
		O_ = Math.ceil,
		R_ = Math.pow,
		N_ = Math.log,
		E_ = (u(z_, k_ = Xv), z_.prototype.getTicks = function(t) {
			var e = this._originalScale,
				n = this._extent,
				i = e.getExtent();
			return F(A_.getTicks.call(this, t), function(t) {
				var t = t.value,
					e = go(R_(this.base, t)),
					e = t === n[0] && this._fixMin ? B_(e, i[0]) : e;
				return {
					value: t === n[1] && this._fixMax ? B_(e, i[1]) : e
				}
			}, this)
		}, z_.prototype.setExtent = function(t, e) {
			var n = N_(this.base);
			t = N_(Math.max(0, t)) / n, e = N_(Math.max(0, e)) / n, A_.setExtent.call(this, t, e)
		}, z_.prototype.getExtent = function() {
			var t = this.base,
				e = D_.getExtent.call(this),
				t = (e[0] = R_(t, e[0]), e[1] = R_(t, e[1]), this._originalScale.getExtent());
			return this._fixMin && (e[0] = B_(e[0], t[0])), this._fixMax && (e[1] = B_(e[1], t[1])), e
		}, z_.prototype.unionExtent = function(t) {
			this._originalScale.unionExtent(t);
			var e = this.base;
			t[0] = N_(t[0]) / N_(e), t[1] = N_(t[1]) / N_(e), D_.unionExtent.call(this, t)
		}, z_.prototype.unionExtentFromData = function(t, e) {
			this.unionExtent(t.getApproximateExtent(e))
		}, z_.prototype.calcNiceTicks = function(t) {
			t = t || 10;
			var e = this._extent,
				n = e[1] - e[0];
			if (!(n == 1 / 0 || n <= 0)) {
				var i = Mo(n);
				for (t / n * i <= .5 && (i *= 10); !isNaN(i) && Math.abs(i) < 1 && 0 < Math.abs(i);) i *= 10;
				t = [go(O_(e[0] / i) * i), go(L_(e[1] / i) * i)];
				this._interval = i, this._niceExtent = t
			}
		}, z_.prototype.calcNiceExtent = function(t) {
			A_.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax
		}, z_.prototype.parse = function(t) {
			return t
		}, z_.prototype.contain = function(t) {
			return n_(t = N_(t) / N_(this.base), this._extent)
		}, z_.prototype.normalize = function(t) {
			return i_(t = N_(t) / N_(this.base), this._extent)
		}, z_.prototype.scale = function(t) {
			return t = r_(t, this._extent), R_(this.base, t)
		}, z_.type = "log", z_),
		am = E_.prototype;

	function z_() {
		var t = null !== k_ && k_.apply(this, arguments) || this;
		return t.type = "log", t.base = 10, t._originalScale = new h_, t._interval = 0, t
	}

	function B_(t, e) {
		return P_(t, yo(e))
	}
	am.getMinorTicks = A_.getMinorTicks, am.getLabel = A_.getLabel, Xv.registerClass(E_);
	V_.prototype._prepareParams = function(t, e, n) {
		n[1] < n[0] && (n = [NaN, NaN]), this._dataMin = n[0], this._dataMax = n[1];
		var i = this._isOrdinal = "ordinal" === t.type,
			r = (this._needCrossZero = "interval" === t.type && e.getNeedCrossZero && e.getNeedCrossZero(), this
				._modelMinRaw = e.get("min", !0)),
			r = (S(r) ? this._modelMinNum = W_(t, r({
				min: n[0],
				max: n[1]
			})) : "dataMin" !== r && (this._modelMinNum = W_(t, r)), this._modelMaxRaw = e.get("max", !0));
		S(r) ? this._modelMaxNum = W_(t, r({
				min: n[0],
				max: n[1]
			})) : "dataMax" !== r && (this._modelMaxNum = W_(t, r)), i ? this._axisDataLen = e.getCategories()
			.length : "boolean" == typeof(t = V(n = e.get("boundaryGap")) ? n : [n || 0, n || 0])[0] ||
			"boolean" == typeof t[1] ? this._boundaryGapInner = [0, 0] : this._boundaryGapInner = [Gr(t[0], 1),
				Gr(t[1], 1)
			]
	}, V_.prototype.calculate = function() {
		var t = this._isOrdinal,
			e = this._dataMin,
			n = this._dataMax,
			i = this._axisDataLen,
			r = this._boundaryGapInner,
			o = t ? null : n - e || Math.abs(e),
			a = "dataMin" === this._modelMinRaw ? e : this._modelMinNum,
			s = "dataMax" === this._modelMaxRaw ? n : this._modelMaxNum,
			l = null != a,
			u = null != s,
			e = (null == a && (a = t ? i ? 0 : NaN : e - r[0] * o), null == s && (s = t ? i ? i - 1 : NaN : n +
				r[1] * o), null != a && isFinite(a) || (a = NaN), null != s && isFinite(s) || (s = NaN), wt(
				a) || wt(s) || t && !i),
			n = (this._needCrossZero && (a = 0 < a && 0 < s && !l ? 0 : a) < 0 && s < 0 && !u && (s = 0), this
				._determinedMin),
			r = this._determinedMax;
		return null != n && (a = n, l = !0), null != r && (s = r, u = !0), {
			min: a,
			max: s,
			minFixed: l,
			maxFixed: u,
			isBlank: e
		}
	}, V_.prototype.modifyDataMinMax = function(t, e) {
		this[G_[t]] = e
	}, V_.prototype.setDeterminedMinMax = function(t, e) {
		this[H_[t]] = e
	}, V_.prototype.freeze = function() {
		this.frozen = !0
	};
	var F_ = V_;

	function V_(t, e, n) {
		this._prepareParams(t, e, n)
	}
	var H_ = {
			min: "_determinedMin",
			max: "_determinedMax"
		},
		G_ = {
			min: "_dataMin",
			max: "_dataMax"
		};

	function W_(t, e) {
		return null == e ? null : wt(e) ? NaN : t.parse(e)
	}

	function U_(t, e) {
		var n, i, r, o, a, s, l = t.type,
			u = (c = e, u = (h = t).getExtent(), (h.rawExtentInfo || (c = new F_(h, c, u), h.rawExtentInfo = c))
				.calculate()),
			h = (t.setBlank(u.isBlank), u.min),
			c = u.max,
			t = e.ecModel;
		return t && "time" === l && (l = v_("bar", t), n = !1, E(l, function(t) {
			n = n || t.getBaseAxis() === e.axis
		}), n) && (t = __(l), l = h, i = c, t = t, s = (s = (r = e).axis.getExtent())[1] - s[0], h = (t =
			void 0 === (t = function(t, e, n) {
				if (t && e) return null != (t = t[m_(e)]) && null != n ? t[y_(n)] : t
			}(t, r.axis)) ? {
				min: l,
				max: i
			} : (o = 1 / 0, E(t, function(t) {
				o = Math.min(t.offset, o)
			}), a = -1 / 0, E(t, function(t) {
				a = Math.max(t.offset + t.width, a)
			}), o = Math.abs(o), a = Math.abs(a), {
				min: l -= o / (r = o + a) * (s = (t = i - l) / (1 - (o + a) / s) - t),
				max: i += a / r * s
			})).min, c = t.max), {
			extent: [h, c],
			fixMin: u.minFixed,
			fixMax: u.maxFixed
		}
	}

	function X_(t, e) {
		var n = U_(t, e),
			i = n.extent,
			r = e.get("splitNumber"),
			o = (t instanceof E_ && (t.base = e.get("logBase")), t.type),
			a = e.get("interval"),
			o = "interval" === o || "time" === o;
		t.setExtent(i[0], i[1]), t.calcNiceExtent({
			splitNumber: r,
			fixMin: n.fixMin,
			fixMax: n.fixMax,
			minInterval: o ? e.get("minInterval") : null,
			maxInterval: o ? e.get("maxInterval") : null
		}), null != a && t.setInterval && t.setInterval(a)
	}

	function Y_(t, e) {
		if (e = e || t.get("type")) switch (e) {
			case "category":
				return new a_({
					ordinalMeta: t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(),
					extent: [1 / 0, -1 / 0]
				});
			case "time":
				return new M_({
					locale: t.ecModel.getLocaleModel(),
					useUTC: t.ecModel.get("useUTC")
				});
			default:
				return new(Xv.getClass(e) || h_)
		}
	}

	function q_(n) {
		var i, r, e, t = n.getLabelModel().get("formatter"),
			o = "category" === n.type ? n.scale.getExtent()[0] : null;
		return "time" === n.scale.type ? (r = t, function(t, e) {
			return n.scale.getFormattedLabel(t, e, r)
		}) : H(t) ? (e = t, function(t) {
			t = n.scale.getLabel(t);
			return e.replace("{value}", null != t ? t : "")
		}) : S(t) ? (i = t, function(t, e) {
			return null != o && (e = t.value - o), i(j_(n, t), e, null != t.level ? {
				level: t.level
			} : null)
		}) : function(t) {
			return n.scale.getLabel(t)
		}
	}

	function j_(t, e) {
		return "category" === t.type ? t.scale.getLabel(e) : e.value
	}

	function Z_(t) {
		var e, n, i, r = t.model,
			o = t.scale;
		if (r.get(["axisLabel", "show"]) && !o.isBlank()) {
			var a, s, l = o.getExtent(),
				u = o instanceof a_ ? o.count() : (a = o.getTicks()).length,
				h = t.getLabelModel(),
				c = q_(t),
				p = 1;
			40 < u && (p = Math.ceil(u / 40));
			for (var d = 0; d < u; d += p) {
				var f = c(a ? a[d] : {
						value: l[0] + d
					}, d),
					g = (f = h.getTextRect(f), e = h.get("rotate") || 0, n = i = g = n = void 0, e = e * Math.PI /
						180, n = f.width, g = f.height, i = n * Math.abs(Math.cos(e)) + Math.abs(g * Math.sin(e)),
						n = n * Math.abs(Math.sin(e)) + Math.abs(g * Math.cos(e)), new U(f.x, f.y, i, n));
				s ? s.union(g) : s = g
			}
			return s
		}
	}

	function K_(t) {
		t = t.get("interval");
		return null == t ? "auto" : t
	}

	function $_(t) {
		return "category" === t.type && 0 === K_(t.getLabelModel())
	}
	J_.prototype.getNeedCrossZero = function() {
		return !this.option.scale
	}, J_.prototype.getCoordSysModel = function() {};
	var Q_ = J_;

	function J_() {}
	var hm = Object.freeze({
			__proto__: null,
			createDimensions: function(t, e) {
				return zv(t, e).dimensions
			},
			createList: function(t) {
				return Uv(null, t)
			},
			createScale: function(t, e) {
				var n = e;
				return (e = Y_(n = e instanceof Qc ? n : new Qc(e))).setExtent(t[0], t[1]), X_(e, n), e
			},
			createSymbol: ym,
			createTextStyle: function(t, e) {
				return Lc(t, null, null, "normal" !== (e = e || {}).state)
			},
			dataStack: {
				isDimensionStacked: Gv,
				enableDataStack: Hv,
				getStackedDimension: Wv
			},
			enableHoverEmphasis: Jl,
			getECData: k,
			getLayoutRect: Qp,
			mixinAxisModelCommonMethods: function(t) {
				lt(t, Q_)
			}
		}),
		t1 = [],
		e1 = {
			registerPreprocessor: j0,
			registerProcessor: Z0,
			registerPostInit: K0,
			registerPostUpdate: $0,
			registerUpdateLifecycle: Q0,
			registerAction: J0,
			registerCoordinateSystem: tv,
			registerLayout: ev,
			registerVisual: nv,
			registerTransform: sv,
			registerLoading: ov,
			registerMap: av,
			registerImpl: function(t, e) {
				Zm[t] = e
			},
			PRIORITY: um,
			ComponentModel: g,
			ComponentView: uy,
			SeriesModel: ey,
			ChartView: fy,
			registerComponentModel: function(t) {
				g.registerClass(t)
			},
			registerComponentView: function(t) {
				uy.registerClass(t)
			},
			registerSeriesModel: function(t) {
				ey.registerClass(t)
			},
			registerChartView: function(t) {
				fy.registerClass(t)
			},
			registerSubTypeDefaulter: function(t, e) {
				g.registerSubTypeDefaulter(t, e)
			},
			registerPainter: function(t, e) {
				uo(t, e)
			}
		};

	function n1(t) {
		V(t) ? E(t, function(t) {
			n1(t)
		}) : 0 <= I(t1, t) || (t1.push(t), (t = S(t) ? {
			install: t
		} : t).install(e1))
	}
	var i1 = 1e-8;

	function r1(t, e) {
		return Math.abs(t - e) < i1
	}

	function o1(t, e, n) {
		var i = 0,
			r = t[0];
		if (r) {
			for (var o = 1; o < t.length; o++) {
				var a = t[o];
				i += ys(r[0], r[1], a[0], a[1], e, n), r = a
			}
			var s = t[0];
			return r1(r[0], s[0]) && r1(r[1], s[1]) || (i += ys(r[0], r[1], s[0], s[1], e, n)), 0 !== i
		}
	}
	var a1 = [];

	function s1(t, e) {
		for (var n = 0; n < t.length; n++) ne(t[n], t[n], e)
	}

	function l1(t, e, n, i) {
		for (var r = 0; r < t.length; r++) {
			var o = t[r];
			(o = i ? i.project(o) : o) && isFinite(o[0]) && isFinite(o[1]) && (ie(e, e, o), re(n, n, o))
		}
	}
	u1.prototype.setCenter = function(t) {
		this._center = t
	}, u1.prototype.getCenter = function() {
		return this._center || (this._center = this.calcCenter())
	};
	cm = u1;

	function u1(t) {
		this.name = t
	}

	function h1(t, e) {
		this.type = "polygon", this.exterior = t, this.interiors = e
	}

	function c1(t) {
		this.type = "linestring", this.points = t
	}
	u(g1, p1 = cm), g1.prototype.calcCenter = function() {
		for (var t, e, n = this.geometries, i = 0, r = 0; r < n.length; r++) {
			var o = n[r],
				a = o.exterior,
				a = a && a.length;
			i < a && (t = o, i = a)
		}
		if (t) {
			for (var s = t.exterior, l = 0, u = 0, h = 0, c = s.length, p = s[c - 1][0], d = s[c - 1][1], f =
					0; f < c; f++) {
				var g = s[f][0],
					y = s[f][1],
					m = p * y - g * d;
				l += m, u += (p + g) * m, h += (d + y) * m, p = g, d = y
			}
			return l ? [u / l / 3, h / l / 3, l] : [s[0][0] || 0, s[0][1] || 0]
		}
		return [(e = this.getBoundingRect()).x + e.width / 2, e.y + e.height / 2]
	}, g1.prototype.getBoundingRect = function(e) {
		var n, i, t = this._rect;
		return t && !e || (n = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0], E(this.geometries, function(t) {
			"polygon" === t.type ? l1(t.exterior, n, i, e) : E(t.points, function(t) {
				l1(t, n, i, e)
			})
		}), isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1]) || (n[0] = n[1] = i[
			0] = i[1] = 0), t = new U(n[0], n[1], i[0] - n[0], i[1] - n[1]), e) || (this._rect = t), t
	}, g1.prototype.contain = function(t) {
		var e = this.getBoundingRect(),
			n = this.geometries;
		if (e.contain(t[0], t[1])) t: for (var i = 0, r = n.length; i < r; i++) {
			var o = n[i];
			if ("polygon" === o.type) {
				var a = o.exterior,
					s = o.interiors;
				if (o1(a, t[0], t[1])) {
					for (var l = 0; l < (s ? s.length : 0); l++)
						if (o1(s[l], t[0], t[1])) continue t;
					return !0
				}
			}
		}
		return !1
	}, g1.prototype.transformTo = function(t, e, n, i) {
		var r = this.getBoundingRect(),
			o = r.width / r.height;
		n ? i = i || n / o : n = o * i;
		for (var o = new U(t, e, n, i), a = r.calculateTransform(o), s = this.geometries, l = 0; l < s
			.length; l++) {
			var u = s[l];
			"polygon" === u.type ? (s1(u.exterior, a), E(u.interiors, function(t) {
				s1(t, a)
			})) : E(u.points, function(t) {
				s1(t, a)
			})
		}(r = this._rect).copy(o), this._center = [r.x + r.width / 2, r.y + r.height / 2]
	}, g1.prototype.cloneShallow = function(t) {
		t = new g1(t = null == t ? this.name : t, this.geometries, this._center);
		return t._rect = this._rect, t.transformTo = null, t
	};
	var p1, d1, f1 = g1;

	function g1(t, e, n) {
		t = p1.call(this, t) || this;
		return t.type = "geoJSON", t.geometries = e, t._center = n && [n[0], n[1]], t
	}

	function y1(t, e) {
		t = d1.call(this, t) || this;
		return t.type = "geoSVG", t._elOnlyForCalculate = e, t
	}

	function m1(t, e, n) {
		for (var i = 0; i < t.length; i++) t[i] = v1(t[i], e[i], n)
	}

	function v1(t, e, n) {
		for (var i = [], r = e[0], o = e[1], a = 0; a < t.length; a += 2) {
			var s = (s = t.charCodeAt(a) - 64) >> 1 ^ -(1 & s),
				l = (l = t.charCodeAt(a + 1) - 64) >> 1 ^ -(1 & l),
				r = s += r,
				o = l += o;
			i.push([s / n, l / n])
		}
		return i
	}

	function _1(t, o) {
		return F(ct((t = (e = t).UTF8Encoding ? (null == (r = (n = e).UTF8Scale) && (r = 1024), E(n.features,
			function(t) {
				var e = t.geometry,
					n = e.encodeOffsets,
					i = e.coordinates;
				if (n) switch (e.type) {
					case "LineString":
						e.coordinates = v1(i, n, r);
						break;
					case "Polygon":
					case "MultiLineString":
						m1(i, n, r);
						break;
					case "MultiPolygon":
						E(i, function(t, e) {
							return m1(t, n[e], r)
						})
				}
			}), n.UTF8Encoding = !1, n) : e).features, function(t) {
			return t.geometry && t.properties && 0 < t.geometry.coordinates.length
		}), function(t) {
			var e = t.properties,
				n = t.geometry,
				i = [];
			switch (n.type) {
				case "Polygon":
					var r = n.coordinates;
					i.push(new h1(r[0], r.slice(1)));
					break;
				case "MultiPolygon":
					E(n.coordinates, function(t) {
						t[0] && i.push(new h1(t[0], t.slice(1)))
					});
					break;
				case "LineString":
					i.push(new c1([n.coordinates]));
					break;
				case "MultiLineString":
					i.push(new c1(n.coordinates))
			}
			t = new f1(e[o || "name"], i, e.cp);
			return t.properties = e, t
		});
		var e, n, r
	}
	u(y1, d1 = cm), y1.prototype.calcCenter = function() {
		for (var t = this._elOnlyForCalculate, e = t.getBoundingRect(), e = [e.x + e.width / 2, e.y + e.height /
				2
			], n = Re(a1), i = t; i && !i.isGeoSVGGraphicRoot;) Ee(n, i.getLocalTransform(), n), i = i.parent;
		return Ve(n, n), ne(e, e, n), e
	};
	var pa = Object.freeze({
			__proto__: null,
			MAX_SAFE_INTEGER: 9007199254740991,
			asc: function(t) {
				return t.sort(function(t, e) {
					return t - e
				}), t
			},
			getPercentWithPrecision: function(t, e, n) {
				return t[e] && _o(t, n)[e] || 0
			},
			getPixelPrecision: vo,
			getPrecision: yo,
			getPrecisionSafe: mo,
			isNumeric: ko,
			isRadianAroundZero: wo,
			linearMap: po,
			nice: Co,
			numericToNumber: Io,
			parseDate: So,
			quantile: function(t, e) {
				var e = (t.length - 1) * e + 1,
					n = Math.floor(e),
					i = +t[n - 1];
				return (e = e - n) ? i + e * (t[n] - i) : i
			},
			quantity: Mo,
			quantityExponent: To,
			reformIntervals: function(t) {
				t.sort(function(t, e) {
					return function t(e, n, i) {
						return e.interval[i] < n.interval[i] || e.interval[i] === n.interval[
							i] && (e.close[i] - n.close[i] == (i ? -1 : 1) || !i && t(e, n,
							1))
					}(t, e, 0) ? -1 : 1
				});
				for (var e = -1 / 0, n = 1, i = 0; i < t.length;) {
					for (var r = t[i].interval, o = t[i].close, a = 0; a < 2; a++) r[a] <= e && (r[a] = e,
						o[a] = a ? 1 : 1 - n), e = r[a], n = o[a];
					r[0] === r[1] && o[0] * o[1] != 1 ? t.splice(i, 1) : i++
				}
				return t
			},
			remRadian: xo,
			round: go
		}),
		fc = Object.freeze({
			__proto__: null,
			format: wp,
			parse: So
		}),
		gp = Object.freeze({
			__proto__: null,
			Arc: Mh,
			BezierCurve: xh,
			BoundingRect: U,
			Circle: Du,
			CompoundPath: Ih,
			Ellipse: Ou,
			Group: no,
			Image: Es,
			IncrementalDisplayable: n,
			Line: fh,
			LinearGradient: Lh,
			Polygon: oh,
			Polyline: uh,
			RadialGradient: Dh,
			Rect: Xs,
			Ring: th,
			Sector: Ku,
			Text: Ks,
			clipPointsByRect: _c,
			clipRectByRect: xc,
			createIcon: wc,
			extendPath: oc,
			extendShape: ic,
			getShapeClass: sc,
			getTransform: gc,
			initProps: jh,
			makeImage: uc,
			makePath: lc,
			mergePath: cc,
			registerShape: ac,
			resizePath: pc,
			updateProps: qh
		}),
		qc = Object.freeze({
			__proto__: null,
			addCommas: zp,
			capitalFirst: function(t) {
				return t && t.charAt(0).toUpperCase() + t.substr(1)
			},
			encodeHTML: xe,
			formatTime: function(t, e, n) {
				"week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (
					t = "MM-dd\nyyyy");
				var i = (e = So(e))[(n = n ? "getUTC" : "get") + "FullYear"](),
					r = e[n + "Month"]() + 1,
					o = e[n + "Date"](),
					a = e[n + "Hours"](),
					s = e[n + "Minutes"](),
					l = e[n + "Seconds"](),
					e = e[n + "Milliseconds"]();
				return t.replace("MM", _p(r, 2)).replace("M", r).replace("yyyy", i).replace("yy", _p(i %
						100 + "", 2)).replace("dd", _p(o, 2)).replace("d", o).replace("hh", _p(a, 2))
					.replace("h", a).replace("mm", _p(s, 2)).replace("m", s).replace("ss", _p(l, 2))
					.replace("s", l).replace("SSS", _p(e, 3))
			},
			formatTpl: Wp,
			getTextRect: function(t, e, n, i, r, o, a, s) {
				return new Ks({
					style: {
						text: t,
						font: e,
						align: n,
						verticalAlign: i,
						padding: r,
						rich: o,
						overflow: a ? "truncate" : null,
						lineHeight: s
					}
				}).getBoundingRect()
			},
			getTooltipMarker: Up,
			normalizeCssArray: Fp,
			toCamelCase: Bp,
			truncateText: _a
		}),
		Wc = Object.freeze({
			__proto__: null,
			bind: pt,
			clone: _,
			curry: dt,
			defaults: B,
			each: E,
			extend: O,
			filter: ct,
			indexOf: I,
			inherits: st,
			isArray: V,
			isFunction: S,
			isObject: L,
			isString: H,
			map: F,
			merge: d,
			reduce: ht
		}),
		x1 = Yo();

	function w1(t) {
		return "category" === t.type ? (r = (e = t).getLabelModel(), o = S1(e, r), !r.get("show") || e.scale
			.isBlank() ? {
				labels: [],
				labelCategoryInterval: o.labelCategoryInterval
			} : o) : (r = (n = t).scale.getTicks(), i = q_(n), {
			labels: F(r, function(t, e) {
				return {
					level: t.level,
					formattedLabel: i(t, e),
					rawLabel: n.scale.getLabel(t),
					tickValue: t.value
				}
			})
		});
		var n, i, e, r, o
	}

	function b1(t, e) {
		var n, i, r, o, a, s;
		return "category" === t.type ? (e = e, o = M1(n = t, "ticks"), a = K_(e), (s = T1(o, a)) || (e.get(
			"show") && !n.scale.isBlank() || (i = []), i = S(a) ? k1(n, a, !0) : "auto" === a ? (s = S1(
			n, n
			.getLabelModel()), r = s.labelCategoryInterval, F(s.labels, function(t) {
			return t.tickValue
		})) : I1(n, r = a, !0), C1(o, a, {
			ticks: i,
			tickCategoryInterval: r
		}))) : {
			ticks: F(t.scale.getTicks(), function(t) {
				return t.value
			})
		}
	}

	function S1(t, e) {
		var n, i = M1(t, "labels"),
			e = K_(e);
		return T1(i, e) || C1(i, e, {
			labels: S(e) ? k1(t, e) : I1(t, n = "auto" === e ? null != (t = x1(i = t).autoInterval) ? t :
				x1(i).autoInterval = i.calculateCategoryInterval() : e),
			labelCategoryInterval: n
		})
	}

	function M1(t, e) {
		return x1(t)[e] || (x1(t)[e] = [])
	}

	function T1(t, e) {
		for (var n = 0; n < t.length; n++)
			if (t[n].key === e) return t[n].value
	}

	function C1(t, e, n) {
		return t.push({
			key: e,
			value: n
		}), n
	}

	function I1(t, e, n) {
		var i = q_(t),
			r = t.scale,
			o = r.getExtent(),
			a = t.getLabelModel(),
			s = [],
			l = Math.max((e || 0) + 1, 1),
			e = o[0],
			u = r.count(),
			u = (0 !== e && 1 < l && 2 < u / l && (e = Math.round(Math.ceil(e / l) * l)), $_(t)),
			t = a.get("showMinLabel") || u,
			a = a.get("showMaxLabel") || u;
		t && e !== o[0] && c(o[0]);
		for (var h = e; h <= o[1]; h += l) c(h);

		function c(t) {
			var e = {
				value: t
			};
			s.push(n ? t : {
				formattedLabel: i(e),
				rawLabel: r.getLabel(e),
				tickValue: t
			})
		}
		return a && h - l !== o[1] && c(o[1]), s
	}

	function k1(t, i, r) {
		var o = t.scale,
			a = q_(t),
			s = [];
		return E(o.getTicks(), function(t) {
			var e = o.getLabel(t),
				n = t.value;
			i(t.value, e) && s.push(r ? n : {
				formattedLabel: a(t),
				rawLabel: e,
				tickValue: n
			})
		}), s
	}
	var D1 = [0, 1],
		Zc = (A1.prototype.contain = function(t) {
			var e = this._extent,
				n = Math.min(e[0], e[1]),
				e = Math.max(e[0], e[1]);
			return n <= t && t <= e
		}, A1.prototype.containData = function(t) {
			return this.scale.contain(t)
		}, A1.prototype.getExtent = function() {
			return this._extent.slice()
		}, A1.prototype.getPixelPrecision = function(t) {
			return vo(t || this.scale.getExtent(), this._extent)
		}, A1.prototype.setExtent = function(t, e) {
			var n = this._extent;
			n[0] = t, n[1] = e
		}, A1.prototype.dataToCoord = function(t, e) {
			var n = this._extent,
				i = this.scale;
			return t = i.normalize(t), this.onBand && "ordinal" === i.type && P1(n = n.slice(), i.count()), po(
				t, D1, n, e)
		}, A1.prototype.coordToData = function(t, e) {
			var n = this._extent,
				i = this.scale,
				i = (this.onBand && "ordinal" === i.type && P1(n = n.slice(), i.count()), po(t, n, D1, e));
			return this.scale.scale(i)
		}, A1.prototype.pointToData = function(t, e) {}, A1.prototype.getTicksCoords = function(t) {
			var e, n, i, r, o = (t = t || {}).tickModel || this.getTickModel(),
				a = F(b1(this, o).ticks, function(t) {
					return {
						coord: this.dataToCoord("ordinal" === this.scale.type ? this.scale
							.getRawOrdinalNumber(t) : t),
						tickValue: t
					}
				}, this),
				s = this,
				l = a,
				o = o.get("alignWithLabel"),
				t = t.clamp,
				u = l.length;

			function h(t, e) {
				return t = go(t), e = go(e), r ? e < t : t < e
			}
			return s.onBand && !o && u && (o = s.getExtent(), 1 === u ? (l[0].coord = o[0], e = l[1] = {
					coord: o[1]
				}) : (n = l[u - 1].tickValue - l[0].tickValue, i = (l[u - 1].coord - l[0].coord) / n, E(l,
					function(t) {
						t.coord -= i / 2
					}), n = 1 + s.scale.getExtent()[1] - l[u - 1].tickValue, e = {
					coord: l[u - 1].coord + i * n
				}, l.push(e)), r = o[0] > o[1], h(l[0].coord, o[0]) && (t ? l[0].coord = o[0] : l.shift()),
				t && h(o[0], l[0].coord) && l.unshift({
					coord: o[0]
				}), h(o[1], e.coord) && (t ? e.coord = o[1] : l.pop()), t) && h(e.coord, o[1]) && l.push({
				coord: o[1]
			}), a
		}, A1.prototype.getMinorTicksCoords = function() {
			var t;
			return "ordinal" === this.scale.type ? [] : (t = this.model.getModel("minorTick").get(
				"splitNumber"), F(this.scale.getMinorTicks(t = 0 < t && t < 100 ? t : 5), function(t) {
				return F(t, function(t) {
					return {
						coord: this.dataToCoord(t),
						tickValue: t
					}
				}, this)
			}, this))
		}, A1.prototype.getViewLabels = function() {
			return w1(this).labels
		}, A1.prototype.getLabelModel = function() {
			return this.model.getModel("axisLabel")
		}, A1.prototype.getTickModel = function() {
			return this.model.getModel("axisTick")
		}, A1.prototype.getBandWidth = function() {
			var t = this._extent,
				e = this.scale.getExtent(),
				e = e[1] - e[0] + (this.onBand ? 1 : 0),
				t = (0 === e && (e = 1), Math.abs(t[1] - t[0]));
			return Math.abs(t) / e
		}, A1.prototype.calculateCategoryInterval = function() {
			r = (n = d = this).getLabelModel();
			var t = {
					axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0,
					labelRotate: r.get("rotate") || 0,
					font: r.getFont()
				},
				e = q_(d),
				n = (t.axisRotate - t.labelRotate) / 180 * Math.PI,
				i = (r = d.scale).getExtent(),
				r = r.count();
			if (i[1] - i[0] < 1) return 0;
			var o = 1;
			40 < r && (o = Math.max(1, Math.floor(r / 40)));
			for (var a = i[0], s = d.dataToCoord(a + 1) - d.dataToCoord(a), l = Math.abs(s * Math.cos(n)), s =
					Math.abs(s * Math.sin(n)), u = 0, h = 0; a <= i[1]; a += o) var c = 1.3 * (p = Br(e({
					value: a
				}), t.font, "center", "top")).width,
				p = 1.3 * p.height,
				u = Math.max(u, c, 7),
				h = Math.max(h, p, 7);
			var n = u / l,
				l = h / s,
				s = (isNaN(n) && (n = 1 / 0), isNaN(l) && (l = 1 / 0), Math.max(0, Math.floor(Math.min(n, l)))),
				n = x1(d.model),
				l = d.getExtent(),
				d = n.lastAutoInterval,
				f = n.lastTickCount;
			return null != d && null != f && Math.abs(d - s) <= 1 && Math.abs(f - r) <= 1 && s < d && n
				.axisExtent0 === l[0] && n.axisExtent1 === l[1] ? s = d : (n.lastTickCount = r, n
					.lastAutoInterval = s, n.axisExtent0 = l[0], n.axisExtent1 = l[1]), s
		}, A1);

	function A1(t, e, n) {
		this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = e, this._extent = n || [0, 0]
	}

	function P1(t, e) {
		e = (t[1] - t[0]) / e / 2;
		t[0] += e, t[1] -= e
	}
	var L1 = 2 * Math.PI,
		O1 = cs.CMD,
		R1 = ["top", "right", "bottom", "left"];

	function N1(t, e, n, i, r, o, a, s) {
		var l = r - t,
			u = o - e,
			n = n - t,
			i = i - e,
			h = Math.sqrt(n * n + i * i),
			l = (l * (n /= h) + u * (i /= h)) / h,
			u = (s && (l = Math.min(Math.max(l, 0), 1)), a[0] = t + (l *= h) * n),
			s = a[1] = e + l * i;
		return Math.sqrt((u - r) * (u - r) + (s - o) * (s - o))
	}

	function E1(t, e, n, i, r, o, a) {
		n < 0 && (t += n, n = -n), i < 0 && (e += i, i = -i);
		n = t + n, i = e + i, t = a[0] = Math.min(Math.max(r, t), n), n = a[1] = Math.min(Math.max(o, e), i);
		return Math.sqrt((t - r) * (t - r) + (n - o) * (n - o))
	}
	var z1 = [];

	function B1(t, e, n) {
		for (var i, r, o, a, s, l, u, h, c, p = 0, d = 0, f = 0, g = 0, y = 1 / 0, m = e.data, v = t.x, _ = t.y, x =
				0; x < m.length;) {
			var w = m[x++],
				b = (1 === x && (f = p = m[x], g = d = m[x + 1]), y);
			switch (w) {
				case O1.M:
					p = f = m[x++], d = g = m[x++];
					break;
				case O1.L:
					b = N1(p, d, m[x], m[x + 1], v, _, z1, !0), p = m[x++], d = m[x++];
					break;
				case O1.C:
					b = Gn(p, d, m[x++], m[x++], m[x++], m[x++], m[x], m[x + 1], v, _, z1), p = m[x++], d = m[x++];
					break;
				case O1.Q:
					b = qn(p, d, m[x++], m[x++], m[x], m[x + 1], v, _, z1), p = m[x++], d = m[x++];
					break;
				case O1.A:
					var S = m[x++],
						M = m[x++],
						T = m[x++],
						C = m[x++],
						I = m[x++],
						k = m[x++],
						D = (x += 1, !!(1 - m[x++])),
						A = Math.cos(I) * T + S,
						P = Math.sin(I) * C + M;
					x <= 1 && (f = A, g = P), P = (A = I) + k, D = D, a = (v - (i = S)) * (o = C) / T + S, s = _,
						l = z1, c = h = u = void 0, a -= i, s -= r = M, u = Math.sqrt(a * a + s * s), h = (a /= u) *
						o + i, c = (s /= u) * o + r, b = Math.abs(A - P) % L1 < 1e-4 || ((P = D ? (D = A, A = fs(P),
							fs(D)) : (A = fs(A), fs(P))) < A && (P += L1), (D = Math.atan2(s, a)) < 0 && (D +=
							L1), A <= D && D <= P) || A <= D + L1 && D + L1 <= P ? (l[0] = h, l[1] = c, u - o) : (
							c = ((D = o * Math.cos(A) + i) - a) * (D - a) + ((h = o * Math.sin(A) + r) - s) * (h -
								s)) < (i = ((u = o * Math.cos(P) + i) - a) * (u - a) + ((A = o * Math.sin(P) + r) -
							s) * (A - s)) ? (l[0] = D, l[1] = h, Math.sqrt(c)) : (l[0] = u, l[1] = A, Math.sqrt(i)),
						p = Math.cos(I + k) * T + S, d = Math.sin(I + k) * C + M;
					break;
				case O1.R:
					b = E1(f = p = m[x++], g = d = m[x++], m[x++], m[x++], v, _, z1);
					break;
				case O1.Z:
					b = N1(p, d, f, g, v, _, z1, !0), p = f, d = g
			}
			b < y && (y = b, n.set(z1[0], z1[1]))
		}
		return y
	}
	var F1 = new W,
		V1 = new W,
		H1 = new W,
		G1 = new W,
		W1 = new W;

	function U1(t, e) {
		if (t) {
			var n = t.getTextGuideLine(),
				i = t.getTextContent();
			if (i && n) {
				var r = t.textGuideLineConfig || {},
					o = [
						[0, 0],
						[0, 0],
						[0, 0]
					],
					a = r.candidates || R1,
					s = i.getBoundingRect().clone(),
					l = (s.applyTransform(i.getComputedTransform()), 1 / 0),
					u = r.anchor,
					h = t.getComputedTransform(),
					c = h && Ve([], h),
					p = e.get("length2") || 0;
				u && H1.copy(u);
				for (var d = 0; d < a.length; d++) {
					x = _ = v = m = y = g = f = void 0;
					var f = a[d],
						g = 0,
						y = s,
						m = F1,
						v = G1,
						_ = y.width,
						x = y.height;
					switch (f) {
						case "top":
							m.set(y.x + _ / 2, y.y - g), v.set(0, -1);
							break;
						case "bottom":
							m.set(y.x + _ / 2, y.y + x + g), v.set(0, 1);
							break;
						case "left":
							m.set(y.x - g, y.y + x / 2), v.set(-1, 0);
							break;
						case "right":
							m.set(y.x + _ + g, y.y + x / 2), v.set(1, 0)
					}
					W.scaleAndAdd(V1, F1, G1, p), V1.transform(c);
					f = t.getBoundingRect(), f = u ? u.distance(V1) : t instanceof Z ? B1(V1, t.path, H1) : (b = H1,
						w = E1((w = f).x, f.y, f.width, f.height, V1.x, V1.y, z1), b.set(z1[0], z1[1]), w);
					f < l && (l = f, V1.transform(h), H1.transform(h), H1.toArray(o[0]), V1.toArray(o[1]), F1
						.toArray(o[2]))
				}
				q1(o, e.get("minTurnAngle")), n.setShape({
					points: o
				})
			}
		}
		var w, b
	}
	var X1 = [],
		Y1 = new W;

	function q1(t, e) {
		var n, i;
		e <= 180 && 0 < e && (e = e / 180 * Math.PI, F1.fromArray(t[0]), V1.fromArray(t[1]), H1.fromArray(t[2]), W
			.sub(G1, F1, V1), W.sub(W1, H1, V1), i = G1.len(), n = W1.len(), i < .001 || n < .001 || (G1.scale(
				1 / i), W1.scale(1 / n), i = G1.dot(W1), Math.cos(e) < i && (n = N1(V1.x, V1.y, H1.x, H1.y,
					F1.x, F1.y, X1, !1), Y1.fromArray(X1), Y1.scaleAndAdd(W1, n / Math.tan(Math.PI - e)),
				i = H1.x !== V1.x ? (Y1.x - V1.x) / (H1.x - V1.x) : (Y1.y - V1.y) / (H1.y - V1.y), isNaN(
					i) || (i < 0 ? W.copy(Y1, V1) : 1 < i && W.copy(Y1, H1), Y1.toArray(t[1])))))
	}

	function j1(t, e, n, i) {
		var r = "normal" === n,
			n = r ? t : t.ensureState(n),
			e = (n.ignore = e, i.get("smooth")),
			e = (e && !0 === e && (e = .3), n.shape = n.shape || {}, 0 < e && (n.shape.smooth = e), i.getModel(
				"lineStyle").getLineStyle());
		r ? t.useStyle(e) : n.style = e
	}

	function Z1(t, e) {
		var n = e.smooth,
			i = e.points;
		if (i)
			if (t.moveTo(i[0][0], i[0][1]), 0 < n && 3 <= i.length) {
				var e = Qt(i[0], i[1]),
					r = Qt(i[1], i[2]);
				e && r ? (n = Math.min(e, r) * n, e = ee([], i[1], i[0], n / e), n = ee([], i[1], i[2], n / r), r =
					ee([], e, n, .5), t.bezierCurveTo(e[0], e[1], e[0], e[1], r[0], r[1]), t.bezierCurveTo(n[0],
						n[1], n[0], n[1], i[2][0], i[2][1])) : (t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[
					2][1]))
			} else
				for (var o = 1; o < i.length; o++) t.lineTo(i[o][0], i[o][1])
	}

	function K1(t, e, n) {
		var i = t.getTextGuideLine(),
			r = t.getTextContent();
		if (r) {
			for (var o = e.normal, a = o.get("show"), s = r.ignore, l = 0; l < vl.length; l++) {
				var u, h = vl[l],
					c = e[h],
					p = "normal" === h;
				c && (u = c.get("show"), (p ? s : N(r.states[h] && r.states[h].ignore, s)) || !N(u, a) ? (u = p ?
					i : i && i.states[h]) && (u.ignore = !0) : (i || (i = new uh, t.setTextGuideLine(i),
					p || !s && a || j1(i, !0, "normal", e.normal), t.stateProxy && (i.stateProxy = t
						.stateProxy)), j1(i, !1, h, c)))
			}
			i && (B(i.style, n), i.style.fill = null, n = o.get("showAbove"), (t.textGuideLineConfig = t
				.textGuideLineConfig || {}).showAbove = n || !1, i.buildPath = Z1)
		} else i && t.removeTextGuideLine()
	}

	function $1(t, e) {
		for (var n = {
				normal: t.getModel(e = e || "labelLine")
			}, i = 0; i < ml.length; i++) {
			var r = ml[i];
			n[r] = t.getModel([r, e])
		}
		return n
	}

	function Q1(t) {
		for (var e = [], n = 0; n < t.length; n++) {
			var i, r, o, a, s, l, u = t[n];
			u.defaultAttr.ignore || (r = (i = u.label).getComputedTransform(), o = i.getBoundingRect(), a = !r || r[
					1] < 1e-5 && r[2] < 1e-5, l = i.style.margin || 0, (s = o.clone()).applyTransform(r), s.x -=
				l / 2, s.y -= l / 2, s.width += l, s.height += l, l = a ? new Vh(o, r) : null, e.push({
					label: i,
					labelLine: u.labelLine,
					rect: s,
					localRect: o,
					obb: l,
					priority: u.priority,
					defaultAttr: u.defaultAttr,
					layoutOption: u.computedLayoutOption,
					axisAligned: a,
					transform: r
				}))
		}
		return e
	}

	function J1(s, l, u, t, e, n) {
		var h = s.length;
		if (!(h < 2)) {
			s.sort(function(t, e) {
				return t.rect[l] - e.rect[l]
			});
			for (var i, r = 0, o = !1, a = [], c = 0, p = 0; p < h; p++) {
				var d = s[p],
					f = d.rect,
					d = ((i = f[l] - r) < 0 && (f[l] -= i, d.label[l] -= i, o = !0), Math.max(-i, 0));
				a.push(d), c += d, r = f[l] + f[u]
			}
			0 < c && n && w(-c / h, 0, h);
			var g, y, m = s[0],
				v = s[h - 1];
			return _(), g < 0 && b(-g, .8), y < 0 && b(y, .8), _(), x(g, y, 1), x(y, g, -1), _(), g < 0 && S(-g),
				y < 0 && S(y), o
		}

		function _() {
			g = m.rect[l] - t, y = e - v.rect[l] - v.rect[u]
		}

		function x(t, e, n) {
			t < 0 && (0 < (e = Math.min(e, -t)) ? (w(e * n, 0, h), (e = e + t) < 0 && b(-e * n, 1)) : b(-t * n, 1))
		}

		function w(t, e, n) {
			0 !== t && (o = !0);
			for (var i = e; i < n; i++) {
				var r = s[i];
				r.rect[l] += t, r.label[l] += t
			}
		}

		function b(t, e) {
			for (var n = [], i = 0, r = 1; r < h; r++) {
				var o = s[r - 1].rect,
					o = Math.max(s[r].rect[l] - o[l] - o[u], 0);
				n.push(o), i += o
			}
			if (i) {
				var a = Math.min(Math.abs(t) / i, e);
				if (0 < t)
					for (r = 0; r < h - 1; r++) w(n[r] * a, 0, r + 1);
				else
					for (r = h - 1; 0 < r; r--) w(-n[r - 1] * a, r, h)
			}
		}

		function S(t) {
			var e = t < 0 ? -1 : 1;
			t = Math.abs(t);
			for (var n = Math.ceil(t / (h - 1)), i = 0; i < h - 1; i++)
				if (0 < e ? w(n, 0, i + 1) : w(-n, h - i - 1, h), (t -= n) <= 0) return
		}
	}

	function tx(t, e, n, i) {
		return J1(t, "y", "height", e, n, i)
	}

	function ex(t) {
		var e = [],
			n = (t.sort(function(t, e) {
				return e.priority - t.priority
			}), new U(0, 0, 0, 0));

		function i(t) {
			var e;
			t.ignore || null == (e = t.ensureState("emphasis")).ignore && (e.ignore = !1), t.ignore = !0
		}
		for (var r = 0; r < t.length; r++) {
			var o = t[r],
				a = o.axisAligned,
				s = o.localRect,
				l = o.transform,
				u = o.label,
				h = o.labelLine;
			n.copy(o.rect), n.width -= .1, n.height -= .1, n.x += .05, n.y += .05;
			for (var c = o.obb, p = !1, d = 0; d < e.length; d++) {
				var f = e[d];
				if (n.intersect(f.rect)) {
					if (a && f.axisAligned) {
						p = !0;
						break
					}
					if (f.obb || (f.obb = new Vh(f.localRect, f.transform)), (c = c || new Vh(s, l)).intersect(f
							.obb)) {
						p = !0;
						break
					}
				}
			}
			p ? (i(u), h && i(h)) : (u.attr("ignore", o.defaultAttr.ignore), h && h.attr("ignore", o.defaultAttr
				.labelGuideIgnore), e.push(o))
		}
	}

	function nx(t, e) {
		var n = t.label,
			e = e && e.getTextGuideLine();
		return {
			dataIndex: t.dataIndex,
			dataType: t.dataType,
			seriesIndex: t.seriesModel.seriesIndex,
			text: t.label.style.text,
			rect: t.hostRect,
			labelRect: t.rect,
			align: n.style.align,
			verticalAlign: n.style.verticalAlign,
			labelLinePoints: function(t) {
				if (t) {
					for (var e = [], n = 0; n < t.length; n++) e.push(t[n].slice());
					return e
				}
			}(e && e.shape.points)
		}
	}
	var ix = ["align", "verticalAlign", "width", "height", "fontSize"],
		rx = new Pr,
		ox = Yo(),
		ax = Yo();

	function sx(t, e, n) {
		for (var i = 0; i < n.length; i++) {
			var r = n[i];
			null != e[r] && (t[r] = e[r])
		}
	}
	var lx = ["x", "y", "rotation"],
		ux = (hx.prototype.clearLabels = function() {
			this._labelList = [], this._chartViewList = []
		}, hx.prototype._addLabel = function(t, e, n, i, r) {
			var o = i.style,
				a = i.__hostTarget.textConfig || {},
				s = i.getComputedTransform(),
				l = i.getBoundingRect().plain();
			U.applyTransform(l, l, s), s ? rx.setLocalTransform(s) : (rx.x = rx.y = rx.rotation = rx.originX =
				rx.originY = 0, rx.scaleX = rx.scaleY = 1), rx.rotation = fs(rx.rotation);
			var u, s = i.__hostTarget,
				h = (s && (u = s.getBoundingRect().plain(), h = s.getComputedTransform(), U.applyTransform(u, u,
					h)), u && s.getTextGuideLine());
			this._labelList.push({
				label: i,
				labelLine: h,
				seriesModel: n,
				dataIndex: t,
				dataType: e,
				layoutOption: r,
				computedLayoutOption: null,
				rect: l,
				hostRect: u,
				priority: u ? u.width * u.height : 0,
				defaultAttr: {
					ignore: i.ignore,
					labelGuideIgnore: h && h.ignore,
					x: rx.x,
					y: rx.y,
					scaleX: rx.scaleX,
					scaleY: rx.scaleY,
					rotation: rx.rotation,
					style: {
						x: o.x,
						y: o.y,
						align: o.align,
						verticalAlign: o.verticalAlign,
						width: o.width,
						height: o.height,
						fontSize: o.fontSize
					},
					cursor: i.cursor,
					attachedPos: a.position,
					attachedRot: a.rotation
				}
			})
		}, hx.prototype.addLabelsOfSeries = function(t) {
			var n = this,
				i = (this._chartViewList.push(t), t.__model),
				r = i.get("labelLayout");
			(S(r) || R(r).length) && t.group.traverse(function(t) {
				if (t.ignore) return !0;
				var e = t.getTextContent(),
					t = k(t);
				e && !e.disableLabelLayout && n._addLabel(t.dataIndex, t.dataType, i, e, r)
			})
		}, hx.prototype.updateLayoutConfig = function(t) {
			var e = t.getWidth(),
				n = t.getHeight();
			for (var i = 0; i < this._labelList.length; i++) {
				var r = this._labelList[i],
					o = r.label,
					a = o.__hostTarget,
					s = r.defaultAttr,
					l = void 0,
					l = (S(r.layoutOption) ? r.layoutOption(nx(r, a)) : r.layoutOption) || {},
					u = (r.computedLayoutOption = l, Math.PI / 180),
					h = (a && a.setTextConfig({
						local: !1,
						position: null != l.x || null != l.y ? null : s.attachedPos,
						rotation: null != l.rotate ? l.rotate * u : s.attachedRot,
						offset: [l.dx || 0, l.dy || 0]
					}), !1);
				null != l.x ? (o.x = fo(l.x, e), o.setStyle("x", 0), h = !0) : (o.x = s.x, o.setStyle("x", s
						.style.x)), null != l.y ? (o.y = fo(l.y, n), o.setStyle("y", 0), h = !0) : (o.y = s.y, o
						.setStyle("y", s.style.y)), l.labelLinePoints && (c = a.getTextGuideLine()) && (c
						.setShape({
							points: l.labelLinePoints
						}), h = !1), ox(o).needsUpdateLabelLine = h, o.rotation = null != l.rotate ? l.rotate *
					u : s.rotation, o.scaleX = s.scaleX, o.scaleY = s.scaleY;
				for (var c, p = 0; p < ix.length; p++) {
					var d = ix[p];
					o.setStyle(d, (null != l[d] ? l : s.style)[d])
				}
				l.draggable ? (o.draggable = !0, o.cursor = "move", a && (c = r.seriesModel, null != r
					.dataIndex && (c = r.seriesModel.getData(r.dataType).getItemModel(r.dataIndex)), o
					.on("drag", function(t, e) {
						return function() {
							U1(t, e)
						}
					}(a, c.getModel("labelLine"))))) : (o.off("drag"), o.cursor = s.cursor)
			}
		}, hx.prototype.layout = function(t) {
			var e, n = t.getWidth(),
				t = t.getHeight(),
				i = Q1(this._labelList),
				r = ct(i, function(t) {
					return "shiftX" === t.layoutOption.moveOverlap
				}),
				o = ct(i, function(t) {
					return "shiftY" === t.layoutOption.moveOverlap
				});
			J1(r, "x", "width", 0, n, e), tx(o, 0, t), ex(ct(i, function(t) {
				return t.layoutOption.hideOverlap
			}))
		}, hx.prototype.processLabelsOverall = function() {
			var a = this;
			E(this._chartViewList, function(t) {
				var i = t.__model,
					r = t.ignoreLabelLineUpdate,
					o = i.isAnimationEnabled();
				t.group.traverse(function(t) {
					if (t.ignore && !t.forceLabelAnimation) return !0;
					var e = !r,
						n = t.getTextContent();
					(e = !e && n ? ox(n).needsUpdateLabelLine : e) && a._updateLabelLine(t, i),
						o && a._animateLabels(t, i)
				})
			})
		}, hx.prototype._updateLabelLine = function(t, e) {
			var n = t.getTextContent(),
				i = k(t),
				r = i.dataIndex;
			n && null != r && (e = (n = e.getData(i.dataType)).getItemModel(r), i = {}, (r = n.getItemVisual(r,
				"style")) && (n = n.getVisual("drawType"), i.stroke = r[n]), r = e.getModel(
				"labelLine"), K1(t, $1(e), i), U1(t, r))
		}, hx.prototype._animateLabels = function(t, e) {
			var n, i, r, o, a, s, l, u, h, c, p, d, f, g = t.getTextContent(),
				y = t.getTextGuideLine();
			!g || !t.forceLabelAnimation && (g.ignore || g.invisible || t.disableLabelAnimation || Zh(t)) || (
				d = (f = ox(g)).oldLayout, n = (i = k(t)).dataIndex, s = {
					x: g.x,
					y: g.y,
					rotation: g.rotation
				}, i = e.getData(i.dataType), d ? (g.attr(d), (t = t.prevStates) && (0 <= I(t, "select") &&
						g.attr(f.oldLayoutSelect), 0 <= I(t, "emphasis")) && g.attr(f.oldLayoutEmphasis),
					qh(g, s, e, n)) : (g.attr(s), Bc(g).valueAnimation || (t = N(g.style.opacity, 1), g
					.style.opacity = 0, jh(g, {
						style: {
							opacity: t
						}
					}, e, n))), f.oldLayout = s, g.states.select && (sx(t = f.oldLayoutSelect = {}, s, lx),
					sx(t, g.states.select, lx)), g.states.emphasis && (sx(t = f.oldLayoutEmphasis = {}, s,
					lx), sx(t, g.states.emphasis, lx)), o = n, a = i, l = s = e, (p = Bc(r = g))
				.valueAnimation && p.prevValue !== p.value && (u = p.defaultInterpolatedText, h = N(p
					.interpolatedValue, p.prevValue), c = p.value, r.percent = 0, (null == p.prevValue ?
					jh : qh)(r, {
					percent: 1
				}, s, o, null, function(t) {
					var e = Jo(a, p.precision, h, c, t),
						t = (p.interpolatedValue = 1 === t ? null : e, Dc({
							labelDataIndex: o,
							labelFetcher: l,
							defaultText: u ? u(e) : e + ""
						}, p.statesModels, e));
					kc(r, t)
				}))), !y || y.ignore || y.invisible || (d = (f = ax(y)).oldLayout, t = {
				points: y.shape.points
			}, d ? (y.attr({
				shape: d
			}), qh(y, {
				shape: t
			}, e)) : (y.setShape(t), y.style.strokePercent = 0, jh(y, {
				style: {
					strokePercent: 1
				}
			}, e)), f.oldLayout = t)
		}, hx);

	function hx() {
		this._labelList = [], this._chartViewList = []
	}
	var cx = Yo();

	function px(t) {
		t.registerUpdateLifecycle("series:beforeupdate", function(t, e, n) {
			(cx(e).labelManager || (cx(e).labelManager = new ux)).clearLabels()
		}), t.registerUpdateLifecycle("series:layoutlabels", function(t, e, n) {
			var i = cx(e).labelManager;
			n.updatedSeries.forEach(function(t) {
				i.addLabelsOfSeries(e.getViewOfSeriesModel(t))
			}), i.updateLayoutConfig(e), i.layout(e), i.processLabelsOverall()
		})
	}

	function dx(t, e, n) {
		var i = X.createCanvas(),
			r = e.getWidth(),
			e = e.getHeight(),
			o = i.style;
		return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = r + "px", o.height = e + "px", i
			.setAttribute("data-zr-dom-id", t)), i.width = r * n, i.height = e * n, i
	}
	n1(px);
	u(yx, fx = ue), yx.prototype.getElementCount = function() {
		return this.__endIndex - this.__startIndex
	}, yx.prototype.afterBrush = function() {
		this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex
	}, yx.prototype.initContext = function() {
		this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr
	}, yx.prototype.setUnpainted = function() {
		this.__firstTimePaint = !0
	}, yx.prototype.createBackBuffer = function() {
		var t = this.dpr;
		this.domBack = dx("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"),
			1 !== t && this.ctxBack.scale(t, t)
	}, yx.prototype.createRepaintRects = function(t, e, n, i) {
		if (this.__firstTimePaint) return this.__firstTimePaint = !1, null;
		var r, l = [],
			u = this.maxRepaintRectCount,
			h = !1,
			c = new U(0, 0, 0, 0);

		function o(t) {
			if (t.isFinite() && !t.isZero())
				if (0 === l.length)(e = new U(0, 0, 0, 0)).copy(t), l.push(e);
				else {
					for (var e, n = !1, i = 1 / 0, r = 0, o = 0; o < l.length; ++o) {
						var a = l[o];
						if (a.intersect(t)) {
							var s = new U(0, 0, 0, 0);
							s.copy(a), s.union(t), l[o] = s, n = !0;
							break
						}
						h && (c.copy(t), c.union(a), s = t.width * t.height, a = a.width * a.height, (a = c
							.width * c.height - s - a) < i) && (i = a, r = o)
					}
					h && (l[r].union(t), n = !0), n || ((e = new U(0, 0, 0, 0)).copy(t), l.push(e)), h = h || l
						.length >= u
				}
		}
		for (var a, s = this.__startIndex; s < this.__endIndex; ++s)(p = t[s]) && (f = p.shouldBePainted(n, i, !
			0, !0), (d = p.__isRendered && (p.__dirty & vn || !f) ? p.getPrevPaintRect() : null) && o(
			d), a = f && (p.__dirty & vn || !p.__isRendered) ? p.getPaintRect() : null) && o(a);
		for (s = this.__prevStartIndex; s < this.__prevEndIndex; ++s) {
			var p, d, f = (p = e[s]).shouldBePainted(n, i, !0, !0);
			!p || f && p.__zr || !p.__isRendered || (d = p.getPrevPaintRect()) && o(d)
		}
		do {
			for (r = !1, s = 0; s < l.length;)
				if (l[s].isZero()) l.splice(s, 1);
				else {
					for (var g = s + 1; g < l.length;) l[s].intersect(l[g]) ? (r = !0, l[s].union(l[g]), l
						.splice(g, 1)) : g++;
					s++
				}
		} while (r);
		return this._paintRects = l
	}, yx.prototype.debugGetPaintRects = function() {
		return (this._paintRects || []).slice()
	}, yx.prototype.resize = function(t, e) {
		var n = this.dpr,
			i = this.dom,
			r = i.style,
			o = this.domBack;
		r && (r.width = t + "px", r.height = e + "px"), i.width = t * n, i.height = e * n, o && (o.width = t *
			n, o.height = e * n, 1 !== n) && this.ctxBack.scale(n, n)
	}, yx.prototype.clear = function(t, o, e) {
		var n = this.dom,
			a = this.ctx,
			i = n.width,
			r = n.height,
			s = (o = o || this.clearColor, this.motionBlur && !t),
			l = this.lastFrameAlpha,
			u = this.dpr,
			h = this,
			c = (s && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy",
				this.ctxBack.drawImage(n, 0, 0, i / u, r / u)), this.domBack);

		function p(t, e, n, i) {
			var r;
			a.clearRect(t, e, n, i), o && "transparent" !== o && (r = void 0, vt(o) ? (r = (o.global || o
				.__width === n && o.__height === i) && o.__canvasGradient || _m(a, o, {
				x: 0,
				y: 0,
				width: n,
				height: i
			}), o.__canvasGradient = r, o.__width = n, o.__height = i) : _t(o) && (o.scaleX = o
				.scaleX || u, o.scaleY = o.scaleY || u, r = Dm(a, o, {
					dirty: function() {
						h.setUnpainted(), h.__painter.refresh()
					}
				})), a.save(), a.fillStyle = r || o, a.fillRect(t, e, n, i), a.restore()), s && (a.save(), a
				.globalAlpha = l, a.drawImage(c, t, e, n, i), a.restore())
		}!e || s ? p(0, 0, i, r) : e.length && E(e, function(t) {
			p(t.x * u, t.y * u, t.width * u, t.height * u)
		})
	};
	var fx, gx = yx;

	function yx(t, e, n) {
		var i, r = fx.call(this) || this,
			t = (r.motionBlur = !1, r.lastFrameAlpha = .7, r.dpr = 1, r.virtual = !1, r.config = {}, r
				.incremental = !1, r.zlevel = 0, r.maxRepaintRectCount = 5, r.__dirty = !0, r.__firstTimePaint = !0,
				r.__used = !1, r.__drawIndex = 0, r.__startIndex = 0, r.__endIndex = 0, r.__prevStartIndex = null, r
				.__prevEndIndex = null, n = n || br, "string" == typeof t ? i = dx(t, e, n) : L(t) && (t = (i = t)
					.id), r.id = t, (r.dom = i).style);
		return t && (Bt(i), i.onselectstart = function() {
			return !1
		}, t.padding = "0", t.margin = "0", t.borderWidth = "0"), r.painter = e, r.dpr = n, r
	}
	var mx = 314159;
	y.prototype.getType = function() {
		return "canvas"
	}, y.prototype.isSingleCanvas = function() {
		return this._singleCanvas
	}, y.prototype.getViewportRoot = function() {
		return this._domRoot
	}, y.prototype.getViewportRootOffset = function() {
		var t = this.getViewportRoot();
		if (t) return {
			offsetLeft: t.offsetLeft || 0,
			offsetTop: t.offsetTop || 0
		}
	}, y.prototype.refresh = function(t) {
		var e = this.storage.getDisplayList(!0),
			n = this._prevDisplayList,
			i = this._zlevelList;
		this._redrawId = Math.random(), this._paintList(e, n, t, this._redrawId);
		for (var r = 0; r < i.length; r++) {
			var o, a = i[r],
				a = this._layers[a];
			!a.__builtin__ && a.refresh && (o = 0 === r ? this._backgroundColor : null, a.refresh(o))
		}
		return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this
	}, y.prototype.refreshHover = function() {
		this._paintHoverList(this.storage.getDisplayList(!1))
	}, y.prototype._paintHoverList = function(t) {
		var e = t.length,
			n = this._hoverlayer;
		if (n && n.clear(), e) {
			for (var i, r = {
					inHover: !0,
					viewWidth: this._width,
					viewHeight: this._height
				}, o = 0; o < e; o++) {
				var a = t[o];
				a.__inHover && (n = n || (this._hoverlayer = this.getLayer(1e5)), i || (i = n.ctx).save(), Gm(i,
					a, r, o === e - 1))
			}
			i && i.restore()
		}
	}, y.prototype.getHoverLayer = function() {
		return this.getLayer(1e5)
	}, y.prototype.paintOne = function(t, e) {
		Hm(t, e)
	}, y.prototype._paintList = function(t, e, n, i) {
		var r, o, a;
		this._redrawId === i && (n = n || !1, this._updateLayerStatus(t), r = (o = this._doPaintList(t, e, n))
			.finished, o = o.needsRefreshHover, this._needsManuallyCompositing && this._compositeManually(),
			o && this._paintHoverList(t), r ? this.eachLayer(function(t) {
				t.afterBrush && t.afterBrush()
			}) : (a = this, Tn(function() {
				a._paintList(t, e, n, i)
			})))
	}, y.prototype._compositeManually = function() {
		var e = this.getLayer(mx).ctx,
			n = this._domRoot.width,
			i = this._domRoot.height;
		e.clearRect(0, 0, n, i), this.eachBuiltinLayer(function(t) {
			t.virtual && e.drawImage(t.dom, 0, 0, n, i)
		})
	}, y.prototype._doPaintList = function(d, f, g) {
		for (var y = this, m = [], v = this._opts.useDirtyRect, t = 0; t < this._zlevelList.length; t++) {
			var e = this._zlevelList[t],
				e = this._layers[e];
			e.__builtin__ && e !== this._hoverlayer && (e.__dirty || g) && m.push(e)
		}
		for (var _ = !0, x = !1, w = this, n = 0; n < m.length; n++) ! function(t) {
			function e(t) {
				var e = {
					inHover: !1,
					allClipped: !1,
					prevEl: null,
					viewWidth: y._width,
					viewHeight: y._height
				};
				for (i = s; i < r.__endIndex; i++) {
					var n = d[i];
					if (n.__inHover && (x = !0), y._doPaintEl(n, r, v, t, e, i === r.__endIndex - 1), l &&
						15 < Date.now() - u) break
				}
				e.prevElClipPaths && o.restore()
			}
			var i, n, r = m[t],
				o = r.ctx,
				a = v && r.createRepaintRects(d, f, w._width, w._height),
				s = g ? r.__startIndex : r.__drawIndex,
				l = !g && r.incremental && Date.now,
				u = l && Date.now(),
				t = r.zlevel === w._zlevelList[0] ? w._backgroundColor : null;
			r.__startIndex !== r.__endIndex && (s !== r.__startIndex || (n = d[s]).incremental && n
				.notClear && !g) || r.clear(!1, t, a), -1 === s && (console.error(
				"For some unknown reason. drawIndex is -1"), s = r.__startIndex);
			if (a)
				if (0 === a.length) i = r.__endIndex;
				else
					for (var h = w.dpr, c = 0; c < a.length; ++c) {
						var p = a[c];
						o.save(), o.beginPath(), o.rect(p.x * h, p.y * h, p.width * h, p.height * h), o
							.clip(), e(p), o.restore()
					} else o.save(), e(), o.restore();
			r.__drawIndex = i, r.__drawIndex < r.__endIndex && (_ = !1)
		}(n);
		return b.wxa && E(this._layers, function(t) {
			t && t.ctx && t.ctx.draw && t.ctx.draw()
		}), {
			finished: _,
			needsRefreshHover: x
		}
	}, y.prototype._doPaintEl = function(t, e, n, i, r, o) {
		e = e.ctx;
		n ? (n = t.getPaintRect(), (!i || n && n.intersect(i)) && (Gm(e, t, r, o), t.setPrevPaintRect(n))) : Gm(
			e, t, r, o)
	}, y.prototype.getLayer = function(t, e) {
		this._singleCanvas && !this._needsManuallyCompositing && (t = mx);
		var n = this._layers[t];
		return n || ((n = new gx("zr_" + t, this, this.dpr)).zlevel = t, n.__builtin__ = !0, this._layerConfig[
			t] ? d(n, this._layerConfig[t], !0) : this._layerConfig[t - .01] && d(n, this._layerConfig[
			t - .01], !0), e && (n.virtual = e), this.insertLayer(t, n), n.initContext()), n
	}, y.prototype.insertLayer = function(t, e) {
		var n, i = this._layers,
			r = this._zlevelList,
			o = r.length,
			a = this._domRoot,
			s = null,
			l = -1;
		if (!i[t] && (n = e) && (n.__builtin__ || "function" == typeof n.resize && "function" == typeof n
				.refresh)) {
			if (0 < o && t > r[0]) {
				for (l = 0; l < o - 1 && !(r[l] < t && r[l + 1] > t); l++);
				s = i[r[l]]
			}
			r.splice(l + 1, 0, t), (i[t] = e).virtual || (s ? (n = s.dom).nextSibling ? a.insertBefore(e.dom, n
				.nextSibling) : a.appendChild(e.dom) : a.firstChild ? a.insertBefore(e.dom, a
				.firstChild) : a.appendChild(e.dom)), e.__painter = this
		}
	}, y.prototype.eachLayer = function(t, e) {
		for (var n = this._zlevelList, i = 0; i < n.length; i++) {
			var r = n[i];
			t.call(e, this._layers[r], r)
		}
	}, y.prototype.eachBuiltinLayer = function(t, e) {
		for (var n = this._zlevelList, i = 0; i < n.length; i++) {
			var r = n[i],
				o = this._layers[r];
			o.__builtin__ && t.call(e, o, r)
		}
	}, y.prototype.eachOtherLayer = function(t, e) {
		for (var n = this._zlevelList, i = 0; i < n.length; i++) {
			var r = n[i],
				o = this._layers[r];
			o.__builtin__ || t.call(e, o, r)
		}
	}, y.prototype.getLayers = function() {
		return this._layers
	}, y.prototype._updateLayerStatus = function(t) {
		function e(t) {
			r && (r.__endIndex !== t && (r.__dirty = !0), r.__endIndex = t)
		}
		if (this.eachBuiltinLayer(function(t, e) {
				t.__dirty = t.__used = !1
			}), this._singleCanvas)
			for (var n = 1; n < t.length; n++)
				if ((s = t[n]).zlevel !== t[n - 1].zlevel || s.incremental) {
					this._needsManuallyCompositing = !0;
					break
				} for (var i, r = null, o = 0, a = 0; a < t.length; a++) {
			var s, l = (s = t[a]).zlevel,
				u = void 0;
			i !== l && (i = l, o = 0), s.incremental ? ((u = this.getLayer(l + .001, this
				._needsManuallyCompositing)).incremental = !0, o = 1) : u = this.getLayer(l + (0 < o ? .01 :
				0), this._needsManuallyCompositing), u.__builtin__ || ot("ZLevel " + l +
				" has been used by unkown layer " + u.id), u !== r && (u.__used = !0, u.__startIndex !==
				a && (u.__dirty = !0), u.__startIndex = a, u.incremental ? u.__drawIndex = -1 : u
				.__drawIndex = a, e(a), r = u), s.__dirty & vn && !s.__inHover && (u.__dirty = !0, u
				.incremental) && u.__drawIndex < 0 && (u.__drawIndex = a)
		}
		e(a), this.eachBuiltinLayer(function(t, e) {
			!t.__used && 0 < t.getElementCount() && (t.__dirty = !0, t.__startIndex = t.__endIndex = t
				.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t
				.__startIndex)
		})
	}, y.prototype.clear = function() {
		return this.eachBuiltinLayer(this._clearLayer), this
	}, y.prototype._clearLayer = function(t) {
		t.clear()
	}, y.prototype.setBackgroundColor = function(t) {
		this._backgroundColor = t, E(this._layers, function(t) {
			t.setUnpainted()
		})
	}, y.prototype.configLayer = function(t, e) {
		if (e) {
			var n = this._layerConfig;
			n[t] ? d(n[t], e, !0) : n[t] = e;
			for (var i = 0; i < this._zlevelList.length; i++) {
				var r = this._zlevelList[i];
				r !== t && r !== t + .01 || d(this._layers[r], n[t], !0)
			}
		}
	}, y.prototype.delLayer = function(t) {
		var e = this._layers,
			n = this._zlevelList,
			i = e[t];
		i && (i.dom.parentNode.removeChild(i.dom), delete e[t], n.splice(I(n, t), 1))
	}, y.prototype.resize = function(t, e) {
		if (this._domRoot.style) {
			var n = this._domRoot,
				i = (n.style.display = "none", this._opts),
				r = this.root;
			if (null != t && (i.width = t), null != e && (i.height = e), t = wm(r, 0, i), e = wm(r, 1, i), n
				.style.display = "", this._width !== t || e !== this._height) {
				for (var o in n.style.width = t + "px", n.style.height = e + "px", this._layers) this._layers
					.hasOwnProperty(o) && this._layers[o].resize(t, e);
				this.refresh(!0)
			}
			this._width = t, this._height = e
		} else {
			if (null == t || null == e) return;
			this._width = t, this._height = e, this.getLayer(mx).resize(t, e)
		}
		return this
	}, y.prototype.clearLayer = function(t) {
		t = this._layers[t];
		t && t.clear()
	}, y.prototype.dispose = function() {
		this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null
	}, y.prototype.getRenderedCanvas = function(t) {
		if (this._singleCanvas && !this._compositeManually) return this._layers[mx].dom;
		var e = new gx("image", this, (t = t || {}).pixelRatio || this.dpr),
			n = (e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor), e.ctx);
		if (t.pixelRatio <= this.dpr) {
			this.refresh();
			var i = e.dom.width,
				r = e.dom.height;
			this.eachLayer(function(t) {
				t.__builtin__ ? n.drawImage(t.dom, 0, 0, i, r) : t.renderToCanvas && (n.save(), t
					.renderToCanvas(n), n.restore())
			})
		} else
			for (var o = {
					inHover: !1,
					viewWidth: this._width,
					viewHeight: this._height
				}, a = this.storage.getDisplayList(!0), s = 0, l = a.length; s < l; s++) {
				var u = a[s];
				Gm(n, u, o, s === l - 1)
			}
		return e.dom
	}, y.prototype.getWidth = function() {
		return this._width
	}, y.prototype.getHeight = function() {
		return this._height
	};
	var vx = y;

	function y(t, e, n, i) {
		this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this
			._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
		var r, o, a = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase(),
			e = (this._opts = n = O({}, n || {}), this.dpr = n.devicePixelRatio || br, this._singleCanvas = a, (this
				.root = t).style && (Bt(t), t.innerHTML = ""), this.storage = e, this._zlevelList),
			s = (this._prevDisplayList = [], this._layers);
		a ? (r = (a = t).width, o = a.height, null != n.width && (r = n.width), null != n.height && (o = n.height),
			this.dpr = n.devicePixelRatio || 1, a.width = r * this.dpr, a.height = o * this.dpr, this._width =
			r, this._height = o, (r = new gx(a, this, this.dpr)).__builtin__ = !0, r.initContext(), (s[mx] = r)
			.zlevel = mx, e.push(mx), this._domRoot = t) : (this._width = wm(t, 0, n), this._height = wm(t, 1,
			n), r = this._domRoot = (o = this._width, a = this._height, (s = document.createElement("div"))
			.style.cssText = ["position:relative", "width:" + o + "px", "height:" + a + "px", "padding:0",
				"margin:0", "border-width:0"
			].join(";") + ";", s), t.appendChild(r))
	}
	u(bx, _x = g), bx.prototype.init = function(t, e, n) {
		_x.prototype.init.call(this, t, e, n), this._sourceManager = new Pg(this), Og(this)
	}, bx.prototype.mergeOption = function(t, e) {
		_x.prototype.mergeOption.call(this, t, e), Og(this)
	}, bx.prototype.optionUpdated = function() {
		this._sourceManager.dirty()
	}, bx.prototype.getSourceManager = function() {
		return this._sourceManager
	}, bx.type = "dataset", bx.defaultOption = {
		seriesLayoutBy: md
	};
	var _x, xx = bx;

	function bx() {
		var t = null !== _x && _x.apply(this, arguments) || this;
		return t.type = "dataset", t
	}
	u(Tx, Sx = uy), Tx.type = "dataset";
	var Sx, Mx = Tx;

	function Tx() {
		var t = null !== Sx && Sx.apply(this, arguments) || this;
		return t.type = "dataset", t
	}

	function Cx(t) {
		t.registerComponentModel(xx), t.registerComponentView(Mx)
	}
	n1([function(t) {
		t.registerPainter("canvas", vx)
	}, Cx]), n1(px);
	var Ix = {
			average: function(t) {
				for (var e = 0, n = 0, i = 0; i < t.length; i++) isNaN(t[i]) || (e += t[i], n++);
				return 0 === n ? NaN : e / n
			},
			sum: function(t) {
				for (var e = 0, n = 0; n < t.length; n++) e += t[n] || 0;
				return e
			},
			max: function(t) {
				for (var e = -1 / 0, n = 0; n < t.length; n++) t[n] > e && (e = t[n]);
				return isFinite(e) ? e : NaN
			},
			min: function(t) {
				for (var e = 1 / 0, n = 0; n < t.length; n++) t[n] < e && (e = t[n]);
				return isFinite(e) ? e : NaN
			},
			nearest: function(t) {
				return t[0]
			}
		},
		kx = function(t) {
			return Math.round(t.length / 2)
		};

	function Dx(t) {
		return {
			seriesType: t,
			reset: function(t, e, n) {
				var i, r = t.getData(),
					o = t.get("sampling"),
					a = t.coordinateSystem,
					s = r.count();
				10 < s && "cartesian2d" === a.type && o && (i = a.getBaseAxis(), a = a.getOtherAxis(i), i = i
						.getExtent(), n = n.getDevicePixelRatio(), i = Math.abs(i[1] - i[0]) * (n || 1), n =
						Math.round(s / i), isFinite(n)) && 1 < n && ("lttb" === o && t.setData(r.lttbDownSample(
						r.mapDimension(a.dim), 1 / n)), s = void 0, H(o) ? s = Ix[o] : S(o) && (s = o), s) && t
					.setData(r.downSample(r.mapDimension(a.dim), 1 / n, s, kx))
			}
		}
	}
	u(Px, Ax = ey), Px.prototype.getInitialData = function(t, e) {
		return Uv(null, this, {
			useEncodeDefaulter: !0
		})
	}, Px.prototype.getMarkerPosition = function(t, c, e) {
		var p, d, n = this.coordinateSystem;
		return n && n.clampData ? (p = n.clampData(t), d = n.dataToPoint(p), e ? E(n.getAxes(), function(t, e) {
			if ("category" === t.type && null != c) {
				var n = t.getTicksCoords(),
					i = p[e],
					r = "x1" === c[e] || "y1" === c[e];
				if (r && (i += 1), !(n.length < 2))
					if (2 === n.length) d[e] = t.toGlobalCoord(t.getExtent()[r ? 1 : 0]);
					else {
						for (var o = void 0, a = void 0, s = 1, l = 0; l < n.length; l++) {
							var u = n[l].coord,
								h = l === n.length - 1 ? n[l - 1].tickValue + s : n[l].tickValue;
							if (h === i) {
								a = u;
								break
							}
							if (h < i) o = u;
							else if (null != o && i < h) {
								a = (u + o) / 2;
								break
							}
							1 === l && (s = h - n[0].tickValue)
						}
						null == a && (a = (o ? n[n.length - 1] : n[0]).coord), d[e] = t
							.toGlobalCoord(a)
					}
			}
		}) : (e = (t = this.getData()).getLayout("offset"), t = t.getLayout("size"), n = n.getBaseAxis()
			.isHorizontal() ? 0 : 1, d[n] += e + t / 2), d) : [NaN, NaN]
	}, Px.type = "series.__base_bar__", Px.defaultOption = {
		z: 2,
		coordinateSystem: "cartesian2d",
		legendHoverLink: !0,
		barMinHeight: 0,
		barMinAngle: 0,
		large: !1,
		largeThreshold: 400,
		progressive: 3e3,
		progressiveChunkMode: "mod"
	};
	var Ax, Xc = Px;

	function Px() {
		var t = null !== Ax && Ax.apply(this, arguments) || this;
		return t.type = Px.type, t
	}
	ey.registerClass(Xc);
	u(Rx, Lx = Xc), Rx.prototype.getInitialData = function() {
		return Uv(null, this, {
			useEncodeDefaulter: !0,
			createInvertedIndices: !!this.get("realtimeSort", !0) || null
		})
	}, Rx.prototype.getProgressive = function() {
		return !!this.get("large") && this.get("progressive")
	}, Rx.prototype.getProgressiveThreshold = function() {
		var t = this.get("progressiveThreshold"),
			e = this.get("largeThreshold");
		return t = t < e ? e : t
	}, Rx.prototype.brushSelector = function(t, e, n) {
		return n.rect(e.getItemLayout(t))
	}, Rx.type = "series.bar", Rx.dependencies = ["grid", "polar"], Rx.defaultOption = np(Xc.defaultOption, {
		clip: !0,
		roundCap: !1,
		showBackground: !1,
		backgroundStyle: {
			color: "rgba(180, 180, 180, 0.2)",
			borderColor: null,
			borderWidth: 0,
			borderType: "solid",
			borderRadius: 0,
			shadowBlur: 0,
			shadowColor: null,
			shadowOffsetX: 0,
			shadowOffsetY: 0,
			opacity: 1
		},
		select: {
			itemStyle: {
				borderColor: "#212121"
			}
		},
		realtimeSort: !1
	});
	var Lx, Ox = Rx;

	function Rx() {
		var t = null !== Lx && Lx.apply(this, arguments) || this;
		return t.type = Rx.type, t
	}

	function Nx(t, e, n, i, r) {
		var o = t.getArea(),
			a = o.x,
			s = o.y,
			l = o.width,
			o = o.height,
			u = n.get(["lineStyle", "width"]) || 2,
			h = (a -= u / 2, s -= u / 2, l += u, o += u, a = Math.floor(a), l = Math.round(l), new Xs({
				shape: {
					x: a,
					y: s,
					width: l,
					height: o
				}
			}));
		return e && (e = (u = t.getBaseAxis()).isHorizontal(), t = u.inverse, e ? (t && (h.shape.x += l), h.shape
			.width = 0) : (t || (h.shape.y += o), h.shape.height = 0), u = S(r) ? function(t) {
			r(t, h)
		} : null, jh(h, {
			shape: {
				width: l,
				height: o,
				x: a,
				y: s
			}
		}, n, null, i, u)), h
	}

	function Ex(t, e, n) {
		var i = t.getArea(),
			r = go(i.r0, 1),
			o = go(i.r, 1),
			a = new Ku({
				shape: {
					cx: go(t.cx, 1),
					cy: go(t.cy, 1),
					r0: r,
					r: o,
					startAngle: i.startAngle,
					endAngle: i.endAngle,
					clockwise: i.clockwise
				}
			});
		return e && ("angle" === t.getBaseAxis().dim ? a.shape.endAngle = i.startAngle : a.shape.r = r, jh(a, {
			shape: {
				endAngle: i.endAngle,
				r: o
			}
		}, n)), a
	}

	function zx() {
		this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = 2 * Math.PI, this
			.clockwise = !0
	}
	u(Vx, Bx = Z), Vx.prototype.getDefaultShape = function() {
		return new zx
	}, Vx.prototype.buildPath = function(t, e) {
		var n = e.cx,
			i = e.cy,
			r = Math.max(e.r0 || 0, 0),
			o = Math.max(e.r, 0),
			a = .5 * (o - r),
			s = r + a,
			l = e.startAngle,
			u = e.endAngle,
			e = e.clockwise,
			h = 2 * Math.PI,
			c = e ? u - l < h : l - u < h,
			h = (c || (l = u - (e ? h : -h)), Math.cos(l)),
			p = Math.sin(l),
			d = Math.cos(u),
			f = Math.sin(u);
		c ? (t.moveTo(h * r + n, p * r + i), t.arc(h * s + n, p * s + i, a, -Math.PI + l, l, !e)) : t.moveTo(h *
			o + n, p * o + i), t.arc(n, i, o, l, u, !e), t.arc(d * s + n, f * s + i, a, u - 2 * Math.PI, u -
			Math.PI, !e), 0 !== r && t.arc(n, i, r, u, l, e)
	};
	var Bx, Fx = Vx;

	function Vx(t) {
		t = Bx.call(this, t) || this;
		return t.type = "sausage", t
	}

	function Hx(t, e) {
		return t.type === e
	}

	function Gx(t, e) {
		var n, i = t.mapDimensionsAll("defaultedLabel"),
			r = i.length;
		if (1 === r) return null != (n = Vf(t, e, i[0])) ? n + "" : null;
		if (r) {
			for (var o = [], a = 0; a < i.length; a++) o.push(Vf(t, e, i[a]));
			return o.join(" ")
		}
	}

	function Wx(t, e) {
		var n = t.mapDimensionsAll("defaultedLabel");
		if (!V(e)) return e + "";
		for (var i = [], r = 0; r < n.length; r++) {
			var o = t.getDimensionIndex(n[r]);
			0 <= o && i.push(e[o])
		}
		return i.join(" ")
	}

	function Ux(t, e, n) {
		return e * Math.sin(t) * (n ? -1 : 1)
	}

	function Xx(t, e, n) {
		return e * Math.cos(t) * (n ? 1 : -1)
	}

	function Yx(t, e, n) {
		t = t.get("borderRadius");
		if (null == t) return n ? {
			cornerRadius: 0
		} : null;
		V(t) || (t = [t, t, t, t]);
		var i = Math.abs(e.r || 0 - e.r0 || 0);
		return {
			cornerRadius: F(t, function(t) {
				return Gr(t, i)
			})
		}
	}
	var qx = Math.max,
		jx = Math.min;
	u(Jx, Zx = fy), Jx.prototype.render = function(t, e, n, i) {
		this._model = t, this._removeOnRenderedListener(n), this._updateDrawMode(t);
		var r = t.get("coordinateSystem");
		"cartesian2d" !== r && "polar" !== r || (this._progressiveEls = null, this._isLargeDraw ? this
			._renderLarge(t, e, n) : this._renderNormal(t, e, n, i))
	}, Jx.prototype.incrementalPrepareRender = function(t) {
		this._clear(), this._updateDrawMode(t), this._updateLargeClip(t)
	}, Jx.prototype.incrementalRender = function(t, e) {
		this._progressiveEls = [], this._incrementalRenderLarge(t, e)
	}, Jx.prototype.eachRendered = function(t) {
		Tc(this._progressiveEls || this.group, t)
	}, Jx.prototype._updateDrawMode = function(t) {
		t = t.pipelineContext.large;
		null != this._isLargeDraw && t === this._isLargeDraw || (this._isLargeDraw = t, this._clear())
	}, Jx.prototype._renderNormal = function(a, t, e, n) {
		var s, i, r, l = this.group,
			u = a.getData(),
			h = this._data,
			c = a.coordinateSystem,
			p = c.getBaseAxis(),
			d = ("cartesian2d" === c.type ? s = p.isHorizontal() : "polar" === c.type && (s = "angle" === p
				.dim), a.isAnimationEnabled() ? a : null),
			f = function(t, e) {
				var t = t.get("realtimeSort", !0),
					n = e.getBaseAxis();
				if (t && "category" === n.type && "cartesian2d" === e.type) return {
					baseAxis: n,
					otherAxis: e.getOtherAxis(n)
				}
			}(a, c),
			g = (f && this._enableRealtimeSort(f, u, e), a.get("clip", !0) || f),
			y = (e = u, r = (i = c).getArea && i.getArea(), !Hx(i, "cartesian2d") || "category" === (i = i
				.getBaseAxis()).type && i.onBand || (e = e.getLayout("bandWidth"), i.isHorizontal() ? (r
				.x -= e, r.width += 2 * e) : (r.y -= e, r.height += 2 * e)), r),
			m = (l.removeClipPath(), a.get("roundCap", !0)),
			v = a.get("showBackground", !0),
			_ = a.getModel("backgroundStyle"),
			x = _.get("borderRadius") || 0,
			w = [],
			b = this._backgroundEls,
			S = n && n.isInitSort,
			M = n && "changeAxisOrder" === n.type;

		function T(t) {
			var e = ow[c.type](u, t),
				n = (n = s, new("polar" === c.type ? Ku : Xs)({
					shape: fw(n, e, c),
					silent: !0,
					z2: 0
				}));
			return n.useStyle(_.getItemStyle()), "cartesian2d" === c.type ? n.setShape("r", x) : n.setShape(
				"cornerRadius", x), w[t] = n
		}
		u.diff(h).add(function(t) {
			var e, n, i = u.getItemModel(t),
				r = ow[c.type](u, t, i);
			v && T(t), u.hasValue(t) && rw[c.type](r) && (e = !1, g && (e = $x[c.type](y, r)), n = Qx[c
				.type](a, u, t, r, s, d, p.model, !1, m), f && (n.forceLabelAnimation = !0), sw(
				n, u, t, i, r, a, s, "polar" === c.type), S ? n.attr({
				shape: r
			}) : f ? tw(f, d, n, r, t, s, !1, !1) : jh(n, {
				shape: r
			}, a, t), u.setItemGraphicEl(t, n), l.add(n), n.ignore = e)
		}).update(function(t, e) {
			var n, i = u.getItemModel(t),
				r = ow[c.type](u, t, i),
				o = (v && (o = void 0, 0 === b.length ? o = T(e) : ((o = b[e]).useStyle(_
						.getItemStyle()), "cartesian2d" === c.type ? o.setShape("r", x) : o
					.setShape("cornerRadius", x), w[t] = o), n = ow[c.type](u, t), qh(o, {
					shape: fw(s, n, c)
				}, d, t)), h.getItemGraphicEl(e));
			u.hasValue(t) && rw[c.type](r) ? (n = !1, g && (n = $x[c.type](y, r)) && l.remove(o), o ?
				Jh(o) : o = Qx[c.type](a, u, t, r, s, d, p.model, !!o, m), f && (o
					.forceLabelAnimation = !0), M ? (e = o.getTextContent()) && null != (e = Bc(e))
				.prevValue && (e.prevValue = e.value) : sw(o, u, t, i, r, a, s, "polar" === c.type),
				S ? o.attr({
					shape: r
				}) : f ? tw(f, d, o, r, t, s, !0, M) : qh(o, {
					shape: r
				}, a, t, null), u.setItemGraphicEl(t, o), o.ignore = n, l.add(o)) : l.remove(o)
		}).remove(function(t) {
			var e = h.getItemGraphicEl(t);
			e && Qh(e, a, t)
		}).execute();
		var o = this._backgroundGroup || (this._backgroundGroup = new no);
		o.removeAll();
		for (var C = 0; C < w.length; ++C) o.add(w[C]);
		l.add(o), this._backgroundEls = w, this._data = u
	}, Jx.prototype._renderLarge = function(t, e, n) {
		this._clear(), pw(t, this.group), this._updateLargeClip(t)
	}, Jx.prototype._incrementalRenderLarge = function(t, e) {
		this._removeBackground(), pw(e, this.group, this._progressiveEls, !0)
	}, Jx.prototype._updateLargeClip = function(t) {
		var e, n, i = t.get("clip", !0) && (i = t.coordinateSystem, r = !1, t = t, i ? "polar" === i.type ? Ex(
				i, r, t) : "cartesian2d" === i.type ? Nx(i, r, t, e, n) : null : null),
			r = this.group;
		i ? r.setClipPath(i) : r.removeClipPath()
	}, Jx.prototype._enableRealtimeSort = function(t, e, n) {
		var i, r, o = this;
		e.count() && (i = t.baseAxis, this._isFirstFrame ? (this._dispatchInitSort(e, t, n), this
			._isFirstFrame = !1) : (r = function(t) {
			t = e.getItemGraphicEl(t), t = t && t.shape;
			return t && Math.abs(i.isHorizontal() ? t.height : t.width) || 0
		}, this._onRendered = function() {
			o._updateSortWithinSameData(e, r, i, n)
		}, n.getZr().on("rendered", this._onRendered)))
	}, Jx.prototype._dataSort = function(t, e, i) {
		var r = [];
		return t.each(t.mapDimension(e.dim), function(t, e) {
			var n = i(e);
			r.push({
				dataIndex: e,
				mappedValue: null == n ? NaN : n,
				ordinalNumber: t
			})
		}), r.sort(function(t, e) {
			return e.mappedValue - t.mappedValue
		}), {
			ordinalNumbers: F(r, function(t) {
				return t.ordinalNumber
			})
		}
	}, Jx.prototype._isOrderChangedWithinSameData = function(t, e, n) {
		for (var i = n.scale, r = t.mapDimension(n.dim), o = Number.MAX_VALUE, a = 0, s = i.getOrdinalMeta()
				.categories.length; a < s; ++a) {
			var l = t.rawIndexOf(r, i.getRawOrdinalNumber(a)),
				l = l < 0 ? Number.MIN_VALUE : e(t.indexOfRawIndex(l));
			if (o < l) return !0;
			o = l
		}
		return !1
	}, Jx.prototype._isOrderDifferentInView = function(t, e) {
		for (var n = e.scale, e = n.getExtent(), i = Math.max(0, e[0]), r = Math.min(e[1], n.getOrdinalMeta()
				.categories.length - 1); i <= r; ++i)
			if (t.ordinalNumbers[i] !== n.getRawOrdinalNumber(i)) return !0
	}, Jx.prototype._updateSortWithinSameData = function(t, e, n, i) {
		this._isOrderChangedWithinSameData(t, e, n) && (t = this._dataSort(t, n, e), this
			._isOrderDifferentInView(t, n)) && (this._removeOnRenderedListener(i), i.dispatchAction({
			type: "changeAxisOrder",
			componentType: n.dim + "Axis",
			axisId: n.index,
			sortInfo: t
		}))
	}, Jx.prototype._dispatchInitSort = function(e, n, t) {
		var i = n.baseAxis,
			r = this._dataSort(e, i, function(t) {
				return e.get(e.mapDimension(n.otherAxis.dim), t)
			});
		t.dispatchAction({
			type: "changeAxisOrder",
			componentType: i.dim + "Axis",
			isInitSort: !0,
			axisId: i.index,
			sortInfo: r
		})
	}, Jx.prototype.remove = function(t, e) {
		this._clear(this._model), this._removeOnRenderedListener(e)
	}, Jx.prototype.dispose = function(t, e) {
		this._removeOnRenderedListener(e)
	}, Jx.prototype._removeOnRenderedListener = function(t) {
		this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null)
	}, Jx.prototype._clear = function(e) {
		var t = this.group,
			n = this._data;
		e && e.isAnimationEnabled() && n && !this._isLargeDraw ? (this._removeBackground(), this
			._backgroundEls = [], n.eachItemGraphicEl(function(t) {
				Qh(t, e, k(t).dataIndex)
			})) : t.removeAll(), this._data = null, this._isFirstFrame = !0
	}, Jx.prototype._removeBackground = function() {
		this.group.remove(this._backgroundGroup), this._backgroundGroup = null
	}, Jx.type = "bar";
	var Zx, Kx = Jx,
		$x = {
			cartesian2d: function(t, e) {
				var n = e.width < 0 ? -1 : 1,
					i = e.height < 0 ? -1 : 1,
					r = (n < 0 && (e.x += e.width, e.width = -e.width), i < 0 && (e.y += e.height, e.height = -e
						.height), t.x + t.width),
					o = t.y + t.height,
					a = qx(e.x, t.x),
					s = jx(e.x + e.width, r),
					t = qx(e.y, t.y),
					l = jx(e.y + e.height, o),
					u = s < a,
					h = l < t;
				return e.x = u && r < a ? s : a, e.y = h && o < t ? l : t, e.width = u ? 0 : s - a, e.height =
					h ? 0 : l - t, n < 0 && (e.x += e.width, e.width = -e.width), i < 0 && (e.y += e.height, e
						.height = -e.height), u || h
			},
			polar: function(t, e) {
				var n, i = e.r0 <= e.r ? 1 : -1,
					r = (i < 0 && (n = e.r, e.r = e.r0, e.r0 = n), jx(e.r, t.r)),
					t = qx(e.r0, t.r0),
					r = (e.r = r) - (e.r0 = t) < 0;
				return i < 0 && (n = e.r, e.r = e.r0, e.r0 = n), r
			}
		},
		Qx = {
			cartesian2d: function(t, e, n, i, r, o, a, s, l) {
				i = new Xs({
					shape: O({}, i),
					z2: 1
				});
				return i.__dataIndex = n, i.name = "item", o && (i.shape[r ? "height" : "width"] = 0), i
			},
			polar: function(t, e, n, i, r, o, a, s, l) {
				var w, b, l = !r && l ? Fx : Ku,
					u = new l({
						shape: i,
						z2: 1
					}),
					h = (u.name = "item", aw(r));
				return u.calculateTextPosition = (w = h, b = ({
					isRoundCap: l === Fx
				} || {}).isRoundCap, function(t, e, n) {
					var i = e.position;
					if (!i || i instanceof Array) return Wr(t, e, n);
					var i = w(i),
						r = null != e.distance ? e.distance : 5,
						o = this.shape,
						a = o.cx,
						s = o.cy,
						l = o.r,
						u = o.r0,
						h = (l + u) / 2,
						c = o.startAngle,
						p = o.endAngle,
						d = (c + p) / 2,
						f = b ? Math.abs(l - u) / 2 : 0,
						g = Math.cos,
						y = Math.sin,
						m = a + l * g(c),
						v = s + l * y(c),
						_ = "left",
						x = "top";
					switch (i) {
						case "startArc":
							m = a + (u - r) * g(d), v = s + (u - r) * y(d), _ = "center", x = "top";
							break;
						case "insideStartArc":
							m = a + (u + r) * g(d), v = s + (u + r) * y(d), _ = "center", x = "bottom";
							break;
						case "startAngle":
							m = a + h * g(c) + Ux(c, r + f, !1), v = s + h * y(c) + Xx(c, r + f, !1),
								_ = "right", x = "middle";
							break;
						case "insideStartAngle":
							m = a + h * g(c) + Ux(c, f - r, !1), v = s + h * y(c) + Xx(c, f - r, !1),
								_ = "left", x = "middle";
							break;
						case "middle":
							m = a + h * g(d), v = s + h * y(d), _ = "center", x = "middle";
							break;
						case "endArc":
							m = a + (l + r) * g(d), v = s + (l + r) * y(d), _ = "center", x = "bottom";
							break;
						case "insideEndArc":
							m = a + (l - r) * g(d), v = s + (l - r) * y(d), _ = "center", x = "top";
							break;
						case "endAngle":
							m = a + h * g(p) + Ux(p, r + f, !0), v = s + h * y(p) + Xx(p, r + f, !0),
								_ = "left", x = "middle";
							break;
						case "insideEndAngle":
							m = a + h * g(p) + Ux(p, f - r, !0), v = s + h * y(p) + Xx(p, f - r, !0),
								_ = "right", x = "middle";
							break;
						default:
							return Wr(t, e, n)
					}
					return (t = t || {}).x = m, t.y = v, t.align = _, t.verticalAlign = x, t
				}), o && (h = {}, u.shape[l = r ? "r" : "endAngle"] = r ? i.r0 : i.startAngle, h[l] = i[l],
					(s ? qh : jh)(u, {
						shape: h
					}, o)), u
			}
		};

	function Jx() {
		var t = Zx.call(this) || this;
		return t.type = Jx.type, t._isFirstFrame = !0, t
	}

	function tw(t, e, n, i, r, o, a, s) {
		var l, o = o ? (l = {
			x: i.x,
			width: i.width
		}, {
			y: i.y,
			height: i.height
		}) : (l = {
			y: i.y,
			height: i.height
		}, {
			x: i.x,
			width: i.width
		});
		s || (a ? qh : jh)(n, {
			shape: o
		}, e, r, null), (a ? qh : jh)(n, {
			shape: l
		}, e ? t.baseAxis.model : null, r)
	}

	function ew(t, e) {
		for (var n = 0; n < e.length; n++)
			if (!isFinite(t[e[n]])) return 1
	}
	var nw = ["x", "y", "width", "height"],
		iw = ["cx", "cy", "r", "startAngle", "endAngle"],
		rw = {
			cartesian2d: function(t) {
				return !ew(t, nw)
			},
			polar: function(t) {
				return !ew(t, iw)
			}
		},
		ow = {
			cartesian2d: function(t, e, n) {
				var t = t.getItemLayout(e),
					i = n && (e = t, i = (n = n).get(["itemStyle", "borderColor"])) && "none" !== i ? (i = n
						.get(["itemStyle", "borderWidth"]) || 0, n = isNaN(e.width) ? Number.MAX_VALUE : Math
						.abs(e.width), e = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height), Math.min(i,
							n, e)) : 0,
					n = 0 < t.width ? 1 : -1,
					e = 0 < t.height ? 1 : -1;
				return {
					x: t.x + n * i / 2,
					y: t.y + e * i / 2,
					width: t.width - n * i,
					height: t.height - e * i
				}
			},
			polar: function(t, e, n) {
				t = t.getItemLayout(e);
				return {
					cx: t.cx,
					cy: t.cy,
					r0: t.r0,
					r: t.r,
					startAngle: t.startAngle,
					endAngle: t.endAngle,
					clockwise: t.clockwise
				}
			}
		};

	function aw(t) {
		return e = t ? "Arc" : "Angle",
			function(t) {
				switch (t) {
					case "start":
					case "insideStart":
					case "end":
					case "insideEnd":
						return t + e;
					default:
						return t
				}
			};
		var e
	}

	function sw(t, e, n, i, r, o, a, s) {
		var l = e.getItemVisual(n, "style"),
			u = (s ? o.get("roundCap") || (O(u = t.shape, Yx(i.getModel("itemStyle"), u, !0)), t.setShape(u)) : (u =
				i.get(["itemStyle", "borderRadius"]) || 0, t.setShape("r", u)), t.useStyle(l), i.getShallow(
				"cursor")),
			u = (u && t.attr("cursor", u), s ? a ? r.r >= r.r0 ? "endArc" : "startArc" : r.endAngle >= r
				.startAngle ? "endAngle" : "startAngle" : a ? 0 <= r.height ? "bottom" : "top" : 0 <= r.width ?
				"right" : "left"),
			h = Pc(i),
			l = (Ac(t, h, {
				labelFetcher: o,
				labelDataIndex: n,
				defaultText: Gx(o.getData(), n),
				inheritColor: l.fill,
				defaultOpacity: l.opacity,
				defaultOutsidePosition: u
			}), t.getTextContent()),
			h = (s && l && (s = i.get(["label", "position"]), t.textConfig.inside = "middle" === s || null,
					function(t, e, n, i) {
						if (G(i)) t.setTextConfig({
							rotation: i
						});
						else if (V(e)) t.setTextConfig({
							rotation: 0
						});
						else {
							var r, i = t.shape,
								o = i.clockwise ? i.startAngle : i.endAngle,
								a = i.clockwise ? i.endAngle : i.startAngle,
								s = (o + a) / 2,
								i = n(e);
							switch (i) {
								case "startArc":
								case "insideStartArc":
								case "middle":
								case "insideEndArc":
								case "endArc":
									r = s;
									break;
								case "startAngle":
								case "insideStartAngle":
									r = o;
									break;
								case "endAngle":
								case "insideEndAngle":
									r = a;
									break;
								default:
									return t.setTextConfig({
										rotation: 0
									})
							}
							n = 1.5 * Math.PI - r;
							"middle" === i && n > Math.PI / 2 && n < 1.5 * Math.PI && (n -= Math.PI), t
								.setTextConfig({
									rotation: n
								})
						}
					}(t, "outside" === s ? u : s, aw(a), i.get(["label", "rotate"]))), u = l, s = h, a = o
				.getRawValue(n), l = function(t) {
					return Wx(e, t)
				}, u && ((u = Bc(u)).prevValue = u.value, u.value = a, a = s.normal, u.valueAnimation = a.get(
					"valueAnimation"), u.valueAnimation) && (u.precision = a.get("precision"), u
					.defaultInterpolatedText = l, u.statesModels = s), i.getModel(["emphasis"]));
		tu(t, h.get("focus"), h.get("blurScope"), h.get("disabled")), iu(t, i), null != (o = r).startAngle &&
			null != o.endAngle && o.startAngle === o.endAngle && (t.style.fill = "none", t.style.stroke = "none", E(
				t.states,
				function(t) {
					t.style && (t.style.fill = t.style.stroke = "none")
				}))
	}

	function lw() {}
	u(cw, uw = Z), cw.prototype.getDefaultShape = function() {
		return new lw
	}, cw.prototype.buildPath = function(t, e) {
		for (var n = e.points, i = this.baseDimIdx, r = 1 - this.baseDimIdx, o = [], a = [], s = this.barWidth,
				l = 0; l < n.length; l += 3) a[i] = s, a[r] = n[l + 2], o[i] = n[l + i], o[r] = n[l + r], t
			.rect(o[0], o[1], a[0], a[1])
	};
	var uw, hw = cw;

	function cw(t) {
		t = uw.call(this, t) || this;
		return t.type = "largeBar", t
	}

	function pw(t, e, n, i) {
		var r = t.getData(),
			o = r.getLayout("valueAxisHorizontal") ? 1 : 0,
			a = r.getLayout("largeDataIndices"),
			s = r.getLayout("size"),
			l = t.getModel("backgroundStyle"),
			u = r.getLayout("largeBackgroundPoints"),
			l = (u && ((u = new hw({
				shape: {
					points: u
				},
				incremental: !!i,
				silent: !0,
				z2: 0
			})).baseDimIdx = o, u.largeDataIndices = a, u.barWidth = s, u.useStyle(l.getItemStyle()), e.add(
				u), n) && n.push(u), new hw({
				shape: {
					points: r.getLayout("largePoints")
				},
				incremental: !!i,
				ignoreCoarsePointer: !0,
				z2: 1
			}));
		l.baseDimIdx = o, l.largeDataIndices = a, l.barWidth = s, e.add(l), l.useStyle(r.getVisual("style")), k(l)
			.seriesIndex = t.seriesIndex, t.get("silent") || (l.on("mousedown", dw), l.on("mousemove", dw)), n && n
			.push(l)
	}
	var dw = My(function(t) {
		t = function(t, e, n) {
			for (var i = t.baseDimIdx, r = 1 - i, o = t.shape.points, a = t.largeDataIndices, s = [],
					l = [], u = t.barWidth, h = 0, c = o.length / 3; h < c; h++) {
				var p = 3 * h;
				if (l[i] = u, l[r] = o[2 + p], s[i] = o[p + i], s[r] = o[p + r], l[r] < 0 && (s[r] += l[
						r], l[r] = -l[r]), s[0] <= e && e <= s[0] + l[0] && s[1] <= n && n <= s[1] + l[
						1]) return a[h]
			}
			return -1
		}(this, t.offsetX, t.offsetY);
		k(this).dataIndex = 0 <= t ? t : null
	}, 30, !1);

	function fw(t, e, n) {
		var i, r;
		return Hx(n, "cartesian2d") ? (r = e, i = n.getArea(), {
			x: (t ? r : i).x,
			y: (t ? i : r).y,
			width: (t ? r : i).width,
			height: (t ? i : r).height
		}) : (r = e, {
			cx: (i = n.getArea()).cx,
			cy: i.cy,
			r0: (t ? i : r).r0,
			r: (t ? i : r).r,
			startAngle: t ? r.startAngle : 0,
			endAngle: t ? r.endAngle : 2 * Math.PI
		})
	}
	n1(function(t) {
		t.registerChartView(Kx), t.registerSeriesModel(Ox), t.registerLayout(t.PRIORITY.VISUAL.LAYOUT, dt(
			x_, "bar")), t.registerLayout(t.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, {
			seriesType: "bar",
			plan: cy(),
			reset: function(t) {
				var e, x, n, w, b, S, i, r, M, T, C, I, k, D, A, P;
				if (w_(t)) return e = t.getData(), i = (x = t.coordinateSystem).getBaseAxis(),
					n = x.getOtherAxis(i), w = e.getDimensionIndex(e.mapDimension(n.dim)),
					b = e.getDimensionIndex(e.mapDimension(i.dim)), S = t.get(
						"showBackground", !0), i = e.mapDimension(n.dim), r = e
					.getCalculationInfo("stackResultDimension"), M = Gv(e, i) && !!e
					.getCalculationInfo("stackedOnSeries"), T = n.isHorizontal(), C = n
					.toGlobalCoord(n.dataToCoord("log" === n.type ? 1 : 0)), I = b_(t), k =
					t.get("barMinHeight") || 0, D = r && e.getDimensionIndex(r), A = e
					.getLayout("size"), P = e.getLayout("offset"), {
						progress: function(t, e) {
							for (var n, i = t.count, r = I && f_(3 * i), o = I && S &&
									f_(3 * i), a = I && f_(i), s = x.master.getRect(),
									l = T ? s.width : s.height, u = e.getStore(), h =
									0; null != (n = t.next());) {
								var c, p = u.get(M ? D : w, n),
									d = u.get(b, n),
									f = C,
									g = void 0,
									y = (M && (g = +p - u.get(w, n)), void 0),
									m = void 0,
									v = void 0,
									_ = void 0;
								T ? (c = x.dataToPoint([p, d]), y = f = M ? x
										.dataToPoint([g, d])[0] : f, m = c[1] + P, v =
										c[0] - f, _ = A, Math.abs(v) < k && (v = (v <
											0 ? -1 : 1) * k)) : (c = x.dataToPoint([d,
											p
										]), M && (f = x.dataToPoint([d, g])[1]),
										y = c[0] + P, m = f, v = A, _ = c[1] - f, Math
										.abs(_) < k && (_ = (_ <= 0 ? -1 : 1) * k)), I ?
									(r[h] = y, r[h + 1] = m, r[h + 2] = T ? v : _, o &&
										(o[h] = T ? s.x : y, o[h + 1] = T ? m : s.y, o[
											h + 2] = l), a[n] = n) : e.setItemLayout(
										n, {
											x: y,
											y: m,
											width: v,
											height: _
										}), h += 3
							}
							I && e.setLayout({
								largePoints: r,
								largeDataIndices: a,
								largeBackgroundPoints: o,
								valueAxisHorizontal: T
							})
						}
					}
			}
		}), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, Dx("bar")), t.registerAction({
			type: "changeAxisOrder",
			event: "changeAxisOrder",
			update: "update"
		}, function(e, t) {
			var n = e.componentType || "series";
			t.eachComponent({
				mainType: n,
				query: e
			}, function(t) {
				e.sortInfo && t.axis.setCategorySortInfo(e.sortInfo)
			})
		})
	});
	u(mw, gw = ey), mw.prototype.getInitialData = function(t) {
		return Uv(null, this, {
			useEncodeDefaulter: !0
		})
	}, mw.prototype.getLegendIcon = function(t) {
		var e = new no,
			n = ym("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1),
			n = (e.add(n), n.setStyle(t.lineStyle), this.getData().getVisual("symbol")),
			i = this.getData().getVisual("symbolRotate"),
			n = "none" === n ? "circle" : n,
			r = .8 * t.itemHeight,
			r = ym(n, (t.itemWidth - r) / 2, (t.itemHeight - r) / 2, r, r, t.itemStyle.fill),
			i = (e.add(r), r.setStyle(t.itemStyle), "inherit" === t.iconRotate ? i : t.iconRotate || 0);
		return r.rotation = i * Math.PI / 180, r.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), -1 < n.indexOf(
			"empty") && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), e
	}, mw.type = "series.line", mw.dependencies = ["grid", "polar"], mw.defaultOption = {
		z: 3,
		coordinateSystem: "cartesian2d",
		legendHoverLink: !0,
		clip: !0,
		label: {
			position: "top"
		},
		endLabel: {
			show: !1,
			valueAnimation: !0,
			distance: 8
		},
		lineStyle: {
			width: 2,
			type: "solid"
		},
		emphasis: {
			scale: !0
		},
		step: !1,
		smooth: !1,
		smoothMonotone: null,
		symbol: "emptyCircle",
		symbolSize: 4,
		symbolRotate: null,
		showSymbol: !0,
		showAllSymbol: "auto",
		connectNulls: !1,
		sampling: "none",
		animationEasing: "linear",
		progressive: 0,
		hoverLayerThreshold: 1 / 0,
		universalTransition: {
			divideShape: "clone"
		},
		triggerLineEvent: !1
	};
	var gw, yw = mw;

	function mw() {
		var t = null !== gw && gw.apply(this, arguments) || this;
		return t.type = mw.type, t.hasSymbolVisual = !0, t
	}
	u(xw, vw = no), xw.prototype._createSymbol = function(t, e, n, i, r) {
		this.removeAll();
		r = ym(t, -1, -1, 2, 2, null, r);
		r.attr({
			z2: 100,
			culling: !0,
			scaleX: i[0] / 2,
			scaleY: i[1] / 2
		}), r.drift = ww, this._symbolType = t, this.add(r)
	}, xw.prototype.stopSymbolAnimation = function(t) {
		this.childAt(0).stopAnimation(null, t)
	}, xw.prototype.getSymbolType = function() {
		return this._symbolType
	}, xw.prototype.getSymbolPath = function() {
		return this.childAt(0)
	}, xw.prototype.highlight = function() {
		Gl(this.childAt(0))
	}, xw.prototype.downplay = function() {
		Wl(this.childAt(0))
	}, xw.prototype.setZ = function(t, e) {
		var n = this.childAt(0);
		n.zlevel = t, n.z = e
	}, xw.prototype.setDraggable = function(t, e) {
		var n = this.childAt(0);
		n.draggable = t, n.cursor = !e && t ? "move" : n.cursor
	}, xw.prototype.updateData = function(t, e, n, i) {
		this.silent = !1;
		var r, o, a, s = t.getItemVisual(e, "symbol") || "circle",
			l = t.hostModel,
			u = xw.getSymbolSize(t, e),
			h = s !== this._symbolType,
			c = i && i.disableAnimation;
		h ? (r = t.getItemVisual(e, "symbolKeepAspect"), this._createSymbol(s, t, e, u, r)) : ((a = this
				.childAt(0)).silent = !1, o = {
				scaleX: u[0] / 2,
				scaleY: u[1] / 2
			}, c ? a.attr(o) : qh(a, o, l, e), Jh(a)), this._updateCommon(t, e, u, n, i), h && (a = this
				.childAt(0), c || (o = {
					scaleX: this._sizeX,
					scaleY: this._sizeY,
					style: {
						opacity: a.style.opacity
					}
				}, a.scaleX = a.scaleY = 0, a.style.opacity = 0, jh(a, o, l, e))), c && this.childAt(0)
			.stopAnimation("leave")
	}, xw.prototype._updateCommon = function(e, t, n, i, r) {
		var o, a, s, l, u, h, c, p, d = this.childAt(0),
			f = e.hostModel,
			g = (i && (o = i.emphasisItemStyle, s = i.blurItemStyle, a = i.selectItemStyle, l = i.focus, u = i
				.blurScope, c = i.labelStatesModels, p = i.hoverScale, y = i.cursorStyle, h = i
				.emphasisDisabled), i && !e.hasItemOption || (o = (g = (i = i && i.itemModel ? i.itemModel :
					e.getItemModel(t)).getModel("emphasis")).getModel("itemStyle").getItemStyle(), a = i
				.getModel(["select", "itemStyle"]).getItemStyle(), s = i.getModel(["blur", "itemStyle"])
				.getItemStyle(), l = g.get("focus"), u = g.get("blurScope"), h = g.get("disabled"), c = Pc(
					i), p = g.getShallow("scale"), y = i.getShallow("cursor")), e.getItemVisual(t,
				"symbolRotate")),
			i = (d.attr("rotation", (g || 0) * Math.PI / 180 || 0), mm(e.getItemVisual(t, "symbolOffset"), n)),
			g = (i && (d.x = i[0], d.y = i[1]), y && d.attr("cursor", y), e.getItemVisual(t, "style")),
			i = g.fill,
			y = (d instanceof Es ? (y = d.style, d.useStyle(O({
				image: y.image,
				x: y.x,
				y: y.y,
				width: y.width,
				height: y.height
			}, g))) : (d.__isEmptyBrush ? d.useStyle(O({}, g)) : d.useStyle(g), d.style.decal = null, d
				.setColor(i, r && r.symbolInnerColor), d.style.strokeNoScale = !0), e.getItemVisual(t,
				"liftZ")),
			m = this._z2,
			v = (null != y ? null == m && (this._z2 = d.z2, d.z2 += y) : null != m && (d.z2 = m, this._z2 =
				null), r && r.useNameLabel),
			y = (Ac(d, c, {
				labelFetcher: f,
				labelDataIndex: t,
				defaultText: function(t) {
					return v ? e.getName(t) : Gx(e, t)
				},
				inheritColor: i,
				defaultOpacity: g.opacity
			}), this._sizeX = n[0] / 2, this._sizeY = n[1] / 2, d.ensureState("emphasis")),
			m = (y.style = o, d.ensureState("select").style = a, d.ensureState("blur").style = s, null == p || !
				0 === p ? Math.max(1.1, 3 / this._sizeY) : isFinite(p) && 0 < p ? +p : 1);
		y.scaleX = this._sizeX * m, y.scaleY = this._sizeY * m, this.setSymbolScale(1), tu(this, l, u, h)
	}, xw.prototype.setSymbolScale = function(t) {
		this.scaleX = this.scaleY = t
	}, xw.prototype.fadeOut = function(t, e, n) {
		var i = this.childAt(0),
			r = k(this).dataIndex,
			o = n && n.animation;
		this.silent = i.silent = !0, n && n.fadeLabel ? (n = i.getTextContent()) && Kh(n, {
			style: {
				opacity: 0
			}
		}, e, {
			dataIndex: r,
			removeOpt: o,
			cb: function() {
				i.removeTextContent()
			}
		}) : i.removeTextContent(), Kh(i, {
			style: {
				opacity: 0
			},
			scaleX: 0,
			scaleY: 0
		}, e, {
			dataIndex: r,
			cb: t,
			removeOpt: o
		})
	}, xw.getSymbolSize = function(t, e) {
		return [(t = V(t = t.getItemVisual(e, "symbolSize")) ? t : [+t, +t])[0] || 0, t[1] || 0]
	};
	var vw, _w = xw;

	function xw(t, e, n, i) {
		var r = vw.call(this) || this;
		return r.updateData(t, e, n, i), r
	}

	function ww(t, e) {
		this.parent.drift(t, e)
	}

	function bw(t, e, n, i) {
		return e && !isNaN(e[0]) && !isNaN(e[1]) && (!i.isIgnore || !i.isIgnore(n)) && (!i.clipShape || i.clipShape
			.contain(e[0], e[1])) && "none" !== t.getItemVisual(n, "symbol")
	}

	function Sw(t) {
		return (t = null == t || L(t) ? t : {
			isIgnore: t
		}) || {}
	}

	function Mw(t) {
		var t = t.hostModel,
			e = t.getModel("emphasis");
		return {
			emphasisItemStyle: e.getModel("itemStyle").getItemStyle(),
			blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(),
			selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(),
			focus: e.get("focus"),
			blurScope: e.get("blurScope"),
			emphasisDisabled: e.get("disabled"),
			hoverScale: e.get("scale"),
			labelStatesModels: Pc(t),
			cursorStyle: t.get("cursor")
		}
	}
	Cw.prototype.updateData = function(o, a) {
		this._progressiveEls = null, a = Sw(a);
		var s = this.group,
			l = o.hostModel,
			u = this._data,
			h = this._SymbolCtor,
			c = a.disableAnimation,
			p = Mw(o),
			d = {
				disableAnimation: c
			},
			f = a.getSymbolPoint || function(t) {
				return o.getItemLayout(t)
			};
		u || s.removeAll(), o.diff(u).add(function(t) {
			var e, n = f(t);
			bw(o, n, t, a) && ((e = new h(o, t, p, d)).setPosition(n), o.setItemGraphicEl(t, e), s.add(
				e))
		}).update(function(t, e) {
			var n, i, e = u.getItemGraphicEl(e),
				r = f(t);
			bw(o, r, t, a) ? (n = o.getItemVisual(t, "symbol") || "circle", i = e && e.getSymbolType &&
				e.getSymbolType(), !e || i && i !== n ? (s.remove(e), (e = new h(o, t, p, d))
					.setPosition(r)) : (e.updateData(o, t, p, d), i = {
					x: r[0],
					y: r[1]
				}, c ? e.attr(i) : qh(e, i, l)), s.add(e), o.setItemGraphicEl(t, e)) : s.remove(e)
		}).remove(function(t) {
			var e = u.getItemGraphicEl(t);
			e && e.fadeOut(function() {
				s.remove(e)
			}, l)
		}).execute(), this._getSymbolPoint = f, this._data = o
	}, Cw.prototype.updateLayout = function() {
		var n = this,
			t = this._data;
		t && t.eachItemGraphicEl(function(t, e) {
			e = n._getSymbolPoint(e);
			t.setPosition(e), t.markRedraw()
		})
	}, Cw.prototype.incrementalPrepareUpdate = function(t) {
		this._seriesScope = Mw(t), this._data = null, this.group.removeAll()
	}, Cw.prototype.incrementalUpdate = function(t, e, n) {
		function i(t) {
			t.isGroup || (t.incremental = !0, t.ensureState("emphasis").hoverLayer = !0)
		}
		this._progressiveEls = [], n = Sw(n);
		for (var r = t.start; r < t.end; r++) {
			var o, a = e.getItemLayout(r);
			bw(e, a, r, n) && ((o = new this._SymbolCtor(e, r, this._seriesScope)).traverse(i), o.setPosition(
				a), this.group.add(o), e.setItemGraphicEl(r, o), this._progressiveEls.push(o))
		}
	}, Cw.prototype.eachRendered = function(t) {
		Tc(this._progressiveEls || this.group, t)
	}, Cw.prototype.remove = function(t) {
		var e = this.group,
			n = this._data;
		n && t ? n.eachItemGraphicEl(function(t) {
			t.fadeOut(function() {
				e.remove(t)
			}, n.hostModel)
		}) : e.removeAll()
	};
	var Tw = Cw;

	function Cw(t) {
		this.group = new no, this._SymbolCtor = t || _w
	}

	function Iw(t, e, n) {
		var i = t.getBaseAxis(),
			r = t.getOtherAxis(i),
			n = (n = n, a = 0, o = (o = r).scale.getExtent(), "start" === n ? a = o[0] : "end" === n ? a = o[1] : G(
				n) && !isNaN(n) ? a = n : 0 < o[0] ? a = o[0] : o[1] < 0 && (a = o[1]), a),
			o = i.dim,
			a = r.dim,
			i = e.mapDimension(a),
			r = e.mapDimension(o),
			s = "x" === a || "radius" === a ? 1 : 0,
			t = F(t.dimensions, function(t) {
				return e.mapDimension(t)
			}),
			l = !1,
			u = e.getCalculationInfo("stackResultDimension");
		return Gv(e, t[0]) && (l = !0, t[0] = u), Gv(e, t[1]) && (l = !0, t[1] = u), {
			dataDimsForPoint: t,
			valueStart: n,
			valueAxisDim: a,
			baseAxisDim: o,
			stacked: !!l,
			valueDim: i,
			baseDim: r,
			baseDataOffset: s,
			stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
		}
	}

	function kw(t, e, n, i) {
		var r = NaN,
			o = (t.stacked && (r = n.get(n.getCalculationInfo("stackedOverDimension"), i)), isNaN(r) && (r = t
				.valueStart), t.baseDataOffset),
			a = [];
		return a[o] = n.get(t.baseDim, i), a[1 - o] = r, e.dataToPoint(a)
	}
	var Dw = Math.min,
		Aw = Math.max;

	function Pw(t, e) {
		return isNaN(t) || isNaN(e)
	}

	function Lw(t, e, n, i, r, o, a, s, l) {
		for (var u, h, c, p, d = n, f = 0; f < i; f++) {
			var g = e[2 * d],
				y = e[2 * d + 1];
			if (r <= d || d < 0) break;
			if (Pw(g, y)) {
				if (l) {
					d += o;
					continue
				}
				break
			}
			if (d === n) t[0 < o ? "moveTo" : "lineTo"](g, y), c = g, p = y;
			else {
				var m = g - u,
					v = y - h;
				if (m * m + v * v < .5) {
					d += o;
					continue
				}
				if (0 < a) {
					for (var _ = d + o, x = e[2 * _], w = e[2 * _ + 1]; x === g && w === y && f < i;) f++, d += o,
						x = e[2 * (_ += o)], w = e[2 * _ + 1], g = e[2 * d], y = e[2 * d + 1];
					var b = f + 1;
					if (l)
						for (; Pw(x, w) && b < i;) b++, x = e[2 * (_ += o)], w = e[2 * _ + 1];
					var S, M, T, C, I, k, D, A, P, m = 0,
						v = 0,
						L = void 0,
						O = void 0;
					i <= b || Pw(x, w) ? (D = g, A = y) : (m = x - u, v = w - h, S = g - u, M = x - g, T = y - h,
							C = w - y, k = I = void 0, O = "x" === s ? (D = g - (P = 0 < m ? 1 : -1) * (I = Math
								.abs(S)) * a, A = y, L = g + P * (k = Math.abs(M)) * a, y) : "y" === s ? (D = g, A =
								y - (P = 0 < v ? 1 : -1) * (I = Math.abs(T)) * a, L = g, y + P * (k = Math.abs(C)) *
								a) : (I = Math.sqrt(S * S + T * T), D = g - m * a * (1 - (S = (k = Math.sqrt(M * M +
								C * C)) / (k + I))), A = y - v * a * (1 - S), O = y + v * a * S, L = Dw(L = g +
								m * a * S, Aw(x, g)), O = Dw(O, Aw(w, y)), L = Aw(L, Dw(x, g)), A = y - (v = (
								O = Aw(O, Dw(w, y))) - y) * I / k, D = Dw(D = g - (m = L - g) * I / k, Aw(u,
								g)), A = Dw(A, Aw(h, y)), L = g + (m = g - (D = Aw(D, Dw(u, g)))) * k / I, y + (
								v =
								y - (A = Aw(A, Dw(h, y)))) * k / I)), t.bezierCurveTo(c, p, D, A, g, y), c = L,
						p = O
				} else t.lineTo(g, y)
			}
			u = g, h = y, d += o
		}
		return f
	}

	function Ow() {
		this.smooth = 0, this.smoothConstraint = !0
	}
	u(Ew, Rw = Z), Ew.prototype.getDefaultStyle = function() {
		return {
			stroke: "#000",
			fill: null
		}
	}, Ew.prototype.getDefaultShape = function() {
		return new Ow
	}, Ew.prototype.buildPath = function(t, e) {
		var n = e.points,
			i = 0,
			r = n.length / 2;
		if (e.connectNulls) {
			for (; 0 < r && Pw(n[2 * r - 2], n[2 * r - 1]); r--);
			for (; i < r && Pw(n[2 * i], n[2 * i + 1]); i++);
		}
		for (; i < r;) i += Lw(t, n, i, r, r, 1, e.smooth, e.smoothMonotone, e.connectNulls) + 1
	}, Ew.prototype.getPointOn = function(t, e) {
		this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
		for (var n, i, r = this.path.data, o = cs.CMD, a = "x" === e, s = [], l = 0; l < r.length;) {
			var u, h = void 0,
				c = void 0;
			switch (r[l++]) {
				case o.M:
					n = r[l++], i = r[l++];
					break;
				case o.L:
					var p, h = r[l++],
						c = r[l++];
					if ((u = a ? (t - n) / (h - n) : (t - i) / (c - i)) <= 1 && 0 <= u) return p = a ? (c - i) *
						u + i : (h - n) * u + n, a ? [t, p] : [p, t];
					n = h, i = c;
					break;
				case o.C:
					h = r[l++], c = r[l++];
					var d = r[l++],
						f = r[l++],
						g = r[l++],
						y = r[l++],
						m = a ? Fn(n, h, d, g, t, s) : Fn(i, c, f, y, t, s);
					if (0 < m)
						for (var v = 0; v < m; v++) {
							var _ = s[v];
							if (_ <= 1 && 0 <= _) return p = a ? zn(i, c, f, y, _) : zn(n, h, d, g, _), a ? [t,
								p
							] : [p, t]
						}
					n = g, i = y
			}
		}
	};
	var Rw, Nw = Ew;

	function Ew(t) {
		t = Rw.call(this, t) || this;
		return t.type = "ec-polyline", t
	}
	u(Gw, Bw = Ow);
	var zw, Bw, Fw = Gw,
		Vw = (u(Hw, zw = Z), Hw.prototype.getDefaultShape = function() {
			return new Fw
		}, Hw.prototype.buildPath = function(t, e) {
			var n = e.points,
				i = e.stackedOnPoints,
				r = 0,
				o = n.length / 2,
				a = e.smoothMonotone;
			if (e.connectNulls) {
				for (; 0 < o && Pw(n[2 * o - 2], n[2 * o - 1]); o--);
				for (; r < o && Pw(n[2 * r], n[2 * r + 1]); r++);
			}
			for (; r < o;) {
				var s = Lw(t, n, r, o, o, 1, e.smooth, a, e.connectNulls);
				Lw(t, i, r + s - 1, s, o, -1, e.stackedOnSmooth, a, e.connectNulls), r += s + 1, t.closePath()
			}
		}, Hw);

	function Hw(t) {
		t = zw.call(this, t) || this;
		return t.type = "ec-polygon", t
	}

	function Gw() {
		return null !== Bw && Bw.apply(this, arguments) || this
	}

	function Ww(t, e) {
		if (t.length === e.length) {
			for (var n = 0; n < t.length; n++)
				if (t[n] !== e[n]) return;
			return 1
		}
	}

	function Uw(t) {
		for (var e = 1 / 0, n = 1 / 0, i = -1 / 0, r = -1 / 0, o = 0; o < t.length;) {
			var a = t[o++],
				s = t[o++];
			isNaN(a) || (e = Math.min(a, e), i = Math.max(a, i)), isNaN(s) || (n = Math.min(s, n), r = Math.max(s,
				r))
		}
		return [
			[e, n],
			[i, r]
		]
	}

	function Xw(t, e) {
		var t = Uw(t),
			n = t[0],
			t = t[1],
			e = Uw(e),
			i = e[0],
			e = e[1];
		return Math.max(Math.abs(n[0] - i[0]), Math.abs(n[1] - i[1]), Math.abs(t[0] - e[0]), Math.abs(t[1] - e[1]))
	}

	function Yw(t) {
		return G(t) ? t : t ? .5 : 0
	}

	function qw(t, e, n, i) {
		var e = e.getBaseAxis(),
			r = "x" === e.dim || "radius" === e.dim ? 0 : 1,
			o = [],
			a = 0,
			s = [],
			l = [],
			u = [],
			h = [];
		if (i) {
			for (a = 0; a < t.length; a += 2) isNaN(t[a]) || isNaN(t[a + 1]) || h.push(t[a], t[a + 1]);
			t = h
		}
		for (a = 0; a < t.length - 2; a += 2) switch (u[0] = t[a + 2], u[1] = t[a + 3], l[0] = t[a], l[1] = t[a +
				1], o.push(l[0], l[1]), n) {
			case "end":
				s[r] = u[r], s[1 - r] = l[1 - r], o.push(s[0], s[1]);
				break;
			case "middle":
				var c = [];
				s[r] = c[r] = (l[r] + u[r]) / 2, s[1 - r] = l[1 - r], c[1 - r] = u[1 - r], o.push(s[0], s[1]), o
					.push(c[0], c[1]);
				break;
			default:
				s[r] = l[r], s[1 - r] = u[1 - r], o.push(s[0], s[1])
		}
		return o.push(t[a++], t[a++]), o
	}

	function jw(t, e, n) {
		var i = t.getVisual("visualMeta");
		if (i && i.length && t.count() && "cartesian2d" === e.type) {
			for (var r, o, a = i.length - 1; 0 <= a; a--) {
				var s = t.getDimensionInfo(i[a].dimension);
				if ("x" === (r = s && s.coordDim) || "y" === r) {
					o = i[a];
					break
				}
			}
			if (o) {
				var l = e.getAxis(r),
					e = F(o.stops, function(t) {
						return {
							coord: l.toGlobalCoord(l.dataToCoord(t.value)),
							color: t.color
						}
					}),
					u = e.length,
					h = o.outerColors.slice(),
					n = (u && e[0].coord > e[u - 1].coord && (e.reverse(), h.reverse()), function(t, e) {
						var n, i, r = [],
							o = t.length;

						function a(t, e, n) {
							var i = t.coord;
							return {
								coord: n,
								color: _i((n - i) / (e.coord - i), [t.color, e.color])
							}
						}
						for (var s = 0; s < o; s++) {
							var l = t[s],
								u = l.coord;
							if (u < 0) n = l;
							else {
								if (e < u) {
									i ? r.push(a(i, l, e)) : n && r.push(a(n, l, 0), a(n, l, e));
									break
								}
								n && (r.push(a(n, l, 0)), n = null), r.push(l), i = l
							}
						}
						return r
					}(e, "x" === r ? n.getWidth() : n.getHeight())),
					c = n.length;
				if (!c && u) return e[0].coord < 0 ? h[1] || e[u - 1].color : h[0] || e[0].color;
				var p = n[0].coord - 10,
					u = n[c - 1].coord + 10,
					d = u - p;
				if (d < .001) return "transparent";
				E(n, function(t) {
					t.offset = (t.coord - p) / d
				}), n.push({
					offset: c ? n[c - 1].offset : .5,
					color: h[1] || "transparent"
				}), n.unshift({
					offset: c ? n[0].offset : .5,
					color: h[0] || "transparent"
				});
				e = new Lh(0, 0, 0, 0, n, !0);
				return e[r] = p, e[r + "2"] = u, e
			}
		}
	}

	function Zw(t, e, n) {
		var t = t.get("showAllSymbol"),
			i = "auto" === t;
		if (!t || i) {
			var r, o, a = n.getAxesByScale("ordinal")[0];
			if (a && (!i || ! function(t, e) {
					var n = t.getExtent(),
						i = Math.abs(n[1] - n[0]) / t.scale.count();
					isNaN(i) && (i = 0);
					for (var r = e.count(), o = Math.max(1, Math.round(r / 5)), a = 0; a < r; a += o)
						if (1.5 * _w.getSymbolSize(e, a)[t.isHorizontal() ? 1 : 0] > i) return;
					return 1
				}(a, e))) return r = e.mapDimension(a.dim), o = {}, E(a.getViewLabels(), function(t) {
					t = a.scale.getRawOrdinalNumber(t.tickValue);
					o[t] = 1
				}),
				function(t) {
					return !o.hasOwnProperty(e.get(r, t))
				}
		}
	}

	function Kw(t) {
		for (var e, n, i = t.length / 2; 0 < i && (e = t[2 * i - 2], n = t[2 * i - 1], isNaN(e) || isNaN(n)); i--);
		return i - 1
	}

	function $w(t, e) {
		return [t[2 * e], t[2 * e + 1]]
	}

	function Qw(t) {
		if (t.get(["endLabel", "show"])) return 1;
		for (var e = 0; e < ml.length; e++)
			if (t.get([ml[e], "endLabel", "show"])) return 1
	}

	function Jw(n, i, e, t) {
		var r, o, a, s, l, u, h, c, p;
		return Hx(i, "cartesian2d") ? (r = t.getModel("endLabel"), o = r.get("valueAnimation"), a = t.getData(),
			s = {
				lastFrameIndex: 0
			}, l = Qw(t) ? function(t, e) {
				n._endLabelOnDuring(t, e, a, s, o, r, i)
			} : null, u = i.getBaseAxis().isHorizontal(), h = Nx(i, e, t, function() {
				var t = n._endLabel;
				t && e && null != s.originalX && t.attr({
					x: s.originalX,
					y: s.originalY
				})
			}, l), t.get("clip", !0) || (c = h.shape, p = Math.max(c.width, c.height), u ? (c.y -= p, c
				.height += 2 * p) : (c.x -= p, c.width += 2 * p)), l && l(1, h), h) : Ex(i, e, t)
	}
	u(nb, tb = fy), nb.prototype.init = function() {
		var t = new no,
			e = new Tw;
		this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
	}, nb.prototype.render = function(t, e, n) {
		var i = this,
			r = t.coordinateSystem,
			o = this.group,
			a = t.getData(),
			s = t.getModel("lineStyle"),
			l = t.getModel("areaStyle"),
			u = a.getLayout("points") || [],
			h = "polar" === r.type,
			c = this._coordSys,
			p = this._symbolDraw,
			d = this._polyline,
			f = this._polygon,
			g = this._lineGroup,
			e = !e.ssr && t.isAnimationEnabled(),
			y = !l.isEmpty(),
			m = l.get("origin"),
			v = Iw(r, a, m),
			v = y && function(t, e, n) {
				if (!n.valueDim) return [];
				for (var i = e.count(), r = f_(2 * i), o = 0; o < i; o++) {
					var a = kw(n, t, e, o);
					r[2 * o] = a[0], r[2 * o + 1] = a[1]
				}
				return r
			}(r, a, v),
			_ = t.get("showSymbol"),
			x = t.get("connectNulls"),
			w = _ && !h && Zw(t, a, r),
			b = this._data;
		b && b.eachItemGraphicEl(function(t, e) {
			t.__temp && (o.remove(t), b.setItemGraphicEl(e, null))
		}), _ || p.remove(), o.add(g);

		function S(t) {
			i._changePolyState(t)
		}
		var M, T = !h && t.get("step"),
			C = (r && r.getArea && t.get("clip", !0) && (null != (M = r.getArea()).width ? (M.x -= .1, M.y -=
					.1, M.width += .2, M.height += .2) : M.r0 && (M.r0 -= .5, M.r += .5)), this
				._clipShapeForSymbol = M, jw(a, r, n) || a.getVisual("style")[a.getVisual("drawType")]),
			c = (d && c.type === r.type && T === this._step ? (y && !f ? f = this._newPolygon(u, v) : f && !y &&
				(g.remove(f), f = this._polygon = null), h || this._initOrUpdateEndLabel(t, r, Xp(C)), (c =
					g.getClipPath()) ? jh(c, {
					shape: Jw(this, r, !1, t).shape
				}, t) : g.setClipPath(Jw(this, r, !0, t)), _ && p.updateData(a, {
					isIgnore: w,
					clipShape: M,
					disableAnimation: !0,
					getSymbolPoint: function(t) {
						return [u[2 * t], u[2 * t + 1]]
					}
				}), Ww(this._stackedOnPoints, v) && Ww(this._points, u) || (e ? this._doUpdateAnimation(a,
					v, r, n, T, m, x) : (T && (u = qw(u, r, T, x), v = v && qw(v, r, T, x)), d
					.setShape({
						points: u
					}), f && f.setShape({
						points: u,
						stackedOnPoints: v
					})))) : (_ && p.updateData(a, {
				isIgnore: w,
				clipShape: M,
				disableAnimation: !0,
				getSymbolPoint: function(t) {
					return [u[2 * t], u[2 * t + 1]]
				}
			}), e && this._initSymbolLabelAnimation(a, r, M), T && (u = qw(u, r, T, x), v = v && qw(v,
				r, T, x)), d = this._newPolyline(u), y ? f = this._newPolygon(u, v) : f && (g.remove(f),
				f = this._polygon = null), h || this._initOrUpdateEndLabel(t, r, Xp(C)), g.setClipPath(
				Jw(this, r, !0, t))), t.getModel("emphasis")),
			n = c.get("focus"),
			_ = c.get("blurScope"),
			p = c.get("disabled"),
			w = (d.useStyle(B(s.getLineStyle(), {
					fill: "none",
					stroke: C,
					lineJoin: "bevel"
				})), iu(d, t, "lineStyle"), 0 < d.style.lineWidth && "bolder" === t.get(["emphasis",
					"lineStyle", "width"
				]) && (d.getState("emphasis").style.lineWidth = +d.style.lineWidth + 1), k(d).seriesIndex = t
				.seriesIndex, tu(d, n, _, p), Yw(t.get("smooth"))),
			e = t.get("smoothMonotone");
		d.setShape({
			smooth: w,
			smoothMonotone: e,
			connectNulls: x
		}), f && (M = a.getCalculationInfo("stackedOnSeries"), y = 0, f.useStyle(B(l.getAreaStyle(), {
			fill: C,
			opacity: .7,
			lineJoin: "bevel",
			decal: a.getVisual("style").decal
		})), M && (y = Yw(M.get("smooth"))), f.setShape({
			smooth: w,
			stackedOnSmooth: y,
			smoothMonotone: e,
			connectNulls: x
		}), iu(f, t, "areaStyle"), k(f).seriesIndex = t.seriesIndex, tu(f, n, _, p));
		a.eachItemGraphicEl(function(t) {
				t && (t.onHoverStateChange = S)
			}), this._polyline.onHoverStateChange = S, this._data = a, this._coordSys = r, this
			._stackedOnPoints = v, this._points = u, this._step = T, this._valueOrigin = m, t.get(
				"triggerLineEvent") && (this.packEventData(t, d), f) && this.packEventData(t, f)
	}, nb.prototype.packEventData = function(t, e) {
		k(e).eventData = {
			componentType: "series",
			componentSubType: "line",
			componentIndex: t.componentIndex,
			seriesIndex: t.seriesIndex,
			seriesName: t.name,
			seriesType: "line"
		}
	}, nb.prototype.highlight = function(t, e, n, i) {
		var r = t.getData(),
			o = Xo(r, i);
		if (this._changePolyState("emphasis"), !(o instanceof Array) && null != o && 0 <= o) {
			var a = r.getLayout("points"),
				s = r.getItemGraphicEl(o);
			if (!s) {
				var l = a[2 * o],
					a = a[2 * o + 1];
				if (isNaN(l) || isNaN(a)) return;
				if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(l, a)) return;
				var u = t.get("zlevel") || 0,
					h = t.get("z") || 0,
					l = ((s = new _w(r, o)).x = l, s.y = a, s.setZ(u, h), s.getSymbolPath().getTextContent());
				l && (l.zlevel = u, l.z = h, l.z2 = this._polyline.z2 + 1), s.__temp = !0, r.setItemGraphicEl(o,
					s), s.stopSymbolAnimation(!0), this.group.add(s)
			}
			s.highlight()
		} else fy.prototype.highlight.call(this, t, e, n, i)
	}, nb.prototype.downplay = function(t, e, n, i) {
		var r, o = t.getData(),
			a = Xo(o, i);
		this._changePolyState("normal"), null != a && 0 <= a ? (r = o.getItemGraphicEl(a)) && (r.__temp ? (o
			.setItemGraphicEl(a, null), this.group.remove(r)) : r.downplay()) : fy.prototype.downplay.call(
			this, t, e, n, i)
	}, nb.prototype._changePolyState = function(t) {
		var e = this._polygon;
		El(this._polyline, t), e && El(e, t)
	}, nb.prototype._newPolyline = function(t) {
		var e = this._polyline;
		return e && this._lineGroup.remove(e), e = new Nw({
			shape: {
				points: t
			},
			segmentIgnoreThreshold: 2,
			z2: 10
		}), this._lineGroup.add(e), this._polyline = e
	}, nb.prototype._newPolygon = function(t, e) {
		var n = this._polygon;
		return n && this._lineGroup.remove(n), n = new Vw({
			shape: {
				points: t,
				stackedOnPoints: e
			},
			segmentIgnoreThreshold: 2
		}), this._lineGroup.add(n), this._polygon = n
	}, nb.prototype._initSymbolLabelAnimation = function(t, l, u) {
		var h, c, e = l.getBaseAxis(),
			p = e.inverse,
			e = ("cartesian2d" === l.type ? (h = e.isHorizontal(), c = !1) : "polar" === l.type && (h =
				"angle" === e.dim, c = !0), t.hostModel),
			d = e.get("animationDuration"),
			f = (S(d) && (d = d(null)), e.get("animationDelay") || 0),
			g = S(f) ? f(null) : f;
		t.eachItemGraphicEl(function(t, e) {
			var n, i, r, o, a, s = t;
			s && (o = [t.x, t.y], a = i = n = void 0, u && (a = c ? (r = u, o = l.pointToCoord(o), h ? (
					n = r.startAngle, i = r.endAngle, -o[1] / 180 * Math.PI) : (n = r.r0,
					i = r.r, o[0])) : h ? (n = u.x, i = u.x + u.width, t.x) : (n = u.y + u
					.height, i = u.y, t.y)), r = i === n ? 0 : (a - n) / (i - n), p && (r = 1 - r),
				o = S(f) ? f(e) : d * r + g, a = (t = s.getSymbolPath()).getTextContent(), s.attr({
					scaleX: 0,
					scaleY: 0
				}), s.animateTo({
					scaleX: 1,
					scaleY: 1
				}, {
					duration: 200,
					setToFinal: !0,
					delay: o
				}), a && a.animateFrom({
					style: {
						opacity: 0
					}
				}, {
					duration: 300,
					delay: o
				}), t.disableLabelAnimation = !0)
		})
	}, nb.prototype._initOrUpdateEndLabel = function(t, e, n) {
		var i, r, o, a = t.getModel("endLabel");
		Qw(t) ? (i = t.getData(), r = this._polyline, (o = i.getLayout("points")) ? (this._endLabel || ((this
					._endLabel = new Ks({
						z2: 200
					})).ignoreClip = !0, r.setTextContent(this._endLabel), r.disableLabelAnimation = !0),
				0 <= (o = Kw(o)) && (Ac(r, Pc(t, "endLabel"), {
					inheritColor: n,
					labelFetcher: t,
					labelDataIndex: o,
					defaultText: function(t, e, n) {
						return null != n ? Wx(i, n) : Gx(i, t)
					},
					enableTextSetter: !0
				}, (n = a, o = (t = (t = e).getBaseAxis()).isHorizontal(), t = t.inverse, a = o ?
					t ? "right" : "left" : "center", o = o ? "middle" : t ? "top" : "bottom", {
						normal: {
							align: n.get("align") || a,
							verticalAlign: n.get("verticalAlign") || o
						}
					})), r.textConfig.position = null)) : (r.removeTextContent(), this._endLabel = null)) : this
			._endLabel && (this._polyline.removeTextContent(), this._endLabel = null)
	}, nb.prototype._endLabelOnDuring = function(t, e, n, i, r, o, a) {
		var s, l, u, h, c, p, d, f, g, y, m = this._endLabel,
			v = this._polyline;
		m && (t < 1 && null == i.originalX && (i.originalX = m.x, i.originalY = m.y), s = n.getLayout("points"),
			g = (l = n.hostModel).get("connectNulls"), u = o.get("precision"), o = o.get("distance") || 0,
			c = (a = a.getBaseAxis()).isHorizontal(), a = a.inverse, e = e.shape, h = (c ? o : 0) * (a ? -
				1 : 1), o = (c ? 0 : -o) * (a ? -1 : 1), d = void 0, 1 <= (f = (p = (c = function(t, e, n) {
					for (var i, r, o = t.length / 2, a = "x" === n ? 0 : 1, s = 0, l = -1, u =
							0; u < o; u++)
						if (r = t[2 * u + a], !isNaN(r) && !isNaN(t[2 * u + 1 - a])) {
							if (0 !== u) {
								if (i <= e && e <= r || e <= i && r <= e) {
									l = u;
									break
								}
								s = u
							}
							i = r
						} return {
						range: [s, l],
						t: (e - i) / (r - i)
					}
				}(s, a = a ? c ? e.x : e.y + e.height : c ? e.x + e.width : e.y, e = c ? "x" : "y"))
				.range)[1] - p[0]) ? (1 < f && !g ? (y = $w(s, p[0]), m.attr({
					x: y[0] + h,
					y: y[1] + o
				}), r && (d = l.getRawValue(p[0]))) : ((y = v.getPointOn(a, e)) && m.attr({
					x: y[0] + h,
					y: y[1] + o
				}), f = l.getRawValue(p[0]), g = l.getRawValue(p[1]), r && (d = Jo(n, u, f, g, c.t))), i
				.lastFrameIndex = p[0]) : (y = $w(s, v = 1 === t || 0 < i.lastFrameIndex ? p[0] : 0), r && (
				d = l.getRawValue(v)), m.attr({
				x: y[0] + h,
				y: y[1] + o
			})), r) && "function" == typeof(a = Bc(m)).setLabelText && a.setLabelText(d)
	}, nb.prototype._doUpdateAnimation = function(t, e, n, i, r, o, a) {
		var s = this._polyline,
			l = this._polygon,
			u = t.hostModel,
			e = function(t, e, n, i, r, o) {
				a = [], e.diff(t).add(function(t) {
					a.push({
						cmd: "+",
						idx: t
					})
				}).update(function(t, e) {
					a.push({
						cmd: "=",
						idx: e,
						idx1: t
					})
				}).remove(function(t) {
					a.push({
						cmd: "-",
						idx: t
					})
				}).execute();
				for (var a, s = a, l = [], u = [], h = [], c = [], p = [], d = [], f = [], g = Iw(r, e, o), y =
						t.getLayout("points") || [], m = e.getLayout("points") || [], v = 0; v < s
					.length; v++) {
					var _ = s[v],
						x = !0,
						w = void 0;
					switch (_.cmd) {
						case "=":
							var b = 2 * _.idx,
								w = 2 * _.idx1,
								S = y[b],
								M = y[1 + b],
								T = m[w],
								C = m[w + 1];
							(isNaN(S) || isNaN(M)) && (S = T, M = C), l.push(S, M), u.push(T, C), h.push(n[b],
								n[1 + b]), c.push(i[w], i[w + 1]), f.push(e.getRawIndex(_.idx1));
							break;
						case "+":
							S = _.idx, M = g.dataDimsForPoint, T = r.dataToPoint([e.get(M[0], S), e.get(M[1],
								S)]), C = (w = 2 * S, l.push(T[0], T[1]), u.push(m[w], m[w + 1]), kw(g, r,
								e, S));
							h.push(C[0], C[1]), c.push(i[w], i[w + 1]), f.push(e.getRawIndex(S));
							break;
						case "-":
							x = !1
					}
					x && (p.push(_), d.push(d.length))
				}
				d.sort(function(t, e) {
					return f[t] - f[e]
				});
				for (var I = f_(o = l.length), k = f_(o), D = f_(o), A = f_(o), P = [], v = 0; v < d
					.length; v++) {
					var L = d[v],
						O = 2 * v,
						R = 2 * L;
					I[O] = l[R], I[1 + O] = l[1 + R], k[O] = u[R], k[1 + O] = u[1 + R], D[O] = h[R], D[1 + O] =
						h[1 + R], A[O] = c[R], A[1 + O] = c[1 + R], P[v] = p[L]
				}
				return {
					current: I,
					next: k,
					stackedOnCurrent: D,
					stackedOnNext: A,
					status: P
				}
			}(this._data, t, this._stackedOnPoints, e, this._coordSys, this._valueOrigin),
			h = e.current,
			c = e.stackedOnCurrent,
			p = e.next,
			d = e.stackedOnNext;
		if (r && (h = qw(e.current, n, r, a), c = qw(e.stackedOnCurrent, n, r, a), p = qw(e.next, n, r, a), d =
				qw(e.stackedOnNext, n, r, a)), 3e3 < Xw(h, p) || l && 3e3 < Xw(c, d)) s.stopAnimation(), s
			.setShape({
				points: p
			}), l && (l.stopAnimation(), l.setShape({
				points: p,
				stackedOnPoints: d
			}));
		else {
			s.shape.__points = e.current, s.shape.points = h;
			n = {
				shape: {
					points: p
				}
			};
			e.current !== h && (n.shape.__points = e.next), s.stopAnimation(), qh(s, n, u), l && (l.setShape({
				points: h,
				stackedOnPoints: c
			}), l.stopAnimation(), qh(l, {
				shape: {
					stackedOnPoints: d
				}
			}, u), s.shape.points !== l.shape.points) && (l.shape.points = s.shape.points);
			for (var f, g = [], y = e.status, m = 0; m < y.length; m++) "=" === y[m].cmd && (f = t
				.getItemGraphicEl(y[m].idx1)) && g.push({
				el: f,
				ptIdx: m
			});
			s.animators && s.animators.length && s.animators[0].during(function() {
				l && l.dirtyShape();
				for (var t = s.shape.__points, e = 0; e < g.length; e++) {
					var n = g[e].el,
						i = 2 * g[e].ptIdx;
					n.x = t[i], n.y = t[1 + i], n.markRedraw()
				}
			})
		}
	}, nb.prototype.remove = function(t) {
		var n = this.group,
			i = this._data;
		this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(t, e) {
				t.__temp && (n.remove(t), i.setItemGraphicEl(e, null))
			}), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this
			._endLabel = this._data = null
	}, nb.type = "line";
	var tb, eb = nb;

	function nb() {
		return null !== tb && tb.apply(this, arguments) || this
	}
	n1(function(t) {
		var i;
		t.registerChartView(eb), t.registerSeriesModel(yw), t.registerLayout((i = !0, {
			seriesType: "line",
			plan: cy(),
			reset: function(t) {
				var h, e, c, p, d, n = t.getData(),
					f = t.coordinateSystem,
					t = t.pipelineContext,
					g = i || t.large;
				if (f) return t = F(f.dimensions, function(t) {
						return n.mapDimension(t)
					}).slice(0, 2), h = t.length, e = n.getCalculationInfo(
						"stackResultDimension"), Gv(n, t[0]) && (t[0] = e), Gv(n, t[
						1]) && (t[1] = e), c = n.getStore(), p = n.getDimensionIndex(t[
						0]),
					d = n.getDimensionIndex(t[1]), h && {
						progress: function(t, e) {
							for (var n = t.end - t.start, i = g && f_(n * h),
									r = [], o = [], a = t.start, s = 0; a < t
								.end; a++) {
								var l, u = void 0;
								u = 1 === h ? (l = c.get(p, a), f.dataToPoint(l,
										null, o)) : (r[0] = c.get(p, a), r[1] = c
										.get(d, a), f.dataToPoint(r, null, o)), g ?
									(i[s++] = u[0], i[s++] = u[1]) : e
									.setItemLayout(a, u.slice())
							}
							g && e.setLayout("points", i)
						}
					}
			}
		})), t.registerVisual({
			seriesType: "line",
			reset: function(t) {
				var e = t.getData(),
					t = t.getModel("lineStyle").getLineStyle();
				t && !t.stroke && (t.stroke = e.getVisual("style").fill), e.setVisual(
					"legendLineStyle", t)
			}
		}), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, Dx("line"))
	});
	var ib = 2 * Math.PI,
		rb = Math.PI / 180;

	function ob(t, e) {
		return Qp(t.getBoxLayoutParams(), {
			width: e.getWidth(),
			height: e.getHeight()
		})
	}

	function ab(t, e) {
		var n = ob(t, e),
			i = t.get("center"),
			r = t.get("radius");
		V(r) || (r = [0, r]);
		var o, a = fo(n.width, e.getWidth()),
			e = fo(n.height, e.getHeight()),
			s = Math.min(a, e),
			l = fo(r[0], s / 2),
			r = fo(r[1], s / 2),
			s = t.coordinateSystem;
		return s = s ? (o = (t = s.dataToPoint(i))[0] || 0, t[1] || 0) : (o = fo((i = V(i) ? i : [i, i])[0], a) + n
			.x, fo(i[1], e) + n.y), {
			cx: o,
			cy: s,
			r0: l,
			r: r
		}
	}

	function sb(t, e, S) {
		e.eachSeriesByType(t, function(t) {
			var n, r = t.getData(),
				e = r.mapDimension("value"),
				i = ob(t, S),
				o = ab(t, S),
				a = o.cx,
				s = o.cy,
				l = o.r,
				u = o.r0,
				h = -t.get("startAngle") * rb,
				c = t.get("minAngle") * rb,
				p = 0,
				d = (r.each(e, function(t) {
					isNaN(t) || p++
				}), r.getSum(e)),
				f = Math.PI / (d || p) * 2,
				g = t.get("clockwise"),
				y = t.get("roseType"),
				m = t.get("stillShowZeroSum"),
				v = r.getDataExtent(e),
				_ = (v[0] = 0, ib),
				x = 0,
				w = h,
				b = g ? 1 : -1;
			r.setLayout({
				viewRect: i,
				r: l
			}), r.each(e, function(t, e) {
				var n, i;
				isNaN(t) ? r.setItemLayout(e, {
					angle: NaN,
					startAngle: NaN,
					endAngle: NaN,
					clockwise: g,
					cx: a,
					cy: s,
					r0: u,
					r: y ? NaN : l
				}) : ((n = "area" !== y ? 0 === d && m ? f : t * f : ib / p) < c ? _ -= n = c :
					x += t, i = w + b * n, r.setItemLayout(e, {
						angle: n,
						startAngle: w,
						endAngle: i,
						clockwise: g,
						cx: a,
						cy: s,
						r0: u,
						r: y ? po(t, v, [u, l]) : l
					}), w = i)
			}), _ < ib && p && (_ <= .001 ? (n = ib / p, r.each(e, function(t, e) {
				isNaN(t) || ((t = r.getItemLayout(e)).angle = n, t.startAngle = h + b * e *
					n, t.endAngle = h + b * (e + 1) * n)
			})) : (f = _ / x, w = h, r.each(e, function(t, e) {
				isNaN(t) || (t = (e = r.getItemLayout(e)).angle === c ? c : t * f, e
					.startAngle = w, e.endAngle = w + b * t, w += b * t)
			})))
		})
	}
	var lb = Math.PI / 180;

	function ub(t, s, l, u, h, e, n, i, r, o) {
		if (!(t.length < 2)) {
			for (var a, c = t.length, p = 0; p < c; p++) "outer" === t[p].position && "labelLine" === t[p]
				.labelAlignTo && (a = t[p].label.x - o, t[p].linePoints[1][0] += a, t[p].label.x = o);
			if (tx(t, r, r + n)) {
				for (var d, f, g, y, m, v = t, _ = {
						list: [],
						maxY: 0
					}, x = {
						list: [],
						maxY: 0
					}, w = 0; w < v.length; w++) "none" === v[w].labelAlignTo && (f = (d = v[w]).label.y > l ? x :
					_, (g = Math.abs(d.label.y - l)) >= f.maxY && (m = d.label.x - s - d.len2 * h, y = u + d
						.len, m = Math.abs(m) < y ? Math.sqrt(g * g / (1 - m * m / y / y)) : y, f.rB = m, f
						.maxY = g), f.list.push(d));
				b(_), b(x)
			}
		}

		function b(t) {
			for (var e = t.rB, n = e * e, i = 0; i < t.list.length; i++) {
				var r = t.list[i],
					o = Math.abs(r.label.y - l),
					a = u + r.len,
					a = a * a,
					o = Math.sqrt((1 - Math.abs(o * o / n)) * a),
					a = s + (o + r.len2) * h,
					o = a - r.label.x;
				hb(r, r.targetTextWidth - o * h, !0), r.label.x = a
			}
		}
	}

	function hb(t, e, n) {
		var i, r, o, a, s, l, u;
		void 0 === n && (n = !1), null == t.labelStyleWidth && (s = (i = t.label).style, r = t.rect, l = s
			.backgroundColor, u = (u = s.padding) ? u[1] + u[3] : 0, s = s.overflow, e < (o = r.width + (l ? 0 :
				u)) || n) && (a = r.height, s && s.match("break") ? (i.setStyle("backgroundColor", null), i
				.setStyle("width", e - u), s = i.getBoundingRect(), i.setStyle("width", Math.ceil(s.width)), i
				.setStyle("backgroundColor", l)) : (s = e - u, l = !(e < o) && (!n || s > t
				.unconstrainedWidth) ? null : s, i.setStyle("width", l)), u = i.getBoundingRect(), r.width = u
			.width, e = (i.style.margin || 0) + 2.1, r.height = u.height + e, r.y -= (r.height - a) / 2)
	}

	function cb(t) {
		return "center" === t.position
	}

	function pb(t) {
		var S, M, T = t.getData(),
			C = [],
			I = !1,
			k = (t.get("minShowLabelAngle") || 0) * lb,
			e = T.getLayout("viewRect"),
			D = T.getLayout("r"),
			A = e.width,
			P = e.x,
			n = e.y,
			e = e.height;

		function L(t) {
			t.ignore = !0
		}
		if (T.each(function(t) {
				var e, n, i, r, o, a, s, l, u, h, c, p = T.getItemGraphicEl(t),
					d = p.shape,
					f = p.getTextContent(),
					g = p.getTextGuideLine(),
					t = T.getItemModel(t),
					y = t.getModel("label"),
					m = y.get("position") || t.get(["emphasis", "label", "position"]),
					v = y.get("distanceToLabelLine"),
					_ = y.get("alignTo"),
					x = fo(y.get("edgeDistance"), A),
					w = y.get("bleedMargin"),
					t = t.getModel("labelLine"),
					b = fo(t.get("length"), A);
				e = fo(t.get("length2"), A), Math.abs(d.endAngle - d.startAngle) < k ? (E(f.states, L), f
					.ignore = !0, g && (E(g.states, L), g.ignore = !0)) : function(t) {
					if (!t.ignore) return 1;
					for (var e in t.states)
						if (!1 === t.states[e].ignore) return 1
				}(f) && (c = (d.startAngle + d.endAngle) / 2, n = Math.cos(c), i = Math.sin(c), S = d.cx,
					M = d.cy, r = "inside" === m || "inner" === m, l = "center" === m ? (o = d.cx, a = d.cy,
						"center") : (o = (l = (r ? (d.r + d.r0) / 2 * n : d.r * n) + S) + 3 * n, a = (u = (
							r ? (d.r + d.r0) / 2 * i : d.r * i) + M) + 3 * i, r || (s = l + n * (b + D - d
								.r), d = u + i * (b + D - d.r), h = s + (n < 0 ? -1 : 1) * e, o = "edge" ===
							_ ? n < 0 ? P + x : P + A - x : h + (n < 0 ? -v : v), s = [
								[l, u],
								[s, a = d],
								[h, d]
							]), r ? "center" : "edge" === _ ? 0 < n ? "right" : "left" : 0 < n ? "left" :
						"right"), u = Math.PI, h = 0, G(d = y.get("rotate")) ? h = d * (u / 180) :
					"center" === m ? h = 0 : "radial" === d || !0 === d ? h = n < 0 ? -c + u : -c :
					"tangential" === d && "outside" !== m && "outer" !== m && ((y = Math.atan2(n, i)) < 0 &&
						(y = 2 * u + y), h = (y = 0 < i ? u + y : y) - u), I = !!h, f.x = o, f.y = a, f
					.rotation = h, f.setStyle({
						verticalAlign: "middle"
					}), r ? (f.setStyle({
						align: l
					}), (c = f.states.select) && (c.x += f.x, c.y += f.y)) : ((d = f.getBoundingRect()
							.clone()).applyTransform(f.getComputedTransform()), y = (f.style.margin || 0) +
						2.1, d.y -= y / 2, d.height += y, C.push({
							label: f,
							labelLine: g,
							position: m,
							len: b,
							len2: e,
							minTurnAngle: t.get("minTurnAngle"),
							maxSurfaceAngle: t.get("maxSurfaceAngle"),
							surfaceNormal: new W(n, i),
							linePoints: s,
							textAlign: l,
							labelDistance: v,
							labelAlignTo: _,
							edgeDistance: x,
							bleedMargin: w,
							rect: d,
							unconstrainedWidth: d.width,
							labelStyleWidth: f.style.width
						})), p.setTextConfig({
						inside: r
					}))
			}), !I && t.get("avoidLabelOverlap")) {
			for (var i = C, r = S, o = (t = M, D), a = A, s = P, l, u, h, c, p, d, f = [], g = [], y = Number
					.MAX_VALUE, m = -Number.MAX_VALUE, v = 0; v < i.length; v++) {
				var _ = i[v].label;
				cb(i[v]) || (_.x < r ? (y = Math.min(y, _.x), f) : (m = Math.max(m, _.x), g)).push(i[v])
			}
			for (v = 0; v < i.length; v++) !cb(u = i[v]) && u.linePoints && null == u.labelStyleWidth && (_ = u
				.label, h = u.linePoints, l = void 0, l = "edge" === u.labelAlignTo ? _.x < r ? h[2][0] - u
				.labelDistance - s - u.edgeDistance : s + a - u.edgeDistance - h[2][0] - u.labelDistance :
				"labelLine" === u.labelAlignTo ? _.x < r ? y - s - u.bleedMargin : s + a - m - u.bleedMargin : _
				.x < r ? _.x - s - u.bleedMargin : s + a - _.x - u.bleedMargin, u.targetTextWidth = l, hb(u, l));
			for (ub(g, r, t, o, 1, 0, e, 0, n, m), ub(f, r, t, o, -1, 0, e, 0, n, y), v = 0; v < i.length; v++) !cb(
				u = i[v]) && u.linePoints && (_ = u.label, h = u.linePoints, c = "edge" === u.labelAlignTo, p =
				(p = _.style.padding) ? p[1] + p[3] : 0, p = _.style.backgroundColor ? 0 : p, p = u.rect.width +
				p, d = h[1][0] - h[2][0], c ? _.x < r ? h[2][0] = s + u.edgeDistance + p + u.labelDistance : h[
					2][0] = s + a - u.edgeDistance - p - u.labelDistance : (_.x < r ? h[2][0] = _.x + u
					.labelDistance : h[2][0] = _.x - u.labelDistance, h[1][0] = h[2][0] + d), h[1][1] = h[2][
					1
				] = _.y)
		}
		for (var x = 0; x < C.length; x++) {
			var w, b = C[x],
				O = b.label,
				R = b.labelLine,
				N = isNaN(O.x) || isNaN(O.y);
			O && (O.setStyle({
				align: b.textAlign
			}), N && (E(O.states, L), O.ignore = !0), w = O.states.select) && (w.x += O.x, w.y += O.y), R && (
				w = b.linePoints, N || !w ? (E(R.states, L), R.ignore = !0) : (q1(w, b.minTurnAngle), function(
					t, e, n) {
					if (n <= 180 && 0 < n) {
						n = n / 180 * Math.PI, F1.fromArray(t[0]), V1.fromArray(t[1]), H1.fromArray(t[2]), W
							.sub(G1, V1, F1), W.sub(W1, H1, V1);
						var i = G1.len(),
							r = W1.len();
						if (!(i < .001 || r < .001) && (G1.scale(1 / i), W1.scale(1 / r), G1.dot(e) < Math
								.cos(n))) {
							i = N1(V1.x, V1.y, H1.x, H1.y, F1.x, F1.y, X1, !1), r = (Y1.fromArray(X1), Math
								.PI / 2), e = r + Math.acos(W1.dot(e)) - n;
							if (r <= e) W.copy(Y1, H1);
							else {
								Y1.scaleAndAdd(W1, i / Math.tan(Math.PI / 2 - e));
								n = H1.x !== V1.x ? (Y1.x - V1.x) / (H1.x - V1.x) : (Y1.y - V1.y) / (H1.y -
									V1.y);
								if (isNaN(n)) return;
								n < 0 ? W.copy(Y1, V1) : 1 < n && W.copy(Y1, H1)
							}
							Y1.toArray(t[1])
						}
					}
				}(w, b.surfaceNormal, b.maxSurfaceAngle), R.setShape({
					points: w
				}), O.__hostTarget.textGuideLineConfig = {
					anchor: new W(w[0][0], w[0][1])
				}))
		}
	}
	u(vb, fb = Ku), vb.prototype.updateData = function(t, e, n, i) {
		var r = this,
			o = t.hostModel,
			a = t.getItemModel(e),
			s = a.getModel("emphasis"),
			l = t.getItemLayout(e),
			u = O(Yx(a.getModel("itemStyle"), l, !0), l);
		isNaN(u.startAngle) ? r.setShape(u) : (i ? (r.setShape(u), i = o.getShallow("animationType"), o.ecModel
				.ssr ? (jh(r, {
					scaleX: 0,
					scaleY: 0
				}, o, {
					dataIndex: e,
					isFrom: !0
				}), r.originX = u.cx, r.originY = u.cy) : "scale" === i ? (r.shape.r = l.r0, jh(r, {
					shape: {
						r: l.r
					}
				}, o, e)) : null != n ? (r.setShape({
					startAngle: n,
					endAngle: n
				}), jh(r, {
					shape: {
						startAngle: l.startAngle,
						endAngle: l.endAngle
					}
				}, o, e)) : (r.shape.endAngle = l.startAngle, qh(r, {
					shape: {
						endAngle: l.endAngle
					}
				}, o, e))) : (Jh(r), qh(r, {
				shape: u
			}, o, e)), r.useStyle(t.getItemVisual(e, "style")), iu(r, a), i = (l.startAngle + l.endAngle) /
			2, n = o.get("selectedOffset"), u = Math.cos(i) * n, i = Math.sin(i) * n, (n = a.getShallow(
				"cursor")) && r.attr("cursor", n), this._updateLabel(o, t, e), r.ensureState("emphasis")
			.shape = O({
				r: l.r + (s.get("scale") && s.get("scaleSize") || 0)
			}, Yx(s.getModel("itemStyle"), l)), O(r.ensureState("select"), {
				x: u,
				y: i,
				shape: Yx(a.getModel(["select", "itemStyle"]), l)
			}), O(r.ensureState("blur"), {
				shape: Yx(a.getModel(["blur", "itemStyle"]), l)
			}), n = r.getTextGuideLine(), o = r.getTextContent(), n && O(n.ensureState("select"), {
				x: u,
				y: i
			}), O(o.ensureState("select"), {
				x: u,
				y: i
			}), tu(this, s.get("focus"), s.get("blurScope"), s.get("disabled")))
	}, vb.prototype._updateLabel = function(t, e, n) {
		var i = e.getItemModel(n),
			r = i.getModel("labelLine"),
			o = e.getItemVisual(n, "style"),
			a = o && o.fill,
			o = o && o.opacity,
			e = (Ac(this, Pc(i), {
				labelFetcher: e.hostModel,
				labelDataIndex: n,
				inheritColor: a,
				defaultOpacity: o,
				defaultText: t.getFormattedLabel(n, "normal") || e.getName(n)
			}), this.getTextContent()),
			n = (this.setTextConfig({
				position: null,
				rotation: null
			}), e.attr({
				z2: 10
			}), t.get(["label", "position"]));
		"outside" !== n && "outer" !== n ? this.removeTextGuideLine() : (this.getTextGuideLine() || (e = new uh,
			this.setTextGuideLine(e)), K1(this, $1(i), {
			stroke: a,
			opacity: St(r.get(["lineStyle", "opacity"]), o, 1)
		}))
	};
	var db, fb, gb = vb,
		yb = (u(mb, db = fy), mb.prototype.render = function(e, t, n, i) {
			var r, o = e.getData(),
				a = this._data,
				s = this.group;
			if (!a && 0 < o.count()) {
				for (var l = o.getItemLayout(0), u = 1; isNaN(l && l.startAngle) && u < o.count(); ++u) l = o
					.getItemLayout(u);
				l && (r = l.startAngle)
			}
			this._emptyCircleSector && s.remove(this._emptyCircleSector), 0 === o.count() && e.get(
				"showEmptyCircle") && ((n = new Ku({
					shape: ab(e, n)
				})).useStyle(e.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = n, s
				.add(n)), o.diff(a).add(function(t) {
				var e = new gb(o, t, r);
				o.setItemGraphicEl(t, e), s.add(e)
			}).update(function(t, e) {
				e = a.getItemGraphicEl(e);
				e.updateData(o, t, r), e.off("click"), s.add(e), o.setItemGraphicEl(t, e)
			}).remove(function(t) {
				Qh(a.getItemGraphicEl(t), e, t)
			}).execute(), pb(e), "expansion" !== e.get("animationTypeUpdate") && (this._data = o)
		}, mb.prototype.dispose = function() {}, mb.prototype.containPoint = function(t, e) {
			var n, e = e.getData().getItemLayout(0);
			if (e) return n = t[0] - e.cx, t = t[1] - e.cy, (n = Math.sqrt(n * n + t * t)) <= e.r && n >= e.r0
		}, mb.type = "pie", mb);

	function mb() {
		var t = null !== db && db.apply(this, arguments) || this;
		return t.ignoreLabelLineUpdate = !0, t
	}

	function vb(t, e, n) {
		var i = fb.call(this) || this,
			r = (i.z2 = 2, new Ks);
		return i.setTextContent(r), i.updateData(t, e, n, !0), i
	}
	xb.prototype.getAllNames = function() {
		var t = this._getRawData();
		return t.mapArray(t.getName)
	}, xb.prototype.containName = function(t) {
		return 0 <= this._getRawData().indexOfName(t)
	}, xb.prototype.indexOfName = function(t) {
		return this._getDataWithEncodedVisual().indexOfName(t)
	}, xb.prototype.getItemVisual = function(t, e) {
		return this._getDataWithEncodedVisual().getItemVisual(t, e)
	};
	var _b = xb;

	function xb(t, e) {
		this._getDataWithEncodedVisual = t, this._getRawData = e
	}
	var wb, bb = Yo(),
		Sb = (u(Mb, wb = ey), Mb.prototype.init = function(t) {
			wb.prototype.init.apply(this, arguments), this.legendVisualProvider = new _b(pt(this.getData, this),
				pt(this.getRawData, this)), this._defaultLabelLine(t)
		}, Mb.prototype.mergeOption = function() {
			wb.prototype.mergeOption.apply(this, arguments)
		}, Mb.prototype.getInitialData = function() {
			return e = V(e = {
				coordDimensions: ["value"],
				encodeDefaulter: dt(bd, t = this)
			}) ? {
				coordDimensions: e
			} : O({
				encodeDefine: t.getEncode()
			}, e), i = t.getSource(), e = zv(i, e).dimensions, (e = new Ev(e, t)).initData(i, n), e;
			var t, e, n, i
		}, Mb.prototype.getDataParams = function(t) {
			var e, n = this.getData(),
				i = bb(n),
				r = i.seats,
				i = (r || (e = [], n.each(n.mapDimension("value"), function(t) {
						e.push(t)
					}), r = i.seats = _o(e, n.hostModel.get("percentPrecision"))), wb.prototype.getDataParams
					.call(this, t));
			return i.percent = r[t] || 0, i.$vars.push("percent"), i
		}, Mb.prototype._defaultLabelLine = function(t) {
			No(t, "labelLine", ["show"]);
			var e = t.labelLine,
				n = t.emphasis.labelLine;
			e.show = e.show && t.label.show, n.show = n.show && t.emphasis.label.show
		}, Mb.type = "series.pie", Mb.defaultOption = {
			z: 2,
			legendHoverLink: !0,
			colorBy: "data",
			center: ["50%", "50%"],
			radius: [0, "75%"],
			clockwise: !0,
			startAngle: 90,
			minAngle: 0,
			minShowLabelAngle: 0,
			selectedOffset: 10,
			percentPrecision: 2,
			stillShowZeroSum: !0,
			left: 0,
			top: 0,
			right: 0,
			bottom: 0,
			width: null,
			height: null,
			label: {
				rotate: 0,
				show: !0,
				overflow: "truncate",
				position: "outer",
				alignTo: "none",
				edgeDistance: "25%",
				bleedMargin: 10,
				distanceToLabelLine: 5
			},
			labelLine: {
				show: !0,
				length: 15,
				length2: 15,
				smooth: !1,
				minTurnAngle: 90,
				maxSurfaceAngle: 90,
				lineStyle: {
					width: 1,
					type: "solid"
				}
			},
			itemStyle: {
				borderWidth: 1,
				borderJoin: "round"
			},
			showEmptyCircle: !0,
			emptyCircleStyle: {
				color: "lightgray",
				opacity: 1
			},
			labelLayout: {
				hideOverlap: !0
			},
			emphasis: {
				scale: !0,
				scaleSize: 5
			},
			avoidLabelOverlap: !0,
			animationType: "expansion",
			animationDuration: 1e3,
			animationTypeUpdate: "transition",
			animationEasingUpdate: "cubicInOut",
			animationDurationUpdate: 500,
			animationEasing: "cubicInOut"
		}, Mb);

	function Mb() {
		return null !== wb && wb.apply(this, arguments) || this
	}
	n1(function(t) {
		t.registerChartView(yb), t.registerSeriesModel(Sb), em("pie", t.registerAction), t.registerLayout(
			dt(sb, "pie")), t.registerProcessor({
			seriesType: "pie",
			reset: function(t, e) {
				var i, r = e.findComponents({
					mainType: "legend"
				});
				r && r.length && (i = t.getData()).filterSelf(function(t) {
					for (var e = i.getName(t), n = 0; n < r.length; n++)
						if (!r[n].isSelected(e)) return !1;
					return !0
				})
			}
		}), t.registerProcessor({
			seriesType: "pie",
			reset: function(t, e) {
				var n = t.getData();
				n.filterSelf(function(t) {
					var e = n.mapDimension("value"),
						e = n.get(e, t);
					return !(G(e) && !isNaN(e) && e < 0)
				})
			}
		})
	});
	u(Ib, Tb = g), Ib.type = "grid", Ib.dependencies = ["xAxis", "yAxis"], Ib.layoutMode = "box", Ib
		.defaultOption = {
			show: !1,
			z: 0,
			left: "10%",
			top: 60,
			right: "10%",
			bottom: 70,
			containLabel: !1,
			backgroundColor: "rgba(0,0,0,0)",
			borderWidth: 1,
			borderColor: "#ccc"
		};
	var Tb, Cb = Ib;

	function Ib() {
		return null !== Tb && Tb.apply(this, arguments) || this
	}
	u(Ab, kb = g), Ab.prototype.getCoordSysModel = function() {
		return this.getReferringComponents("grid", Ko).models[0]
	}, Ab.type = "cartesian2dAxis";
	var kb, Db = Ab;

	function Ab() {
		return null !== kb && kb.apply(this, arguments) || this
	}
	lt(Db, Q_);
	var aa = {
			show: !0,
			z: 0,
			inverse: !1,
			name: "",
			nameLocation: "end",
			nameRotate: null,
			nameTruncate: {
				maxWidth: null,
				ellipsis: "...",
				placeholder: "."
			},
			nameTextStyle: {},
			nameGap: 15,
			silent: !1,
			triggerEvent: !1,
			tooltip: {
				show: !1
			},
			axisPointer: {},
			axisLine: {
				show: !0,
				onZero: !0,
				onZeroAxisIndex: null,
				lineStyle: {
					color: "#6E7079",
					width: 1,
					type: "solid"
				},
				symbol: ["none", "none"],
				symbolSize: [10, 15]
			},
			axisTick: {
				show: !0,
				inside: !1,
				length: 5,
				lineStyle: {
					width: 1
				}
			},
			axisLabel: {
				show: !0,
				inside: !1,
				rotate: 0,
				showMinLabel: null,
				showMaxLabel: null,
				margin: 8,
				fontSize: 12
			},
			splitLine: {
				show: !0,
				lineStyle: {
					color: ["#E0E6F1"],
					width: 1,
					type: "solid"
				}
			},
			splitArea: {
				show: !1,
				areaStyle: {
					color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
				}
			}
		},
		am = d({
			boundaryGap: !0,
			deduplication: null,
			splitLine: {
				show: !1
			},
			axisTick: {
				alignWithLabel: !1,
				interval: "auto"
			},
			axisLabel: {
				interval: "auto"
			}
		}, aa),
		cm = d({
			boundaryGap: [0, 0],
			axisLine: {
				show: "auto"
			},
			axisTick: {
				show: "auto"
			},
			splitNumber: 5,
			minorTick: {
				show: !1,
				splitNumber: 5,
				length: 3,
				lineStyle: {}
			},
			minorSplitLine: {
				show: !1,
				lineStyle: {
					color: "#F4F7FD",
					width: 1
				}
			}
		}, aa),
		Pb = {
			category: am,
			value: cm,
			time: d({
				splitNumber: 6,
				axisLabel: {
					showMinLabel: !1,
					showMaxLabel: !1,
					rich: {
						primary: {
							fontWeight: "bold"
						}
					}
				},
				splitLine: {
					show: !1
				}
			}, cm),
			log: B({
				logBase: 10
			}, cm)
		},
		Lb = {
			value: 1,
			category: 1,
			time: 1,
			log: 1
		};

	function Ob(o, a, s, l) {
		E(Lb, function(t, r) {
			var e, n = d(d({}, Pb[r], !0), l, !0),
				n = (u(i, e = s), i.prototype.mergeDefaultAndTheme = function(t, e) {
					var n = Jp(this),
						i = n ? ed(t) : {};
					d(t, e.getTheme().get(r + "Axis")), d(t, this.getDefaultOption()), t.type = Rb(t),
						n && td(t, i, n)
				}, i.prototype.optionUpdated = function() {
					"category" === this.option.type && (this.__ordinalMeta = jv.createByAxisModel(this))
				}, i.prototype.getCategories = function(t) {
					var e = this.option;
					if ("category" === e.type) return t ? e.data : this.__ordinalMeta.categories
				}, i.prototype.getOrdinalMeta = function() {
					return this.__ordinalMeta
				}, i.type = a + "Axis." + r, i.defaultOption = n, i);

			function i() {
				var t = null !== e && e.apply(this, arguments) || this;
				return t.type = a + "Axis." + r, t
			}
			o.registerComponentModel(n)
		}), o.registerSubTypeDefaulter(a + "Axis", Rb)
	}

	function Rb(t) {
		return t.type || (t.data ? "category" : "value")
	}

	function Nb(t) {
		this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || ""
	}
	Nb.prototype.getAxis = function(t) {
		return this._axes[t]
	}, Nb.prototype.getAxes = function() {
		return F(this._dimList, function(t) {
			return this._axes[t]
		}, this)
	}, Nb.prototype.getAxesByScale = function(e) {
		return e = e.toLowerCase(), ct(this.getAxes(), function(t) {
			return t.scale.type === e
		})
	}, Nb.prototype.addAxis = function(t) {
		var e = t.dim;
		this._axes[e] = t, this._dimList.push(e)
	};
	var Eb = ["x", "y"];

	function zb(t) {
		return "interval" === t.type || "time" === t.type
	}
	u(Vb, Bb = Nb), Vb.prototype.calcAffineTransform = function() {
		this._transform = this._invTransform = null;
		var t, e, n, i, r = this.getAxis("x").scale,
			o = this.getAxis("y").scale;
		zb(r) && zb(o) && (r = r.getExtent(), o = o.getExtent(), i = this.dataToPoint([r[0], o[0]]), e = this
			.dataToPoint([r[1], o[1]]), t = r[1] - r[0], n = o[1] - o[0], t) && n && (t = (e[0] - i[0]) / t,
			e = (e[1] - i[1]) / n, n = i[0] - r[0] * t, r = i[1] - o[0] * e, i = this._transform = [t, 0, 0,
				e, n, r
			], this._invTransform = Ve([], i))
	}, Vb.prototype.getBaseAxis = function() {
		return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
	}, Vb.prototype.containPoint = function(t) {
		var e = this.getAxis("x"),
			n = this.getAxis("y");
		return e.contain(e.toLocalCoord(t[0])) && n.contain(n.toLocalCoord(t[1]))
	}, Vb.prototype.containData = function(t) {
		return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
	}, Vb.prototype.containZone = function(t, e) {
		var t = this.dataToPoint(t),
			e = this.dataToPoint(e),
			n = this.getArea(),
			e = new U(t[0], t[1], e[0] - t[0], e[1] - t[1]);
		return n.intersect(e)
	}, Vb.prototype.dataToPoint = function(t, e, n) {
		n = n || [];
		var i, r = t[0],
			o = t[1];
		return this._transform && null != r && isFinite(r) && null != o && isFinite(o) ? ne(n, t, this
			._transform) : (t = this.getAxis("x"), i = this.getAxis("y"), n[0] = t.toGlobalCoord(t
			.dataToCoord(r, e)), n[1] = i.toGlobalCoord(i.dataToCoord(o, e)), n)
	}, Vb.prototype.clampData = function(t, e) {
		var n = this.getAxis("x").scale,
			i = this.getAxis("y").scale,
			r = n.getExtent(),
			o = i.getExtent(),
			n = n.parse(t[0]),
			i = i.parse(t[1]);
		return (e = e || [])[0] = Math.min(Math.max(Math.min(r[0], r[1]), n), Math.max(r[0], r[1])), e[1] = Math
			.min(Math.max(Math.min(o[0], o[1]), i), Math.max(o[0], o[1])), e
	}, Vb.prototype.pointToData = function(t, e) {
		var n, i, r = [];
		return this._invTransform ? ne(r, t, this._invTransform) : (n = this.getAxis("x"), i = this.getAxis(
			"y"), r[0] = n.coordToData(n.toLocalCoord(t[0]), e), r[1] = i.coordToData(i.toLocalCoord(t[
				1]),
			e), r)
	}, Vb.prototype.getOtherAxis = function(t) {
		return this.getAxis("x" === t.dim ? "y" : "x")
	}, Vb.prototype.getArea = function() {
		var t = this.getAxis("x").getGlobalExtent(),
			e = this.getAxis("y").getGlobalExtent(),
			n = Math.min(t[0], t[1]),
			i = Math.min(e[0], e[1]),
			t = Math.max(t[0], t[1]) - n,
			e = Math.max(e[0], e[1]) - i;
		return new U(n, i, t, e)
	};
	var Bb, Fb = Vb;

	function Vb() {
		var t = null !== Bb && Bb.apply(this, arguments) || this;
		return t.type = "cartesian2d", t.dimensions = Eb, t
	}
	u(Wb, Hb = Zc), Wb.prototype.isHorizontal = function() {
		var t = this.position;
		return "top" === t || "bottom" === t
	}, Wb.prototype.getGlobalExtent = function(t) {
		var e = this.getExtent();
		return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e
			.reverse(), e
	}, Wb.prototype.pointToData = function(t, e) {
		return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e)
	}, Wb.prototype.setCategorySortInfo = function(t) {
		if ("category" !== this.type) return !1;
		this.model.option.categorySortInfo = t, this.scale.setSortInfo(t)
	};
	var Hb, Gb = Wb;

	function Wb(t, e, n, i, r) {
		t = Hb.call(this, t, e, n) || this;
		return t.index = 0, t.type = i || "value", t.position = r || "bottom", t
	}

	function Ub(t, e, n) {
		n = n || {};
		var t = t.coordinateSystem,
			i = e.axis,
			r = {},
			o = i.getAxesOnZeroOf()[0],
			a = i.position,
			s = o ? "onZero" : a,
			i = i.dim,
			t = t.getRect(),
			t = [t.x, t.x + t.width, t.y, t.y + t.height],
			l = {
				left: 0,
				right: 1,
				top: 0,
				bottom: 1,
				onZero: 2
			},
			u = e.get("offset") || 0,
			u = "x" === i ? [t[2] - u, t[3] + u] : [t[0] - u, t[1] + u],
			h = (o && (h = o.toGlobalCoord(o.dataToCoord(0)), u[l.onZero] = Math.max(Math.min(h, u[1]), u[0])), r
				.position = ["y" === i ? u[l[s]] : t[0], "x" === i ? u[l[s]] : t[3]], r.rotation = Math.PI / 2 * (
					"x" === i ? 0 : 1), r.labelDirection = r.tickDirection = r.nameDirection = {
					top: -1,
					bottom: 1,
					left: -1,
					right: 1
				} [a], r.labelOffset = o ? u[l[a]] - u[l.onZero] : 0, e.get(["axisTick", "inside"]) && (r
					.tickDirection = -r.tickDirection), bt(n.labelInside, e.get(["axisLabel", "inside"])) && (r
					.labelDirection = -r.labelDirection), e.get(["axisLabel", "rotate"]));
		return r.labelRotate = "top" === s ? -h : h, r.z2 = 1, r
	}

	function Xb(t) {
		return "cartesian2d" === t.get("coordinateSystem")
	}

	function Yb(i) {
		var r = {
			xAxisModel: null,
			yAxisModel: null
		};
		return E(r, function(t, e) {
			var n = e.replace(/Model$/, ""),
				n = i.getReferringComponents(n, Ko).models[0];
			r[e] = n
		}), r
	}
	var qb = Math.log;
	Zb.prototype.getRect = function() {
		return this._rect
	}, Zb.prototype.update = function(t, e) {
		var n = this._axesMap;

		function i(t) {
			var d, e = R(t),
				n = e.length;
			if (n) {
				for (var i = [], r = n - 1; 0 <= r; r--) {
					var o = t[+e[r]],
						a = o.model,
						s = o.scale;
					$v(s) && a.get("alignTicks") && null == a.get("interval") ? i.push(o) : (X_(s, a), $v(s) &&
						(d = o))
				}
				i.length && (d || X_((d = i.pop()).scale, d.model), E(i, function(t) {
					var e = t.scale,
						t = t.model,
						n = d.scale,
						i = h_.prototype,
						r = i.getTicks.call(n),
						o = i.getTicks.call(n, !0),
						a = r.length - 1,
						n = i.getInterval.call(n),
						s = (t = U_(e, t)).extent,
						l = t.fixMin,
						t = t.fixMax,
						u = ("log" === e.type && (u = qb(e.base), s = [qb(s[0]) / u, qb(s[1]) / u]),
							e.setExtent(s[0], s[1]), e.calcNiceExtent({
								splitNumber: a,
								fixMin: l,
								fixMax: t
							}), i.getExtent.call(e)),
						h = (l && (s[0] = u[0]), t && (s[1] = u[1]), i.getInterval.call(e)),
						c = s[0],
						p = s[1];
					if (l && t) h = (p - c) / a;
					else if (l)
						for (p = s[0] + h * a; p < s[1] && isFinite(p) && isFinite(s[1]);) h = Jv(
							h), p = s[0] + h * a;
					else if (t)
						for (c = s[1] - h * a; c > s[0] && isFinite(c) && isFinite(s[0]);) h = Jv(
							h), c = s[1] - h * a;
					else {
						u = (h = e.getTicks().length - 1 > a ? Jv(h) : h) * a;
						(c = go((p = Math.ceil(s[1] / h) * h) - u)) < 0 && 0 <= s[0] ? (c = 0, p =
							go(u)) : 0 < p && s[1] <= 0 && (p = 0, c = -go(u))
					}
					l = (r[0].value - o[0].value) / n, t = (r[a].value - o[a].value) / n, i
						.setExtent.call(e, c + h * l, p + h * t), i.setInterval.call(e, h), (l ||
							t) && i.setNiceExtent.call(e, c + h, p - h)
				}))
			}
		}
		this._updateScale(t, this.model), i(n.x), i(n.y);
		var r = {};
		E(n.x, function(t) {
			$b(n, "y", t, r)
		}), E(n.y, function(t) {
			$b(n, "x", t, r)
		}), this.resize(this.model, e)
	}, Zb.prototype.resize = function(t, e, n) {
		var i = t.getBoxLayoutParams(),
			n = !n && t.get("containLabel"),
			a = Qp(i, {
				width: e.getWidth(),
				height: e.getHeight()
			}),
			r = (this._rect = a, this._axesList);

		function o() {
			E(r, function(t) {
				var e, n, i = t.isHorizontal(),
					r = i ? [0, a.width] : [0, a.height],
					o = t.inverse ? 1 : 0;
				t.setExtent(r[o], r[1 - o]), r = t, e = i ? a.x : a.y, o = r.getExtent(), n = o[0] + o[
					1], r.toGlobalCoord = "x" === r.dim ? function(t) {
					return t + e
				} : function(t) {
					return n - t + e
				}, r.toLocalCoord = "x" === r.dim ? function(t) {
					return t - e
				} : function(t) {
					return n - t + e
				}
			})
		}
		o(), n && (E(r, function(t) {
			var e, n, i;
			t.model.get(["axisLabel", "inside"]) || (e = Z_(t)) && (n = t.isHorizontal() ?
				"height" : "width", i = t.model.get(["axisLabel", "margin"]), a[n] -= e[n] + i,
				"top" === t.position ? a.y += e.height + i : "left" === t.position && (a.x += e
					.width + i))
		}), o()), E(this._coordsList, function(t) {
			t.calcAffineTransform()
		})
	}, Zb.prototype.getAxis = function(t, e) {
		t = this._axesMap[t];
		if (null != t) return t[e || 0]
	}, Zb.prototype.getAxes = function() {
		return this._axesList.slice()
	}, Zb.prototype.getCartesian = function(t, e) {
		if (null != t && null != e) return this._coordsMap["x" + t + "y" + e];
		L(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
		for (var n = 0, i = this._coordsList; n < i.length; n++)
			if (i[n].getAxis("x").index === t || i[n].getAxis("y").index === e) return i[n]
	}, Zb.prototype.getCartesians = function() {
		return this._coordsList.slice()
	}, Zb.prototype.convertToPixel = function(t, e, n) {
		e = this._findConvertTarget(e);
		return e.cartesian ? e.cartesian.dataToPoint(n) : e.axis ? e.axis.toGlobalCoord(e.axis.dataToCoord(n)) :
			null
	}, Zb.prototype.convertFromPixel = function(t, e, n) {
		e = this._findConvertTarget(e);
		return e.cartesian ? e.cartesian.pointToData(n) : e.axis ? e.axis.coordToData(e.axis.toLocalCoord(n)) :
			null
	}, Zb.prototype._findConvertTarget = function(t) {
		var e, n, i = t.seriesModel,
			r = t.xAxisModel || i && i.getReferringComponents("xAxis", Ko).models[0],
			o = t.yAxisModel || i && i.getReferringComponents("yAxis", Ko).models[0],
			t = t.gridModel,
			a = this._coordsList;
		return i ? I(a, e = i.coordinateSystem) < 0 && (e = null) : r && o ? e = this.getCartesian(r
				.componentIndex, o.componentIndex) : r ? n = this.getAxis("x", r.componentIndex) : o ? n = this
			.getAxis("y", o.componentIndex) : t && t.coordinateSystem === this && (e = this._coordsList[0]), {
				cartesian: e,
				axis: n
			}
	}, Zb.prototype.containPoint = function(t) {
		var e = this._coordsList[0];
		if (e) return e.containPoint(t)
	}, Zb.prototype._initCartesian = function(o, t, e) {
		var a = this,
			s = this,
			l = {
				left: !1,
				right: !1,
				top: !1,
				bottom: !1
			},
			u = {
				x: {},
				y: {}
			},
			h = {
				x: 0,
				y: 0
			};

		function n(r) {
			return function(t, e) {
				var n, i;
				Kb(t, o) && (n = t.get("position"), "x" === r ? "top" !== n && "bottom" !== n && (n = l
					.bottom ? "top" : "bottom") : "left" !== n && "right" !== n && (n = l.left ?
					"right" : "left"), l[n] = !0, i = "category" === (n = new Gb(r, Y_(t), [0, 0], t
					.get("type"), n)).type, n.onBand = i && t.get("boundaryGap"), n.inverse = t.get(
					"inverse"), (t.axis = n).model = t, n.grid = s, n.index = e, s._axesList.push(
					n), u[r][e] = n, h[r]++)
			}
		}
		t.eachComponent("xAxis", n("x"), this), t.eachComponent("yAxis", n("y"), this), h.x && h.y ? E((this
			._axesMap = u).x, function(i, r) {
			E(u.y, function(t, e) {
				var e = "x" + r + "y" + e,
					n = new Fb(e);
				n.master = a, n.model = o, a._coordsMap[e] = n, a._coordsList.push(n), n
					.addAxis(i), n.addAxis(t)
			})
		}) : (this._axesMap = {}, this._axesList = [])
	}, Zb.prototype._updateScale = function(t, i) {
		function r(e, n) {
			var i, t, r;
			E((i = e, t = n.dim, r = {}, E(i.mapDimensionsAll(t), function(t) {
				r[Wv(i, t)] = !0
			}), R(r)), function(t) {
				n.scale.unionExtentFromData(e, t)
			})
		}
		E(this._axesList, function(t) {
			var e;
			t.scale.setExtent(1 / 0, -1 / 0), "category" === t.type && (e = t.model.get(
				"categorySortInfo"), t.scale.setSortInfo(e))
		}), t.eachSeries(function(t) {
			var e, n;
			Xb(t) && (n = (e = Yb(t)).xAxisModel, e = e.yAxisModel, Kb(n, i)) && Kb(e, i) && (n = this
				.getCartesian(n.componentIndex, e.componentIndex), e = t.getData(), t = n.getAxis(
					"x"), n = n.getAxis("y"), r(e, t), r(e, n))
		}, this)
	}, Zb.prototype.getTooltipAxes = function(n) {
		var i = [],
			r = [];
		return E(this.getCartesians(), function(t) {
			var e = null != n && "auto" !== n ? t.getAxis(n) : t.getBaseAxis(),
				t = t.getOtherAxis(e);
			I(i, e) < 0 && i.push(e), I(r, t) < 0 && r.push(t)
		}), {
			baseAxes: i,
			otherAxes: r
		}
	}, Zb.create = function(i, r) {
		var o = [];
		return i.eachComponent("grid", function(t, e) {
			var n = new Zb(t, i, r);
			n.name = "grid_" + e, n.resize(t, r, !0), t.coordinateSystem = n, o.push(n)
		}), i.eachSeries(function(t) {
			var e, n, i;
			Xb(t) && (e = (n = Yb(t)).xAxisModel, n = n.yAxisModel, i = e.getCoordSysModel()
				.coordinateSystem, t.coordinateSystem = i.getCartesian(e.componentIndex, n
					.componentIndex))
		}), o
	}, Zb.dimensions = Eb;
	var jb = Zb;

	function Zb(t, e, n) {
		this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [],
			this.axisPointerEnabled = !0, this.dimensions = Eb, this._initCartesian(t, e, n), this.model = t
	}

	function Kb(t, e) {
		return t.getCoordSysModel() === e
	}

	function $b(t, e, n, i) {
		n.getAxesOnZeroOf = function() {
			return r ? [r] : []
		};
		var r, o = t[e],
			t = n.model,
			e = t.get(["axisLine", "onZero"]),
			n = t.get(["axisLine", "onZeroAxisIndex"]);
		if (e) {
			if (null != n) Qb(o[n]) && (r = o[n]);
			else
				for (var a in o)
					if (o.hasOwnProperty(a) && Qb(o[a]) && !i[s(o[a])]) {
						r = o[a];
						break
					} r && (i[s(r)] = !0)
		}

		function s(t) {
			return t.dim + "_" + t.index
		}
	}

	function Qb(t) {
		return t && "category" !== t.type && "time" !== t.type && (e = (t = (t = t).scale.getExtent())[0], t = t[1],
			!(0 < e && 0 < t || e < 0 && t < 0));
		var e
	}
	var Jb = Math.PI,
		tS = (nS.prototype.hasBuilder = function(t) {
			return !!eS[t]
		}, nS.prototype.add = function(t) {
			eS[t](this.opt, this.axisModel, this.group, this._transformGroup)
		}, nS.prototype.getGroup = function() {
			return this.group
		}, nS.innerTextLayout = function(t, e, n) {
			var i, e = xo(e - t),
				t = wo(e) ? (i = 0 < n ? "top" : "bottom", "center") : wo(e - Jb) ? (i = 0 < n ? "bottom" :
					"top", "center") : (i = "middle", 0 < e && e < Jb ? 0 < n ? "right" : "left" : 0 < n ?
					"left" : "right");
			return {
				rotation: e,
				textAlign: t,
				textVerticalAlign: i
			}
		}, nS.makeAxisEventDataBase = function(t) {
			var e = {
				componentType: t.mainType,
				componentIndex: t.componentIndex
			};
			return e[t.mainType + "Index"] = t.componentIndex, e
		}, nS.isLabelSilent = function(t) {
			var e = t.get("tooltip");
			return t.get("silent") || !(t.get("triggerEvent") || e && e.show)
		}, nS),
		eS = {
			axisLine: function(i, t, r, e) {
				var o, a, s, l, u, h, c, n = t.get(["axisLine", "show"]);
				(n = "auto" === n && i.handleAutoShown ? i.handleAutoShown("axisLine") : n) && (n = t.axis
					.getExtent(), e = e.transform, o = [n[0], 0], a = [n[1], 0], s = a[0] < o[0], e && (ne(o, o,
						e), ne(a, a, e)), l = O({
						lineCap: "round"
					}, t.getModel(["axisLine", "lineStyle"]).getLineStyle()), dc((n = new fh({
						shape: {
							x1: o[0],
							y1: o[1],
							x2: a[0],
							y2: a[1]
						},
						style: l,
						strokeContainThreshold: i.strokeContainThreshold || 5,
						silent: !0,
						z2: 1
					})).shape, n.style.lineWidth), n.anid = "line", r.add(n), null != (u = t.get(["axisLine",
						"symbol"
					]))) && (e = t.get(["axisLine", "symbolSize"]), H(u) && (u = [u, u]), (H(e) || G(e)) && (
					e = [e, e]), n = mm(t.get(["axisLine", "symbolOffset"]) || 0, e), h = e[0], c = e[1], E(
					[{
						rotate: i.rotation + Math.PI / 2,
						offset: n[0],
						r: 0
					}, {
						rotate: i.rotation - Math.PI / 2,
						offset: n[1],
						r: Math.sqrt((o[0] - a[0]) * (o[0] - a[0]) + (o[1] - a[1]) * (o[1] - a[1]))
					}],
					function(t, e) {
						var n;
						"none" !== u[e] && null != u[e] && (e = ym(u[e], -h / 2, -c / 2, h, c, l.stroke, !
							0), n = t.r + t.offset, e.attr({
							rotation: t.rotate,
							x: (t = s ? a : o)[0] + n * Math.cos(i.rotation),
							y: t[1] - n * Math.sin(i.rotation),
							silent: !0,
							z2: 11
						}), r.add(e))
					}))
			},
			axisTickLabel: function(t, e, n, i) {
				var r, o, a, s = function(t, e, n, i) {
						var r = n.axis,
							o = n.getModel("axisTick"),
							a = o.get("show");
						if ((a = "auto" === a && i.handleAutoShown ? i.handleAutoShown("axisTick") : a) && !r
							.scale.isBlank()) {
							for (var a = o.getModel("lineStyle"), i = i.tickDirection * o.get("length"), s = aS(
									r.getTicksCoords(), e.transform, i, B(a.getLineStyle(), {
										stroke: n.get(["axisLine", "lineStyle", "color"])
									}), "ticks"), l = 0; l < s.length; l++) t.add(s[l]);
							return s
						}
					}(n, i, e, t),
					l = function(l, u, h, c) {
						var p = h.axis; {
							var d, f, t, e, g, y, m, v, _;
							if (bt(c.axisLabelShow, h.get(["axisLabel", "show"])) && !p.scale.isBlank())
								return d = h.getModel("axisLabel"), f = d.get("margin"), t = p.getViewLabels(),
									e = (bt(c.labelRotate, d.get("rotate")) || 0) * Jb / 180, g = tS
									.innerTextLayout(c.rotation, e, c.labelDirection), y = h.getCategories && h
									.getCategories(!0), m = [], v = tS.isLabelSilent(h), _ = h.get(
										"triggerEvent"), E(t, function(t, e) {
										var n = "ordinal" === p.scale.type ? p.scale.getRawOrdinalNumber(t
												.tickValue) : t.tickValue,
											i = t.formattedLabel,
											r = t.rawLabel,
											o = d,
											a = (o = y && y[n] && L(a = y[n]) && a.textStyle ? new Qc(a
												.textStyle, d, h.ecModel) : o).getTextColor() || h.get([
												"axisLine", "lineStyle", "color"
											]),
											s = p.dataToCoord(n),
											s = new Ks({
												x: s,
												y: c.labelOffset + c.labelDirection * f,
												rotation: g.rotation,
												silent: v,
												z2: 10 + (t.level || 0),
												style: Lc(o, {
													text: i,
													align: o.getShallow("align", !0) || g
														.textAlign,
													verticalAlign: o.getShallow("verticalAlign",
														!0) || o.getShallow("baseline", !
														0) || g.textVerticalAlign,
													fill: S(a) ? a("category" === p.type ? r :
														"value" === p.type ? n + "" : n, e
													) : a
												})
											});
										s.anid = "label_" + n, _ && ((t = tS.makeAxisEventDataBase(h))
												.targetType = "axisLabel", t.value = r, t.tickIndex = e,
												"category" === p.type && (t.dataIndex = n), k(s).eventData =
												t), u.add(s), s.updateTransform(), m.push(s), l.add(s), s
											.decomposeTransform()
									}), m
						}
					}(n, i, e, t),
					u = e,
					h = l,
					c = ($_(u.axis) || (d = u.get(["axisLabel", "showMinLabel"]), u = u.get(["axisLabel",
							"showMaxLabel"
						]), s = s || [], y = (h = h || [])[0], f = h[1], r = h[h.length - 1], h = h[h
							.length - 2], o = s[0], g = s[1], a = s[s.length - 1], s = s[s.length - 2], !
						1 === d ? (iS(y), iS(o)) : rS(y, f) && (d ? (iS(f), iS(g)) : (iS(y), iS(o))), !1 ===
						u ? (iS(r), iS(a)) : rS(h, r) && (u ? (iS(h), iS(s)) : (iS(r), iS(a)))), n),
					p = i,
					d = e,
					f = t.tickDirection,
					g = d.axis,
					y = d.getModel("minorTick");
				if (y.get("show") && !g.scale.isBlank()) {
					var m = g.getMinorTicksCoords();
					if (m.length)
						for (var g = y.getModel("lineStyle"), v = f * y.get("length"), _ = B(g.getLineStyle(),
								B(d.getModel("axisTick").getLineStyle(), {
									stroke: d.get(["axisLine", "lineStyle", "color"])
								})), x = 0; x < m.length; x++)
							for (var w = aS(m[x], p.transform, v, _, "minorticks_" + x), b = 0; b < w
								.length; b++) c.add(w[b])
				}
				e.get(["axisLabel", "hideOverlap"]) && ex(Q1(F(l, function(t) {
					return {
						label: t,
						priority: t.z2,
						defaultAttr: {
							ignore: t.ignore
						}
					}
				})))
			},
			axisName: function(t, e, n, i) {
				var r, o, a, s, l, u, h, c, p = bt(t.axisName, e.get("name"));
				p && (l = e.get("nameLocation"), s = t.nameDirection, o = e.getModel("nameTextStyle"), u = e
					.get("nameGap") || 0, a = (h = e.axis.getExtent())[0] > h[1] ? -1 : 1, a = ["start" ===
						l ? h[0] - a * u : "end" === l ? h[1] + a * u : (h[0] + h[1]) / 2, oS(l) ? t
						.labelOffset + s * u : 0
					], null != (u = e.get("nameRotate")) && (u = u * Jb / 180), oS(l) ? r = tS
					.innerTextLayout(t.rotation, null != u ? u : t.rotation, s) : (s = t.rotation, l = l,
						h = h, u = xo((u = u || 0) - s), s = h[0] > h[1], h = "start" === l && !s ||
						"start" !== l && s, l = wo(u - Jb / 2) ? (c = h ? "bottom" : "top", "center") : wo(
							u - 1.5 * Jb) ? (c = h ? "top" : "bottom", "center") : (c = "middle", u < 1.5 *
							Jb && Jb / 2 < u ? h ? "left" : "right" : h ? "right" : "left"), r = {
							rotation: u,
							textAlign: l,
							textVerticalAlign: c
						}, null == (c = t.axisNameAvailableWidth) || (c = Math.abs(c / Math.sin(r
							.rotation)), isFinite(c)) || (c = null)), s = o.getFont(), u = (h = e.get(
						"nameTruncate", !0) || {}).ellipsis, l = bt(t.nameTruncateMaxWidth, h.maxWidth, c),
					Sc({
						el: t = new Ks({
							x: a[0],
							y: a[1],
							rotation: r.rotation,
							silent: tS.isLabelSilent(e),
							style: Lc(o, {
								text: p,
								font: s,
								overflow: "truncate",
								width: l,
								ellipsis: u,
								fill: o.getTextColor() || e.get(["axisLine",
									"lineStyle", "color"
								]),
								align: o.get("align") || r.textAlign,
								verticalAlign: o.get("verticalAlign") || r
									.textVerticalAlign
							}),
							z2: 1
						}),
						componentModel: e,
						itemName: p
					}), t.__fullText = p, t.anid = "name", e.get("triggerEvent") && ((h = tS
							.makeAxisEventDataBase(e)).targetType = "axisName", h.name = p, k(t).eventData =
						h), i.add(t), t.updateTransform(), n.add(t), t.decomposeTransform())
			}
		};

	function nS(t, e) {
		this.group = new no, this.opt = e, this.axisModel = t, B(e, {
			labelOffset: 0,
			nameDirection: 1,
			tickDirection: 1,
			labelDirection: 1,
			silent: !0,
			handleAutoShown: function() {
				return !0
			}
		});
		t = new no({
			x: e.position[0],
			y: e.position[1],
			rotation: e.rotation
		});
		t.updateTransform(), this._transformGroup = t
	}

	function iS(t) {
		t && (t.ignore = !0)
	}

	function rS(t, e) {
		var n, i = t && t.getBoundingRect().clone(),
			r = e && e.getBoundingRect().clone();
		if (i && r) return Be(n = Re([]), n, -t.rotation), i.applyTransform(Ee([], n, t.getLocalTransform())), r
			.applyTransform(Ee([], n, e.getLocalTransform())), i.intersect(r)
	}

	function oS(t) {
		return "middle" === t || "center" === t
	}

	function aS(t, e, n, i, r) {
		for (var o = [], a = [], s = [], l = 0; l < t.length; l++) {
			var u = t[l].coord,
				u = (a[0] = u, s[a[1] = 0] = u, s[1] = n, e && (ne(a, a, e), ne(s, s, e)), new fh({
					shape: {
						x1: a[0],
						y1: a[1],
						x2: s[0],
						y2: s[1]
					},
					style: i,
					z2: 2,
					autoBatch: !0,
					silent: !0
				}));
			dc(u.shape, u.style.lineWidth), u.anid = r + "_" + t[l].tickValue, o.push(u)
		}
		return o
	}

	function sS(t, e) {
		var r, h, c, o, p, d, f, n = {
			axesInfo: {},
			seriesInvolved: !1,
			coordSysAxesInfo: {},
			coordSysMap: {}
		};
		return h = n, e = e, o = (c = t).getComponent("tooltip"), p = c.getComponent("axisPointer"), d = p.get(
			"link", !0) || [], f = [], E(e.getCoordinateSystems(), function(s) {
			var l, u, t, e, n;

			function i(t, e, n) {
				var i, r, o = n.model.getModel("axisPointer", p),
					a = o.get("show");
				a && ("auto" !== a || t || hS(o)) && (null == e && (e = o.get("triggerTooltip")), a = (o =
					t ? function(t, e, n, i, r, o) {
						var a = e.getModel("axisPointer"),
							s = {},
							e = (E(["type", "snap", "lineStyle", "shadowStyle", "label",
								"animation", "animationDurationUpdate",
								"animationEasingUpdate", "z"
							], function(t) {
								s[t] = _(a.get(t))
							}), s.snap = "category" !== t.type && !!o, "cross" === a.get(
								"type") && (s.type = "line"), s.label || (s.label = {}));
						null == e.show && (e.show = !1), "cross" === r && (r = a.get(["label",
							"show"
						]), e.show = null == r || r, o || (r = s.lineStyle = a.get(
							"crossStyle")) && B(e, r.textStyle));
						return t.model.getModel("axisPointer", new Qc(s, n, i))
					}(n, u, p, c, t, e) : o).get("snap"), t = o.get("triggerEmphasis"), i = cS(n
					.model), r = e || a || "category" === n.type, e = h.axesInfo[i] = {
					key: i,
					axis: n,
					coordSys: s,
					axisPointerModel: o,
					triggerTooltip: e,
					triggerEmphasis: t,
					involveSeries: r,
					snap: a,
					useHandle: hS(o),
					seriesModels: [],
					linkGroup: null
				}, l[i] = e, h.seriesInvolved = h.seriesInvolved || r, null != (t = function(t, e) {
					for (var n = e.model, i = e.dim, r = 0; r < t.length; r++) {
						var o = t[r] || {};
						if (lS(o[i + "AxisId"], n.id) || lS(o[i + "AxisIndex"], n
								.componentIndex) || lS(o[i + "AxisName"], n.name)) return r
					}
				}(d, n))) && ((a = f[t] || (f[t] = {
					axesInfo: {}
				})).axesInfo[i] = e, a.mapper = d[t].mapper, e.linkGroup = a)
			}
			s.axisPointerEnabled && (t = cS(s.model), l = h.coordSysAxesInfo[t] = {}, u = (h.coordSysMap[
					t] = s).model.getModel("tooltip", o), E(s.getAxes(), dt(i, !1, null)), s
				.getTooltipAxes) && o && u.get("show") && (t = "axis" === u.get("trigger"), e =
				"cross" === u.get(["axisPointer", "type"]), n = s.getTooltipAxes(u.get(["axisPointer",
					"axis"
				])), (t || e) && E(n.baseAxes, dt(i, !e || "cross", t)), e) && E(n.otherAxes, dt(i,
				"cross", !1))
		}), n.seriesInvolved && (r = n, t.eachSeries(function(n) {
			var i = n.coordinateSystem,
				t = n.get(["tooltip", "trigger"], !0),
				e = n.get(["tooltip", "show"], !0);
			i && "none" !== t && !1 !== t && "item" !== t && !1 !== e && !1 !== n.get(["axisPointer",
				"show"
			], !0) && E(r.coordSysAxesInfo[cS(i.model)], function(t) {
				var e = t.axis;
				i.getAxis(e.dim) === e && (t.seriesModels.push(n), null == t.seriesDataCount &&
					(t.seriesDataCount = 0), t.seriesDataCount += n.getData().count())
			})
		})), n
	}

	function lS(t, e) {
		return "all" === t || V(t) && 0 <= I(t, e) || t === e
	}

	function uS(t) {
		var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
		return e && e.axesInfo[cS(t)]
	}

	function hS(t) {
		return !!t.get(["handle", "show"])
	}

	function cS(t) {
		return t.type + "||" + t.id
	}
	var pS, dS = {},
		fS = (u(gS, pS = uy), gS.prototype.render = function(t, e, n, i) {
			var r, o, a, s, l, u;
			this.axisPointerClass && (r = uS(r = t)) && (l = r.axisPointerModel, o = r.axis.scale, a = l.option,
					u = l.get("status"), null != (s = l.get("value")) && (s = o.parse(s)), l = hS(l), null ==
					u && (a.status = l ? "show" : "hide"), (u = o.getExtent().slice())[0] > u[1] && u.reverse(),
					(s = null == s || s > u[1] ? u[1] : s) < u[0] && (s = u[0]), a.value = s, l) && (a.status =
					r.axis.scale.isBlank() ? "hide" : "show"), pS.prototype.render.apply(this, arguments), this
				._doUpdateAxisPointerClass(t, n, !0)
		}, gS.prototype.updateAxisPointer = function(t, e, n, i) {
			this._doUpdateAxisPointerClass(t, n, !1)
		}, gS.prototype.remove = function(t, e) {
			var n = this._axisPointer;
			n && n.remove(e)
		}, gS.prototype.dispose = function(t, e) {
			this._disposeAxisPointer(e), pS.prototype.dispose.apply(this, arguments)
		}, gS.prototype._doUpdateAxisPointerClass = function(t, e, n) {
			var i, r = gS.getAxisPointerClass(this.axisPointerClass);
			r && ((i = (i = uS(i = t)) && i.axisPointerModel) ? (this._axisPointer || (this._axisPointer =
				new r)).render(t, i, e, n) : this._disposeAxisPointer(e))
		}, gS.prototype._disposeAxisPointer = function(t) {
			this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null
		}, gS.registerAxisPointerClass = function(t, e) {
			dS[t] = e
		}, gS.getAxisPointerClass = function(t) {
			return t && dS[t]
		}, gS.type = "axis", gS);

	function gS() {
		var t = null !== pS && pS.apply(this, arguments) || this;
		return t.type = gS.type, t
	}
	var yS = Yo();
	var mS, vS, _S = ["axisLine", "axisTickLabel", "axisName"],
		xS = ["splitArea", "splitLine", "minorSplitLine"],
		xh = (u(MS, vS = fS), MS.prototype.render = function(i, t, e, n) {
			this.group.removeAll();
			var r, o, a = this._axisGroup;
			this._axisGroup = new no, this.group.add(this._axisGroup), i.get("show") && (o = Ub(r = i
					.getCoordSysModel(), i), o = new tS(i, O({
					handleAutoShown: function(t) {
						for (var e = r.coordinateSystem.getCartesians(), n = 0; n < e
							.length; n++)
							if ($v(e[n].getOtherAxis(i.axis).scale)) return !0;
						return !1
					}
				}, o)), E(_S, o.add, o), this._axisGroup.add(o.getGroup()), E(xS, function(t) {
					i.get([t, "show"]) && wS[t](this, this._axisGroup, i, r)
				}, this), n && "changeAxisOrder" === n.type && n.isInitSort || vc(a, this._axisGroup, i), vS
				.prototype.render.call(this, i, t, e, n))
		}, MS.prototype.remove = function() {
			yS(this).splitAreaColors = null
		}, MS.type = "cartesianAxis", MS),
		wS = {
			splitLine: function(t, e, n, i) {
				var r = n.axis;
				if (!r.scale.isBlank())
					for (var n = n.getModel("splitLine"), o = n.getModel("lineStyle"), a = V(a = o.get(
								"color")) ? a : [a], s = i.coordinateSystem.getRect(), l = r.isHorizontal(), u =
							0,
							h = r.getTicksCoords({
								tickModel: n
							}), c = [], p = [], d = o.getLineStyle(), f = 0; f < h.length; f++) {
						var g = r.toGlobalCoord(h[f].coord),
							g = (l ? (c[0] = g, c[1] = s.y, p[0] = g, p[1] = s.y + s.height) : (c[0] = s.x, c[
								1] = g, p[0] = s.x + s.width, p[1] = g), u++ % a.length),
							y = h[f].tickValue,
							y = new fh({
								anid: null != y ? "line_" + h[f].tickValue : null,
								autoBatch: !0,
								shape: {
									x1: c[0],
									y1: c[1],
									x2: p[0],
									y2: p[1]
								},
								style: B({
									stroke: a[g]
								}, d),
								silent: !0
							});
						dc(y.shape, d.lineWidth), e.add(y)
					}
			},
			minorSplitLine: function(t, e, n, i) {
				var r = n.axis,
					n = n.getModel("minorSplitLine").getModel("lineStyle"),
					o = i.coordinateSystem.getRect(),
					a = r.isHorizontal(),
					s = r.getMinorTicksCoords();
				if (s.length)
					for (var l = [], u = [], h = n.getLineStyle(), c = 0; c < s.length; c++)
						for (var p = 0; p < s[c].length; p++) {
							var d = r.toGlobalCoord(s[c][p].coord),
								d = (a ? (l[0] = d, l[1] = o.y, u[0] = d, u[1] = o.y + o.height) : (l[0] = o.x,
									l[1] = d, u[0] = o.x + o.width, u[1] = d), new fh({
									anid: "minor_line_" + s[c][p].tickValue,
									autoBatch: !0,
									shape: {
										x1: l[0],
										y1: l[1],
										x2: u[0],
										y2: u[1]
									},
									style: h,
									silent: !0
								}));
							dc(d.shape, h.lineWidth), e.add(d)
						}
			},
			splitArea: function(t, e, n, i) {
				var r = e,
					e = i,
					o = (i = n).axis;
				if (!o.scale.isBlank()) {
					var i = i.getModel("splitArea"),
						n = i.getModel("areaStyle"),
						a = n.get("color"),
						s = e.coordinateSystem.getRect(),
						l = o.getTicksCoords({
							tickModel: i,
							clamp: !0
						});
					if (l.length) {
						var u = a.length,
							h = yS(t).splitAreaColors,
							c = z(),
							p = 0;
						if (h)
							for (var d = 0; d < l.length; d++) {
								var f = h.get(l[d].tickValue);
								if (null != f) {
									p = (f + (u - 1) * d) % u;
									break
								}
							}
						for (var g = o.toGlobalCoord(l[0].coord), y = n.getAreaStyle(), a = V(a) ? a : [a], d =
								1; d < l.length; d++) {
							var m = o.toGlobalCoord(l[d].coord),
								v = void 0,
								_ = void 0,
								x = void 0,
								w = void 0,
								g = o.isHorizontal() ? (v = g, _ = s.y, w = s.height, v + (x = m - v)) : (v = s
									.x, _ = g, x = s.width, _ + (w = m - _)),
								m = l[d - 1].tickValue;
							null != m && c.set(m, p), r.add(new Xs({
								anid: null != m ? "area_" + m : null,
								shape: {
									x: v,
									y: _,
									width: x,
									height: w
								},
								style: B({
									fill: a[p]
								}, y),
								autoBatch: !0,
								silent: !0
							})), p = (p + 1) % u
						}
						yS(t).splitAreaColors = c
					}
				}
			}
		},
		bS = (u(SS, mS = xh), SS.type = "xAxis", SS);

	function SS() {
		var t = null !== mS && mS.apply(this, arguments) || this;
		return t.type = SS.type, t
	}

	function MS() {
		var t = null !== vS && vS.apply(this, arguments) || this;
		return t.type = MS.type, t.axisPointerClass = "CartesianAxisPointer", t
	}
	u(IS, TS = xh), IS.type = "yAxis";
	var TS, CS = IS;

	function IS() {
		var t = null !== TS && TS.apply(this, arguments) || this;
		return t.type = bS.type, t
	}
	u(PS, kS = uy), PS.prototype.render = function(t, e) {
		this.group.removeAll(), t.get("show") && this.group.add(new Xs({
			shape: t.coordinateSystem.getRect(),
			style: B({
				fill: t.get("backgroundColor")
			}, t.getItemStyle()),
			silent: !0,
			z2: -1
		}))
	}, PS.type = "grid";
	var kS, DS = PS,
		AS = {
			offset: 0
		};

	function PS() {
		var t = null !== kS && kS.apply(this, arguments) || this;
		return t.type = "grid", t
	}
	n1(function(t) {
		t.registerComponentView(DS), t.registerComponentModel(Cb), t.registerCoordinateSystem("cartesian2d",
				jb), Ob(t, "x", Db, AS), Ob(t, "y", Db, AS), t.registerComponentView(bS), t
			.registerComponentView(CS), t.registerPreprocessor(function(t) {
				t.xAxis && t.yAxis && !t.grid && (t.grid = {})
			})
	});
	u(zS, OS = g), zS.type = "title", zS.defaultOption = {
		z: 6,
		show: !0,
		text: "",
		target: "blank",
		subtext: "",
		subtarget: "blank",
		left: 0,
		top: 0,
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: "#ccc",
		borderWidth: 0,
		padding: 5,
		itemGap: 10,
		textStyle: {
			fontSize: 18,
			fontWeight: "bold",
			color: "#464646"
		},
		subtextStyle: {
			fontSize: 12,
			color: "#6E7079"
		}
	};
	var LS, OS, RS = zS,
		NS = (u(ES, LS = uy), ES.prototype.render = function(t, e, n) {
			var i, r, o, a, s, l, u, h, c;
			this.group.removeAll(), t.get("show") && (i = this.group, u = t.getModel("textStyle"), r = t
				.getModel("subtextStyle"), h = t.get("textAlign"), c = N(t.get("textBaseline"), t.get(
					"textVerticalAlign")), s = (u = new Ks({
					style: Lc(u, {
						text: t.get("text"),
						fill: u.getTextColor()
					}, {
						disableBox: !0
					}),
					z2: 10
				})).getBoundingRect(), l = t.get("subtext"), r = new Ks({
					style: Lc(r, {
						text: l,
						fill: r.getTextColor(),
						y: s.height + t.get("itemGap"),
						verticalAlign: "top"
					}, {
						disableBox: !0
					}),
					z2: 10
				}), o = t.get("link"), a = t.get("sublink"), s = t.get("triggerEvent", !0), u.silent = !o &&
				!s, r.silent = !a && !s, o && u.on("click", function() {
					Yp(o, "_" + t.get("target"))
				}), a && r.on("click", function() {
					Yp(a, "_" + t.get("subtarget"))
				}), k(u).eventData = k(r).eventData = s ? {
					componentType: "title",
					componentIndex: t.componentIndex
				} : null, i.add(u), l && i.add(r), s = i.getBoundingRect(), (l = t.getBoxLayoutParams())
				.width = s.width, l.height = s.height, l = Qp(l, {
					width: n.getWidth(),
					height: n.getHeight()
				}, t.get("padding")), h || ("right" === (h = "middle" === (h = t.get("left") || t.get(
					"right")) ? "center" : h) ? l.x += l.width : "center" === h && (l.x += l.width / 2)),
				c || ("bottom" === (c = "center" === (c = t.get("top") || t.get("bottom")) ? "middle" : c) ?
					l.y += l.height : "middle" === c && (l.y += l.height / 2), c = c || "top"), i.x = l.x, i
				.y = l.y, i.markRedraw(), u.setStyle(n = {
					align: h,
					verticalAlign: c
				}), r.setStyle(n), s = i.getBoundingRect(), u = l.margin, (h = t.getItemStyle(["color",
					"opacity"
				])).fill = t.get("backgroundColor"), c = new Xs({
					shape: {
						x: s.x - u[3],
						y: s.y - u[0],
						width: s.width + u[1] + u[3],
						height: s.height + u[0] + u[2],
						r: t.get("borderRadius")
					},
					style: h,
					subPixelOptimize: !0,
					silent: !0
				}), i.add(c))
		}, ES.type = "title", ES);

	function ES() {
		var t = null !== LS && LS.apply(this, arguments) || this;
		return t.type = ES.type, t
	}

	function zS() {
		var t = null !== OS && OS.apply(this, arguments) || this;
		return t.type = zS.type, t.layoutMode = {
			type: "box",
			ignoreSize: !0
		}, t
	}
	n1(function(t) {
		t.registerComponentModel(RS), t.registerComponentView(NS)
	});
	u(VS, BS = g), VS.prototype.init = function(t, e, n) {
		this.mergeDefaultAndTheme(t, n), t.selected = t.selected || {}, this._updateSelector(t)
	}, VS.prototype.mergeOption = function(t, e) {
		BS.prototype.mergeOption.call(this, t, e), this._updateSelector(t)
	}, VS.prototype._updateSelector = function(t) {
		var n = t.selector,
			i = this.ecModel;
		V(n = !0 === n ? t.selector = ["all", "inverse"] : n) && E(n, function(t, e) {
			H(t) && (t = {
				type: t
			}), n[e] = d(t, (e = i, "all" === (t = t.type) ? {
				type: "all",
				title: e.getLocaleModel().get(["legend", "selector", "all"])
			} : "inverse" === t ? {
				type: "inverse",
				title: e.getLocaleModel().get(["legend", "selector", "inverse"])
			} : void 0))
		})
	}, VS.prototype.optionUpdated = function() {
		this._updateData(this.ecModel);
		var t = this._data;
		if (t[0] && "single" === this.get("selectedMode")) {
			for (var e = !1, n = 0; n < t.length; n++) {
				var i = t[n].get("name");
				if (this.isSelected(i)) {
					this.select(i), e = !0;
					break
				}
			}
			e || this.select(t[0].get("name"))
		}
	}, VS.prototype._updateData = function(i) {
		var r = [],
			o = [],
			t = (i.eachRawSeries(function(t) {
				var e, n = t.name;
				o.push(n), t.legendVisualProvider && (n = t.legendVisualProvider.getAllNames(), i
						.isSeriesFiltered(t) || (o = o.concat(n)), n.length) ? r = r.concat(n) : e = !0,
					e && Go(t) && r.push(t.name)
			}), this._availableNames = o, this.get("data") || r),
			e = z(),
			t = F(t, function(t) {
				return (H(t) || G(t)) && (t = {
					name: t
				}), e.get(t.name) ? null : (e.set(t.name, !0), new Qc(t, this, this.ecModel))
			}, this);
		this._data = ct(t, function(t) {
			return !!t
		})
	}, VS.prototype.getData = function() {
		return this._data
	}, VS.prototype.select = function(t) {
		var e = this.option.selected;
		"single" === this.get("selectedMode") && E(this._data, function(t) {
			e[t.get("name")] = !1
		}), e[t] = !0
	}, VS.prototype.unSelect = function(t) {
		"single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
	}, VS.prototype.toggleSelected = function(t) {
		var e = this.option.selected;
		e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
	}, VS.prototype.allSelect = function() {
		var t = this._data,
			e = this.option.selected;
		E(t, function(t) {
			e[t.get("name", !0)] = !0
		})
	}, VS.prototype.inverseSelect = function() {
		var t = this._data,
			e = this.option.selected;
		E(t, function(t) {
			t = t.get("name", !0);
			e.hasOwnProperty(t) || (e[t] = !0), e[t] = !e[t]
		})
	}, VS.prototype.isSelected = function(t) {
		var e = this.option.selected;
		return !(e.hasOwnProperty(t) && !e[t]) && 0 <= I(this._availableNames, t)
	}, VS.prototype.getOrient = function() {
		return "vertical" === this.get("orient") ? {
			index: 1,
			name: "vertical"
		} : {
			index: 0,
			name: "horizontal"
		}
	}, VS.type = "legend.plain", VS.dependencies = ["series"], VS.defaultOption = {
		z: 4,
		show: !0,
		orient: "horizontal",
		left: "center",
		top: 0,
		align: "auto",
		backgroundColor: "rgba(0,0,0,0)",
		borderColor: "#ccc",
		borderRadius: 0,
		borderWidth: 0,
		padding: 5,
		itemGap: 10,
		itemWidth: 25,
		itemHeight: 14,
		symbolRotate: "inherit",
		symbolKeepAspect: !0,
		inactiveColor: "#ccc",
		inactiveBorderColor: "#ccc",
		inactiveBorderWidth: "auto",
		itemStyle: {
			color: "inherit",
			opacity: "inherit",
			borderColor: "inherit",
			borderWidth: "auto",
			borderCap: "inherit",
			borderJoin: "inherit",
			borderDashOffset: "inherit",
			borderMiterLimit: "inherit"
		},
		lineStyle: {
			width: "auto",
			color: "inherit",
			inactiveColor: "#ccc",
			inactiveWidth: 2,
			opacity: "inherit",
			type: "inherit",
			cap: "inherit",
			join: "inherit",
			dashOffset: "inherit",
			miterLimit: "inherit"
		},
		textStyle: {
			color: "#333"
		},
		selectedMode: !0,
		selector: !1,
		selectorLabel: {
			show: !0,
			borderRadius: 10,
			padding: [3, 5, 3, 5],
			fontSize: 12,
			fontFamily: "sans-serif",
			color: "#666",
			borderWidth: 1,
			borderColor: "#666"
		},
		emphasis: {
			selectorLabel: {
				show: !0,
				color: "#eee",
				backgroundColor: "#666"
			}
		},
		selectorPosition: "auto",
		selectorItemGap: 7,
		selectorButtonGap: 10,
		tooltip: {
			show: !1
		}
	};
	var BS, FS = VS;

	function VS() {
		var t = null !== BS && BS.apply(this, arguments) || this;
		return t.type = VS.type, t.layoutMode = {
			type: "box",
			ignoreSize: !0
		}, t
	}
	var HS, GS = dt,
		WS = E,
		US = no,
		XS = (u(YS, HS = uy), YS.prototype.init = function() {
			this.group.add(this._contentGroup = new US), this.group.add(this._selectorGroup = new US), this
				._isFirstRender = !0
		}, YS.prototype.getContentGroup = function() {
			return this._contentGroup
		}, YS.prototype.getSelectorGroup = function() {
			return this._selectorGroup
		}, YS.prototype.render = function(t, e, n) {
			var i, r, o, a, s, l = this._isFirstRender;
			this._isFirstRender = !1, this.resetInner(), t.get("show", !0) && (r = t.get("align"), i = t.get(
					"orient"), r && "auto" !== r || (r = "right" === t.get("left") && "vertical" === i ?
					"right" : "left"), a = t.get("selector", !0), s = t.get("selectorPosition", !0), this
				.renderInner(r, t, e, n, a, i, s = !a || s && "auto" !== s ? s : "horizontal" === i ?
					"end" : "start"), o = Qp(e = t.getBoxLayoutParams(), i = {
					width: n.getWidth(),
					height: n.getHeight()
				}, n = t.get("padding")), o = Qp(B({
					width: (r = this.layoutInner(t, r, o, l, a, s)).width,
					height: r.height
				}, e), i, n), this.group.x = o.x - r.x, this.group.y = o.y - r.y, this.group.markRedraw(),
				this.group.add(this._backgroundEl = (l = r, s = Fp((a = t).get("padding")), (e = a
					.getItemStyle(["color", "opacity"])).fill = a.get("backgroundColor"), new Xs({
					shape: {
						x: l.x - s[3],
						y: l.y - s[0],
						width: l.width + s[1] + s[3],
						height: l.height + s[0] + s[2],
						r: a.get("borderRadius")
					},
					style: e,
					silent: !0,
					z2: -1
				}))))
		}, YS.prototype.resetInner = function() {
			this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl),
				this.getSelectorGroup().removeAll()
		}, YS.prototype.renderInner = function(s, l, u, h, t, e, n) {
			var c = this.getContentGroup(),
				p = z(),
				d = l.get("selectedMode"),
				f = [];
			u.eachRawSeries(function(t) {
				t.get("legendHoverLink") || f.push(t.id)
			}), WS(l.getData(), function(r, o) {
				var t, e, n, i, a = r.get("name");
				this.newlineDisabled || "" !== a && "\n" !== a ? (t = u.getSeriesByName(a)[0], p.get(
					a) || (t ? (e = (i = t.getData()).getVisual("legendLineStyle") || {}, n = i
					.getVisual("legendIcon"), i = i.getVisual("style"), this._createItem(t,
						a, o, r, l, s, e, i, n, d, h).on("click", GS(qS, a, null, h, f)).on(
						"mouseover", GS(ZS, t.name, null, h, f)).on("mouseout", GS(KS, t
						.name, null, h, f)), p.set(a, !0)) : u.eachRawSeries(function(t) {
					var e, n, i;
					!p.get(a) && t.legendVisualProvider && (n = t.legendVisualProvider)
						.containName(a) && (i = n.indexOfName(a), e = n.getItemVisual(i,
								"style"), n = n.getItemVisual(i, "legendIcon"), (i = gi(
								e.fill)) && 0 === i[3] && (i[3] = .2, e = O(O({}, e), {
								fill: xi(i, "rgba")
							})), this._createItem(t, a, o, r, l, s, {}, e, n, d, h).on(
								"click", GS(qS, null, a, h, f)).on("mouseover", GS(ZS,
								null, a, h, f)).on("mouseout", GS(KS, null, a, h, f)), p
							.set(a, !0))
				}, this))) : ((e = new US).newline = !0, c.add(e))
			}, this), t && this._createSelector(t, l, h, e, n)
		}, YS.prototype._createSelector = function(t, i, r, e, n) {
			var o = this.getSelectorGroup();
			WS(t, function(t) {
				var e = t.type,
					n = new Ks({
						style: {
							x: 0,
							y: 0,
							align: "center",
							verticalAlign: "middle"
						},
						onclick: function() {
							r.dispatchAction({
								type: "all" === e ? "legendAllSelect" :
									"legendInverseSelect"
							})
						}
					});
				o.add(n), Ac(n, {
					normal: i.getModel("selectorLabel"),
					emphasis: i.getModel(["emphasis", "selectorLabel"])
				}, {
					defaultText: t.title
				}), Jl(n)
			})
		}, YS.prototype._createItem = function(t, e, n, i, r, o, a, s, l, u, h) {
			var c = t.visualDrawType,
				p = r.get("itemWidth"),
				d = r.get("itemHeight"),
				f = r.isSelected(e),
				g = i.get("symbolRotate"),
				y = i.get("symbolKeepAspect"),
				m = i.get("icon"),
				a = function(t, e, n, i, r, o, a) {
					function s(n, i) {
						"auto" === n.lineWidth && (n.lineWidth = 0 < i.lineWidth ? 2 : 0), WS(n, function(t,
							e) {
							"inherit" === n[e] && (n[e] = i[e])
						})
					}
					var l = e.getModel("itemStyle"),
						u = l.getItemStyle(),
						t = 0 === t.lastIndexOf("empty", 0) ? "fill" : "stroke",
						l = l.getShallow("decal"),
						l = (u.decal = l && "inherit" !== l ? Ym(l, a) : i.decal, "inherit" === u.fill && (u
								.fill = i[r]), "inherit" === u.stroke && (u.stroke = i[t]), "inherit" === u
							.opacity && (u.opacity = ("fill" === r ? i : n).opacity), s(u, i), e.getModel(
								"lineStyle")),
						a = l.getLineStyle();
					s(a, n), "auto" === u.fill && (u.fill = i.fill), "auto" === u.stroke && (u.stroke = i.fill),
						"auto" === a.stroke && (a.stroke = i.fill), o || (r = e.get("inactiveBorderWidth"), n =
							u[t], u.lineWidth = "auto" === r ? 0 < i.lineWidth && n ? 2 : 0 : u.lineWidth, u
							.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), a.stroke =
							l.get("inactiveColor"), a.lineWidth = l.get("inactiveWidth"));
					return {
						itemStyle: u,
						lineStyle: a
					}
				}(l = m || l || "roundRect", i, a, s, c, f, h),
				s = new US,
				c = i.getModel("textStyle"),
				m = (!S(t.getLegendIcon) || m && "inherit" !== m ? (h = "inherit" === m && t.getData()
					.getVisual("symbol") ? "inherit" === g ? t.getData().getVisual("symbolRotate") : g : 0,
					s.add((m = {
						itemWidth: p,
						itemHeight: d,
						icon: l,
						iconRotate: h,
						itemStyle: a.itemStyle,
						lineStyle: a.lineStyle,
						symbolKeepAspect: y
					}, h = m.icon || "roundRect", (v = ym(h, 0, 0, m.itemWidth, m.itemHeight, m
						.itemStyle.fill, m.symbolKeepAspect)).setStyle(m.itemStyle), v.rotation = (m
						.iconRotate || 0) * Math.PI / 180, v.setOrigin([m.itemWidth / 2, m
						.itemHeight / 2
					]), -1 < h.indexOf("empty") && (v.style.stroke = v.style.fill, v.style.fill =
						"#fff", v.style.lineWidth = 2), v))) : s.add(t.getLegendIcon({
					itemWidth: p,
					itemHeight: d,
					icon: l,
					iconRotate: g,
					itemStyle: a.itemStyle,
					lineStyle: a.lineStyle,
					symbolKeepAspect: y
				})), "left" === o ? p + 5 : -5),
				h = o,
				v = r.get("formatter"),
				t = e,
				l = (H(v) && v ? t = v.replace("{name}", null != e ? e : "") : S(v) && (t = v(e)), f ? c
					.getTextColor() : i.get("inactiveColor")),
				g = (s.add(new Ks({
					style: Lc(c, {
						text: t,
						x: m,
						y: d / 2,
						fill: l,
						align: h,
						verticalAlign: "middle"
					}, {
						inheritColor: l
					})
				})), new Xs({
					shape: s.getBoundingRect(),
					invisible: !0
				})),
				a = i.getModel("tooltip");
			return a.get("show") && Sc({
				el: g,
				componentModel: r,
				itemName: e,
				itemTooltipOption: a.option
			}), s.add(g), s.eachChild(function(t) {
				t.silent = !0
			}), g.silent = !u, this.getContentGroup().add(s), Jl(s), s.__legendDataIndex = n, s
		}, YS.prototype.layoutInner = function(t, e, n, i, r, o) {
			var a, s, l, u, h, c = this.getContentGroup(),
				p = this.getSelectorGroup(),
				n = ($p(t.get("orient"), c, t.get("itemGap"), n.width, n.height), c.getBoundingRect()),
				d = [-n.x, -n.y];
			return p.markRedraw(), c.markRedraw(), r ? ($p("horizontal", p, t.get("selectorItemGap", !0)), a = [
					-(r = p.getBoundingRect()).x, -r.y
				], s = t.get("selectorButtonGap", !0), l = 0 === (t = t.getOrient().index) ? "width" :
				"height", u = 0 === t ? "height" : "width", h = 0 === t ? "y" : "x", "end" === o ? a[t] +=
				n[l] + s : d[t] += r[l] + s, a[1 - t] += n[u] / 2 - r[u] / 2, p.x = a[0], p.y = a[1], c.x =
				d[0], c.y = d[1], (o = {
					x: 0,
					y: 0
				})[l] = n[l] + s + r[l], o[u] = Math.max(n[u], r[u]), o[h] = Math.min(0, r[h] + a[1 - t]), o
			) : (c.x = d[0], c.y = d[1], this.group.getBoundingRect())
		}, YS.prototype.remove = function() {
			this.getContentGroup().removeAll(), this._isFirstRender = !0
		}, YS.type = "legend.plain", YS);

	function YS() {
		var t = null !== HS && HS.apply(this, arguments) || this;
		return t.type = YS.type, t.newlineDisabled = !1, t
	}

	function qS(t, e, n, i) {
		KS(t, e, n, i), n.dispatchAction({
			type: "legendToggleSelect",
			name: null != t ? t : e
		}), ZS(t, e, n, i)
	}

	function jS(t) {
		for (var e, n = t.getZr().storage.getDisplayList(), i = 0, r = n.length; i < r && !(e = n[i].states
				.emphasis);) i++;
		return e && e.hoverLayer
	}

	function ZS(t, e, n, i) {
		jS(n) || n.dispatchAction({
			type: "highlight",
			seriesName: t,
			name: e,
			excludeSeriesId: i
		})
	}

	function KS(t, e, n, i) {
		jS(n) || n.dispatchAction({
			type: "downplay",
			seriesName: t,
			name: e,
			excludeSeriesId: i
		})
	}

	function $S(t) {
		var n = t.findComponents({
			mainType: "legend"
		});
		n && n.length && t.filterSeries(function(t) {
			for (var e = 0; e < n.length; e++)
				if (!n[e].isSelected(t.name)) return !1;
			return !0
		})
	}

	function QS(t, e, n) {
		var i, r = {},
			o = "toggleSelected" === t;
		return n.eachComponent("legend", function(n) {
			o && null != i ? n[i ? "select" : "unSelect"](e.name) : "allSelect" === t || "inverseSelect" ===
				t ? n[t]() : (n[t](e.name), i = n.isSelected(e.name)), E(n.getData(), function(t) {
					var e, t = t.get("name");
					"\n" !== t && "" !== t && (e = n.isSelected(t), r.hasOwnProperty(t) ? r[t] = r[t] &&
						e : r[t] = e)
				})
		}), "allSelect" === t || "inverseSelect" === t ? {
			selected: r
		} : {
			name: e.name,
			selected: r
		}
	}

	function JS(t) {
		t.registerComponentModel(FS), t.registerComponentView(XS), t.registerProcessor(t.PRIORITY.PROCESSOR
				.SERIES_FILTER, $S), t.registerSubTypeDefaulter("legend", function() {
				return "plain"
			}), (t = t).registerAction("legendToggleSelect", "legendselectchanged", dt(QS, "toggleSelected")), t
			.registerAction("legendAllSelect", "legendselectall", dt(QS, "allSelect")), t.registerAction(
				"legendInverseSelect", "legendinverseselect", dt(QS, "inverseSelect")), t.registerAction(
				"legendSelect", "legendselected", dt(QS, "select")), t.registerAction("legendUnSelect",
				"legendunselected", dt(QS, "unSelect"))
	}
	u(nM, tM = FS), nM.prototype.setScrollDataIndex = function(t) {
		this.option.scrollDataIndex = t
	}, nM.prototype.init = function(t, e, n) {
		var i = ed(t);
		tM.prototype.init.call(this, t, e, n), iM(this, t, i)
	}, nM.prototype.mergeOption = function(t, e) {
		tM.prototype.mergeOption.call(this, t, e), iM(this, this.option, t)
	}, nM.type = "legend.scroll", nM.defaultOption = np(FS.defaultOption, {
		scrollDataIndex: 0,
		pageButtonItemGap: 5,
		pageButtonGap: null,
		pageButtonPosition: "end",
		pageFormatter: "{current}/{total}",
		pageIcons: {
			horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
			vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
		},
		pageIconColor: "#2f4554",
		pageIconInactiveColor: "#aaa",
		pageIconSize: 15,
		pageTextStyle: {
			color: "#333"
		},
		animationDurationUpdate: 800
	});
	var tM, eM = nM;

	function nM() {
		var t = null !== tM && tM.apply(this, arguments) || this;
		return t.type = nM.type, t
	}

	function iM(t, e, n) {
		var i = [1, 1];
		i[t.getOrient().index] = 0, td(e, n, {
			type: "box",
			ignoreSize: !!i
		})
	}
	var rM, oM = no,
		aM = ["width", "height"],
		sM = ["x", "y"],
		lM = (u(uM, rM = XS), uM.prototype.init = function() {
			rM.prototype.init.call(this), this.group.add(this._containerGroup = new oM), this._containerGroup
				.add(this.getContentGroup()), this.group.add(this._controllerGroup = new oM)
		}, uM.prototype.resetInner = function() {
			rM.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup
				.removeClipPath(), this._containerGroup.__rectSize = null
		}, uM.prototype.renderInner = function(t, i, e, r, n, o, a) {
			var s = this,
				l = (rM.prototype.renderInner.call(this, t, i, e, r, n, o, a), this._controllerGroup),
				t = i.get("pageIconSize", !0),
				u = V(t) ? t : [t, t],
				e = (h("pagePrev", 0), i.getModel("pageTextStyle"));

			function h(t, e) {
				var n = t + "DataIndex",
					e = wc(i.get("pageIcons", !0)[i.getOrient().name][e], {
						onclick: pt(s._pageGo, s, n, i, r)
					}, {
						x: -u[0] / 2,
						y: -u[1] / 2,
						width: u[0],
						height: u[1]
					});
				e.name = t, l.add(e)
			}
			l.add(new Ks({
				name: "pageText",
				style: {
					text: "xx/xx",
					fill: e.getTextColor(),
					font: e.getFont(),
					verticalAlign: "middle",
					align: "center"
				},
				silent: !0
			})), h("pageNext", 1)
		}, uM.prototype.layoutInner = function(t, e, n, i, r, o) {
			var a = this.getSelectorGroup(),
				s = t.getOrient().index,
				l = aM[s],
				u = sM[s],
				h = aM[1 - s],
				c = sM[1 - s],
				p = (r && $p("horizontal", a, t.get("selectorItemGap", !0)), t.get("selectorButtonGap", !0)),
				d = a.getBoundingRect(),
				f = [-d.x, -d.y],
				g = _(n),
				n = (r && (g[l] = n[l] - d[l] - p), this._layoutContentAndController(t, i, g, s, l, h, c, u));
			return r && ("end" === o ? f[s] += n[l] + p : (t = d[l] + p, f[s] -= t, n[u] -= t), n[l] += d[l] +
				p, f[1 - s] += n[c] + n[h] / 2 - d[h] / 2, n[h] = Math.max(n[h], d[h]), n[c] = Math.min(n[
					c], d[c] + f[1 - s]), a.x = f[0], a.y = f[1], a.markRedraw()), n
		}, uM.prototype._layoutContentAndController = function(t, e, n, i, r, o, a, s) {
			var l = this.getContentGroup(),
				u = this._containerGroup,
				h = this._controllerGroup,
				c = ($p(t.get("orient"), l, t.get("itemGap"), i ? n.width : null, i ? null : n.height), $p(
					"horizontal", h, t.get("pageButtonItemGap", !0)), l.getBoundingRect()),
				p = h.getBoundingRect(),
				d = this._showController = c[r] > n[r],
				f = [-c.x, -c.y],
				e = (e || (f[i] = l[s]), [0, 0]),
				s = [-p.x, -p.y],
				g = N(t.get("pageButtonGap", !0), t.get("itemGap", !0)),
				f = (d && ("end" === t.get("pageButtonPosition", !0) ? s[i] += n[r] - p[r] : e[i] += p[r] + g),
					s[1 - i] += c[o] / 2 - p[o] / 2, l.setPosition(f), u.setPosition(e), h.setPosition(s), {
						x: 0,
						y: 0
					}),
				c = (f[r] = (d ? n : c)[r], f[o] = Math.max(c[o], p[o]), f[a] = Math.min(0, p[a] + s[1 - i]), u
					.__rectSize = n[r], d ? ((e = {
						x: 0,
						y: 0
					})[r] = Math.max(n[r] - p[r] - g, 0), e[o] = f[o], u.setClipPath(new Xs({
						shape: e
					})), u.__rectSize = e[r]) : h.eachChild(function(t) {
						t.attr({
							invisible: !0,
							silent: !0
						})
					}), this._getPageInfo(t));
			return null != c.pageIndex && qh(l, {
				x: c.contentPosition[0],
				y: c.contentPosition[1]
			}, d ? t : null), this._updatePageInfoView(t, c), f
		}, uM.prototype._pageGo = function(t, e, n) {
			t = this._getPageInfo(e)[t];
			null != t && n.dispatchAction({
				type: "legendScroll",
				scrollDataIndex: t,
				legendId: e.id
			})
		}, uM.prototype._updatePageInfoView = function(n, i) {
			var r = this._controllerGroup,
				t = (E(["pagePrev", "pageNext"], function(t) {
					var e = null != i[t + "DataIndex"],
						t = r.childOfName(t);
					t && (t.setStyle("fill", e ? n.get("pageIconColor", !0) : n.get(
						"pageIconInactiveColor", !0)), t.cursor = e ? "pointer" : "default")
				}), r.childOfName("pageText")),
				e = n.get("pageFormatter"),
				o = i.pageIndex,
				o = null != o ? o + 1 : 0,
				a = i.pageCount;
			t && e && t.setStyle("text", H(e) ? e.replace("{current}", null == o ? "" : o + "").replace(
				"{total}", null == a ? "" : a + "") : e({
				current: o,
				total: a
			}))
		}, uM.prototype._getPageInfo = function(t) {
			var e = t.get("scrollDataIndex", !0),
				n = this.getContentGroup(),
				i = this._containerGroup.__rectSize,
				t = t.getOrient().index,
				r = aM[t],
				o = sM[t],
				e = this._findTargetItemIndex(e),
				a = n.children(),
				s = a[e],
				l = a.length,
				u = l ? 1 : 0,
				h = {
					contentPosition: [n.x, n.y],
					pageCount: u,
					pageIndex: u - 1,
					pagePrevDataIndex: null,
					pageNextDataIndex: null
				};
			if (s) {
				n = g(s);
				h.contentPosition[t] = -n.s;
				for (var c = e + 1, p = n, d = n, f = null; c <= l; ++c)(!(f = g(a[c])) && d.e > p.s + i || f &&
					!y(f, p.s)) && (p = d.i > p.i ? d : f) && (null == h.pageNextDataIndex && (h
					.pageNextDataIndex = p.i), ++h.pageCount), d = f;
				for (c = e - 1, d = p = n, f = null; - 1 <= c; --c)(f = g(a[c])) && y(d, f.s) || !(p.i < d.i) ||
					(d = p, null == h.pagePrevDataIndex && (h.pagePrevDataIndex = p.i), ++h.pageCount, ++h
						.pageIndex), p = f
			}
			return h;

			function g(t) {
				var e, n;
				if (t) return {
					s: n = (e = t.getBoundingRect())[o] + t[o],
					e: n + e[r],
					i: t.__legendDataIndex
				}
			}

			function y(t, e) {
				return t.e >= e && t.s <= e + i
			}
		}, uM.prototype._findTargetItemIndex = function(n) {
			return this._showController ? (this.getContentGroup().eachChild(function(t, e) {
				t = t.__legendDataIndex;
				null == r && null != t && (r = e), t === n && (i = e)
			}), null != i ? i : r) : 0;
			var i, r
		}, uM.type = "legend.scroll", uM);

	function uM() {
		var t = null !== rM && rM.apply(this, arguments) || this;
		return t.type = uM.type, t.newlineDisabled = !0, t._currentIndex = 0, t
	}
	n1(function(t) {
		n1(JS), t.registerComponentModel(eM), t.registerComponentView(lM), t.registerAction("legendScroll",
			"legendscroll",
			function(t, e) {
				var n = t.scrollDataIndex;
				null != n && e.eachComponent({
					mainType: "legend",
					subType: "scroll",
					query: t
				}, function(t) {
					t.setScrollDataIndex(n)
				})
			})
	});
	var hM = Yo(),
		cM = _,
		pM = pt;

	function dM() {
		this._dragging = !1, this.animationThreshold = 15
	}

	function fM(t, e, n, i) {
		! function n(i, t) {
			{
				var r;
				if (L(i) && L(t)) return r = !0, E(t, function(t, e) {
					r = r && n(i[e], t)
				}), !!r
			}
			return i === t
		}(hM(n).lastProp, i) && (hM(n).lastProp = i, e ? qh(n, i, t) : (n.stopAnimation(), n.attr(i)))
	}

	function gM(t, e) {
		t[e.get(["label", "show"]) ? "show" : "hide"]()
	}

	function yM(t) {
		return {
			x: t.x || 0,
			y: t.y || 0,
			rotation: t.rotation || 0
		}
	}

	function mM(t, e, n) {
		var i = e.get("z"),
			r = e.get("zlevel");
		t && t.traverse(function(t) {
			"group" !== t.type && (null != i && (t.z = i), null != r && (t.zlevel = r), t.silent = n)
		})
	}

	function vM(t, e, n, i, r) {
		var o = _M(n.get("value"), e.axis, e.ecModel, n.get("seriesDataIndices"), {
				precision: n.get(["label", "precision"]),
				formatter: n.get(["label", "formatter"])
			}),
			n = n.getModel("label"),
			a = Fp(n.get("padding") || 0),
			s = n.getFont(),
			l = Br(o, s),
			u = r.position,
			h = l.width + a[1] + a[3],
			l = l.height + a[0] + a[2],
			c = r.align,
			c = ("right" === c && (u[0] -= h), "center" === c && (u[0] -= h / 2), r.verticalAlign),
			i = ("bottom" === c && (u[1] -= l), "middle" === c && (u[1] -= l / 2), r = u, c = h, h = l, i = (l = i)
				.getWidth(), l = l.getHeight(), r[0] = Math.min(r[0] + c, i) - c, r[1] = Math.min(r[1] + h, l) - h,
				r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0), n.get("backgroundColor"));
		i && "auto" !== i || (i = e.get(["axisLine", "lineStyle", "color"])), t.label = {
			x: u[0],
			y: u[1],
			style: Lc(n, {
				text: o,
				font: s,
				fill: n.getTextColor(),
				padding: a,
				backgroundColor: i
			}),
			z2: 10
		}
	}

	function _M(t, e, n, i, r) {
		t = e.scale.parse(t);
		var o, a = e.scale.getLabel({
				value: t
			}, {
				precision: r.precision
			}),
			r = r.formatter;
		return r && (o = {
			value: j_(e, {
				value: t
			}),
			axisDimension: e.dim,
			axisIndex: e.index,
			seriesData: []
		}, E(i, function(t) {
			var e = n.getSeriesByIndex(t.seriesIndex),
				t = t.dataIndexInside,
				e = e && e.getDataParams(t);
			e && o.seriesData.push(e)
		}), H(r) ? a = r.replace("{value}", a) : S(r) && (a = r(o))), a
	}

	function xM(t, e, n) {
		var i = Oe();
		return Be(i, i, n.rotation), ze(i, i, n.position), yc([t.dataToCoord(e), (n.labelOffset || 0) + (n
			.labelDirection || 1) * (n.labelMargin || 0)], i)
	}
	dM.prototype.render = function(t, e, n, i) {
		var r, o, a = e.get("value"),
			s = e.get("status");
		this._axisModel = t, this._axisPointerModel = e, this._api = n, !i && this._lastValue === a && this
			._lastStatus === s || (this._lastValue = a, this._lastStatus = s, i = this._group, r = this._handle,
				s && "hide" !== s ? (i && i.show(), r && r.show(), this.makeElOption(s = {}, a, t, e, n), (o = s
						.graphicKey) !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = o, o =
					this._moveAnimation = this.determineAnimation(t, e), i ? (o = dt(fM, e, o), this
						.updatePointerEl(i, s, o), this.updateLabelEl(i, s, o, e)) : (i = this._group = new no,
						this.createPointerEl(i, s, t, e), this.createLabelEl(i, s, t, e), n.getZr().add(i)), mM(
						i, e, !0), this._renderHandle(a)) : (i && i.hide(), r && r.hide()))
	}, dM.prototype.remove = function(t) {
		this.clear(t)
	}, dM.prototype.dispose = function(t) {
		this.clear(t)
	}, dM.prototype.determineAnimation = function(t, e) {
		var n, i = e.get("animation"),
			r = t.axis,
			o = "category" === r.type,
			e = e.get("snap");
		return !(!e && !o) && ("auto" === i || null == i ? (n = this.animationThreshold, o && r.getBandWidth() >
				n || !!e && (o = uS(t).seriesDataCount, e = r.getExtent(), Math.abs(e[0] - e[1]) / o > n)) :
			!0 === i)
	}, dM.prototype.makeElOption = function(t, e, n, i, r) {}, dM.prototype.createPointerEl = function(t, e, n,
		i) {
		var r = e.pointer;
		r && (r = hM(t).pointerEl = new Cc[r.type](cM(e.pointer)), t.add(r))
	}, dM.prototype.createLabelEl = function(t, e, n, i) {
		e.label && (e = hM(t).labelEl = new Ks(cM(e.label)), t.add(e), gM(e, i))
	}, dM.prototype.updatePointerEl = function(t, e, n) {
		t = hM(t).pointerEl;
		t && e.pointer && (t.setStyle(e.pointer.style), n(t, {
			shape: e.pointer.shape
		}))
	}, dM.prototype.updateLabelEl = function(t, e, n, i) {
		t = hM(t).labelEl;
		t && (t.setStyle(e.label.style), n(t, {
			x: e.label.x,
			y: e.label.y
		}), gM(t, i))
	}, dM.prototype._renderHandle = function(t) {
		var e, n, i, r, o, a;
		!this._dragging && this.updateHandleTransform && (n = this._axisPointerModel, i = this._api.getZr(), r =
			this._handle, o = n.getModel("handle"), a = n.get("status"), o.get("show") && a && "hide" !==
			a ? (this._handle || (e = !0, r = this._handle = wc(o.get("icon"), {
					cursor: "move",
					draggable: !0,
					onmousemove: function(t) {
						ke(t.event)
					},
					onmousedown: pM(this._onHandleDragMove, this, 0, 0),
					drift: pM(this._onHandleDragMove, this),
					ondragend: pM(this._onHandleDragEnd, this)
				}), i.add(r)), mM(r, n, !1), r.setStyle(o.getItemStyle(null, ["color", "borderColor",
					"borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX",
					"shadowOffsetY"
				])), V(a = o.get("size")) || (a = [a, a]), r.scaleX = a[0] / 2, r.scaleY = a[1] / 2, Ty(
					this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this
				._moveHandleToValue(t, e)) : (r && i.remove(r), this._handle = null))
	}, dM.prototype._moveHandleToValue = function(t, e) {
		fM(this._axisPointerModel, !e && this._moveAnimation, this._handle, yM(this.getHandleTransform(t, this
			._axisModel, this._axisPointerModel)))
	}, dM.prototype._onHandleDragMove = function(t, e) {
		var n = this._handle;
		n && (this._dragging = !0, t = this.updateHandleTransform(yM(n), [t, e], this._axisModel, this
				._axisPointerModel), this._payloadInfo = t, n.stopAnimation(), n.attr(yM(t)), hM(n)
			.lastProp = null, this._doDispatchAxisPointer())
	}, dM.prototype._doDispatchAxisPointer = function() {
		var t, e;
		this._handle && (t = this._payloadInfo, e = this._axisModel, this._api.dispatchAction({
			type: "updateAxisPointer",
			x: t.cursorPoint[0],
			y: t.cursorPoint[1],
			tooltipOption: t.tooltipOption,
			axesInfo: [{
				axisDim: e.axis.dim,
				axisIndex: e.componentIndex
			}]
		}))
	}, dM.prototype._onHandleDragEnd = function() {
		var t;
		this._dragging = !1, this._handle && (t = this._axisPointerModel.get("value"), this._moveHandleToValue(
			t), this._api.dispatchAction({
			type: "hideTip"
		}))
	}, dM.prototype.clear = function(t) {
		this._lastValue = null, this._lastStatus = null;
		var t = t.getZr(),
			e = this._group,
			n = this._handle;
		t && e && (this._lastGraphicKey = null, e && t.remove(e), n && t.remove(n), this._group = null, this
			._handle = null, this._payloadInfo = null), Cy(this, "_doDispatchAxisPointer")
	}, dM.prototype.doClear = function() {}, dM.prototype.buildLabel = function(t, e, n) {
		return {
			x: t[n = n || 0],
			y: t[1 - n],
			width: e[n],
			height: e[1 - n]
		}
	};
	u(SM, wM = dM), SM.prototype.makeElOption = function(t, e, n, i, r) {
		var o, a, s = n.axis,
			l = s.grid,
			u = i.get("type"),
			h = MM(l, s).getOtherAxis(s).getGlobalExtent(),
			c = s.toGlobalCoord(s.dataToCoord(e, !0)),
			p = (u && "none" !== u && (o = (a = i).get("type"), a = a.getModel(o + "Style"), "line" === o ? (p =
				a.getLineStyle()).fill = null : "shadow" === o && ((p = a.getAreaStyle()).stroke =
				null), o = p, (a = TM[u](s, c, h)).style = o, t.graphicKey = a.type, t.pointer = a), Ub(l
				.model, n));
		u = e, s = t, c = p, h = n, o = i, a = r, l = tS.innerTextLayout(c.rotation, 0, c.labelDirection), c
			.labelMargin = o.get(["label", "margin"]), vM(s, h, o, a, {
				position: xM(h.axis, u, c),
				align: l.textAlign,
				verticalAlign: l.textVerticalAlign
			})
	}, SM.prototype.getHandleTransform = function(t, e, n) {
		var i = Ub(e.axis.grid.model, e, {
				labelInside: !1
			}),
			n = (i.labelMargin = n.get(["handle", "margin"]), xM(e.axis, t, i));
		return {
			x: n[0],
			y: n[1],
			rotation: i.rotation + (i.labelDirection < 0 ? Math.PI : 0)
		}
	}, SM.prototype.updateHandleTransform = function(t, e, n, i) {
		var n = n.axis,
			r = n.grid,
			o = n.getGlobalExtent(!0),
			r = MM(r, n).getOtherAxis(n).getGlobalExtent(),
			n = "x" === n.dim ? 0 : 1,
			a = [t.x, t.y],
			e = (a[n] += e[n], a[n] = Math.min(o[1], a[n]), a[n] = Math.max(o[0], a[n]), (r[1] + r[0]) / 2),
			o = [e, e];
		return o[n] = a[n], {
			x: a[0],
			y: a[1],
			rotation: t.rotation,
			cursorPoint: o,
			tooltipOption: [{
				verticalAlign: "middle"
			}, {
				align: "center"
			}][n]
		}
	};
	var wM, bM = SM;

	function SM() {
		return null !== wM && wM.apply(this, arguments) || this
	}

	function MM(t, e) {
		var n = {};
		return n[e.dim + "AxisIndex"] = e.index, t.getCartesian(n)
	}
	var TM = {
		line: function(t, e, n) {
			return {
				type: "Line",
				subPixelOptimize: !0,
				shape: (i = [e, n[0]], e = [e, n[1]], n = CM(t), {
					x1: i[n = n || 0],
					y1: i[1 - n],
					x2: e[n],
					y2: e[1 - n]
				})
			};
			var i
		},
		shadow: function(t, e, n) {
			var i = Math.max(1, t.getBandWidth()),
				r = n[1] - n[0];
			return {
				type: "Rect",
				shape: (e = [e - i / 2, n[0]], n = [i, r], i = CM(t), {
					x: e[i = i || 0],
					y: e[1 - i],
					width: n[i],
					height: n[1 - i]
				})
			}
		}
	};

	function CM(t) {
		return "x" === t.dim ? 0 : 1
	}
	u(DM, IM = g), DM.type = "axisPointer", DM.defaultOption = {
		show: "auto",
		z: 50,
		type: "line",
		snap: !1,
		triggerTooltip: !0,
		triggerEmphasis: !0,
		value: null,
		status: null,
		link: [],
		animation: null,
		animationDurationUpdate: 200,
		lineStyle: {
			color: "#B9BEC9",
			width: 1,
			type: "dashed"
		},
		shadowStyle: {
			color: "rgba(210,219,238,0.2)"
		},
		label: {
			show: !0,
			formatter: null,
			precision: "auto",
			margin: 3,
			color: "#fff",
			padding: [5, 7, 5, 7],
			backgroundColor: "auto",
			borderColor: null,
			borderWidth: 0,
			borderRadius: 3
		},
		handle: {
			show: !1,
			icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
			size: 45,
			margin: 50,
			color: "#333",
			shadowBlur: 3,
			shadowColor: "#aaa",
			shadowOffsetX: 0,
			shadowOffsetY: 2,
			throttle: 40
		}
	};
	var IM, kM = DM;

	function DM() {
		var t = null !== IM && IM.apply(this, arguments) || this;
		return t.type = DM.type, t
	}
	var AM = Yo(),
		PM = E;

	function LM(t, e, n) {
		var i, c, p;

		function r(t, h) {
			c.on(t, function(e) {
				n = p;
				var n, i, t, r, o, a, s, l = {
					dispatchAction: u,
					pendings: i = {
						showTip: [],
						hideTip: []
					}
				};

				function u(t) {
					var e = i[t.type];
					e ? e.push(t) : (t.dispatchAction = u, n.dispatchAction(t))
				}
				PM(AM(c).records, function(t) {
					t && h(t, e, l.dispatchAction)
				}), r = p, a = (t = l.pendings).showTip.length, s = t.hideTip.length, a ? o = t.showTip[
					a - 1] : s && (o = t.hideTip[s - 1]), o && (o.dispatchAction = null, r
					.dispatchAction(o))
			})
		}
		b.node || (i = e.getZr(), AM(i).records || (AM(i).records = {}), p = e, AM(c = i).initialized || (AM(c)
			.initialized = !0, r("click", dt(RM, "click")), r("mousemove", dt(RM, "mousemove")), r(
				"globalout", OM)), (AM(i).records[t] || (AM(i).records[t] = {})).handler = n)
	}

	function OM(t, e, n) {
		t.handler("leave", null, n)
	}

	function RM(t, e, n, i) {
		e.handler(t, n, i)
	}

	function NM(t, e) {
		b.node || (e = e.getZr(), (AM(e).records || {})[t] && (AM(e).records[t] = null))
	}
	u(BM, EM = uy), BM.prototype.render = function(t, e, n) {
		var e = e.getComponent("tooltip"),
			i = t.get("triggerOn") || e && e.get("triggerOn") || "mousemove|click";
		LM("axisPointer", n, function(t, e, n) {
			"none" !== i && ("leave" === t || 0 <= i.indexOf(t)) && n({
				type: "updateAxisPointer",
				currTrigger: t,
				x: e && e.offsetX,
				y: e && e.offsetY
			})
		})
	}, BM.prototype.remove = function(t, e) {
		NM("axisPointer", e)
	}, BM.prototype.dispose = function(t, e) {
		NM("axisPointer", e)
	}, BM.type = "axisPointer";
	var EM, zM = BM;

	function BM() {
		var t = null !== EM && EM.apply(this, arguments) || this;
		return t.type = BM.type, t
	}

	function FM(t, e) {
		var n, i, r, o, a = [],
			s = t.seriesIndex;
		return null == s || !(e = e.getSeriesByIndex(s)) || null == (s = Xo(n = e.getData(), t)) || s < 0 || V(s) ?
		{
			point: []
		} : (i = n.getItemGraphicEl(s), r = e.coordinateSystem, e.getTooltipPosition ? a = e.getTooltipPosition(
			s) || [] : r && r.dataToPoint ? a = t.isStacked ? (e = r.getBaseAxis(), t = r.getOtherAxis(e)
			.dim, e = e.dim, t = "x" === t || "radius" === t ? 1 : 0, e = n.mapDimension(e), (o = [])[t] = n
			.get(e, s), o[1 - t] = n.get(n.getCalculationInfo("stackResultDimension"), s), r.dataToPoint(
				o) || []) : r.dataToPoint(n.getValues(F(r.dimensions, function(t) {
			return n.mapDimension(t)
		}), s)) || [] : i && ((e = i.getBoundingRect().clone()).applyTransform(i.transform), a = [e.x + e
			.width / 2, e.y + e.height / 2
		]), {
			point: a,
			el: i
		})
	}
	var VM = Yo();

	function HM(t, e, n) {
		var o, a, i, s, l, r, u, h, c, p, d, f, g, y, m = t.currTrigger,
			v = [t.x, t.y],
			_ = t,
			x = t.dispatchAction || pt(n.dispatchAction, n),
			w = e.getComponent("axisPointer").coordSysAxesInfo;
		if (w) return YM(v) && (v = FM({
			seriesIndex: _.seriesIndex,
			dataIndex: _.dataIndex
		}, e).point), o = YM(v), a = _.axesInfo, i = w.axesInfo, s = "leave" === m || YM(v), l = {}, e = {
			list: [],
			map: {}
		}, u = {
			showPointer: dt(WM, r = {}),
			showTooltip: dt(UM, e)
		}, E(w.coordSysMap, function(t, e) {
			var r = o || t.containPoint(v);
			E(w.coordSysAxesInfo[e], function(t, e) {
				var n = t.axis,
					i = function(t, e) {
						for (var n = 0; n < (t || []).length; n++) {
							var i = t[n];
							if (e.axis.dim === i.axisDim && e.axis.model.componentIndex === i
								.axisIndex) return i
						}
					}(a, t);
				s || !r || a && !i || null != (i = null != (i = i && i.value) || o ? i : n
					.pointToData(v)) && GM(t, i, u, !1, l)
			})
		}), h = {}, E(i, function(n, t) {
			var i = n.linkGroup;
			i && !r[t] && E(i.axesInfo, function(t, e) {
				var e = r[e];
				t !== n && e && (e = e.value, i.mapper && (e = n.axis.scale.parse(i.mapper(e,
					XM(t), XM(n)))), h[n.key] = e)
			})
		}), E(h, function(t, e) {
			GM(i[e], t, u, !0, l)
		}), g = r, _ = i, y = l.axesInfo = [], E(_, function(t, e) {
			var n = t.axisPointerModel.option,
				e = g[e];
			e ? (t.useHandle || (n.status = "show"), n.value = e.value, n.seriesDataIndices = (e
					.payloadBatch || []).slice()) : t.useHandle || (n.status = "hide"), "show" === n
				.status && y.push({
					axisDim: t.axis.dim,
					axisIndex: t.axis.model.componentIndex,
					value: n.value
				})
		}), m = e, _ = t, e = x, !YM(t = v) && m.list.length ? (x = ((m.list[0].dataByAxis[0] || {})
			.seriesDataIndices || [])[0] || {}, e({
			type: "showTip",
			escapeConnect: !0,
			x: t[0],
			y: t[1],
			tooltipOption: _.tooltipOption,
			position: _.position,
			dataIndexInside: x.dataIndexInside,
			dataIndex: x.dataIndex,
			seriesIndex: x.seriesIndex,
			dataByCoordSys: m.list
		})) : e({
			type: "hideTip"
		}), t = i, x = (_ = n).getZr(), m = "axisPointerLastHighlights", c = VM(x)[m] || {}, p = VM(x)[
			m] = {}, E(t, function(t, e) {
			var n = t.axisPointerModel.option;
			"show" === n.status && t.triggerEmphasis && E(n.seriesDataIndices, function(t) {
				var e = t.seriesIndex + " | " + t.dataIndex;
				p[e] = t
			})
		}), d = [], f = [], E(c, function(t, e) {
			p[e] || f.push(t)
		}), E(p, function(t, e) {
			c[e] || d.push(t)
		}), f.length && _.dispatchAction({
			type: "downplay",
			escapeConnect: !0,
			notBlur: !0,
			batch: f
		}), d.length && _.dispatchAction({
			type: "highlight",
			escapeConnect: !0,
			notBlur: !0,
			batch: d
		}), l
	}

	function GM(t, e, n, i, r) {
		var o, a, s, l, u, h, c, p, d, f, g = t.axis;
		!g.scale.isBlank() && g.containData(e) && (t.involveSeries ? (l = e, u = t.axis, h = u.dim, c = l, p = [],
				d = Number.MAX_VALUE, f = -1, E(t.seriesModels, function(e, t) {
					var n, i = e.getData().mapDimensionsAll(h);
					if (e.getAxisTooltipData) var r = e.getAxisTooltipData(i, l, u),
						o = r.dataIndices,
						r = r.nestestValue;
					else {
						if (!(o = e.getData().indicesOfNearest(i[0], l, "category" === u.type ? .5 : null))
							.length) return;
						r = e.getData().get(i[0], o[0])
					}
					null != r && isFinite(r) && (i = l - r, (n = Math.abs(i)) <= d) && ((n < d || 0 <= i &&
						f < 0) && (d = n, f = i, c = r, p.length = 0), E(o, function(t) {
						p.push({
							seriesIndex: e.seriesIndex,
							dataIndexInside: t,
							dataIndex: e.getData().getRawIndex(t)
						})
					}))
				}), s = (o = {
					payloadBatch: p,
					snapToValue: c
				}).snapToValue, (a = o.payloadBatch)[0] && null == r.seriesIndex && O(r, a[0]), !i && t.snap &&
				g.containData(s) && null != s && (e = s), n.showPointer(t, e, a), n.showTooltip(t, o, s)) : n
			.showPointer(t, e))
	}

	function WM(t, e, n, i) {
		t[e.key] = {
			value: n,
			payloadBatch: i
		}
	}

	function UM(t, e, n, i) {
		var r, o, n = n.payloadBatch,
			a = e.axis,
			s = a.model,
			l = e.axisPointerModel;
		e.triggerTooltip && n.length && (r = cS(e = e.coordSys.model), (o = t.map[r]) || (o = t.map[r] = {
			coordSysId: e.id,
			coordSysIndex: e.componentIndex,
			coordSysType: e.type,
			coordSysMainType: e.mainType,
			dataByAxis: []
		}, t.list.push(o)), o.dataByAxis.push({
			axisDim: a.dim,
			axisIndex: s.componentIndex,
			axisType: s.type,
			axisId: s.id,
			value: i,
			valueLabelOpt: {
				precision: l.get(["label", "precision"]),
				formatter: l.get(["label", "formatter"])
			},
			seriesDataIndices: n.slice()
		}))
	}

	function XM(t) {
		var e = t.axis.model,
			n = {},
			t = n.axisDim = t.axis.dim;
		return n.axisIndex = n[t + "AxisIndex"] = e.componentIndex, n.axisName = n[t + "AxisName"] = e.name, n
			.axisId = n[t + "AxisId"] = e.id, n
	}

	function YM(t) {
		return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1])
	}

	function qM(t) {
		fS.registerAxisPointerClass("CartesianAxisPointer", bM), t.registerComponentModel(kM), t
			.registerComponentView(zM), t.registerPreprocessor(function(t) {
				var e;
				t && (t.axisPointer && 0 !== t.axisPointer.length || (t.axisPointer = {}), e = t.axisPointer
					.link) && !V(e) && (t.axisPointer.link = [e])
			}), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
				t.getComponent("axisPointer").coordSysAxesInfo = sS(t, e)
			}), t.registerAction({
				type: "updateAxisPointer",
				event: "updateAxisPointer",
				update: ":updateAxisPointer"
			}, HM)
	}
	u(KM, jM = g), KM.type = "tooltip", KM.dependencies = ["axisPointer"], KM.defaultOption = {
		z: 60,
		show: !0,
		showContent: !0,
		trigger: "item",
		triggerOn: "mousemove|click",
		alwaysShowContent: !1,
		displayMode: "single",
		renderMode: "auto",
		confine: null,
		showDelay: 0,
		hideDelay: 100,
		transitionDuration: .4,
		enterable: !1,
		backgroundColor: "#fff",
		shadowBlur: 10,
		shadowColor: "rgba(0, 0, 0, .2)",
		shadowOffsetX: 1,
		shadowOffsetY: 2,
		borderRadius: 4,
		borderWidth: 1,
		padding: null,
		extraCssText: "",
		axisPointer: {
			type: "line",
			axis: "auto",
			animation: "auto",
			animationDurationUpdate: 200,
			animationEasingUpdate: "exponentialOut",
			crossStyle: {
				color: "#999",
				width: 1,
				type: "dashed",
				textStyle: {}
			}
		},
		textStyle: {
			color: "#666",
			fontSize: 14
		}
	};
	var jM, ZM = KM;

	function KM() {
		var t = null !== jM && jM.apply(this, arguments) || this;
		return t.type = KM.type, t
	}

	function $M(t) {
		var e = t.get("confine");
		return null != e ? e : "richText" === t.get("renderMode")
	}

	function QM(t) {
		if (b.domSupported)
			for (var e = document.documentElement.style, n = 0, i = t.length; n < i; n++)
				if (t[n] in e) return t[n]
	}
	var JM = QM(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);

	function tT(t, e) {
		if (!t) return e;
		e = Bp(e, !0);
		var n = t.indexOf(e);
		return (t = -1 === n ? e : "-" + t.slice(0, n) + "-" + e).toLowerCase()
	}
	var eT = tT(QM(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]),
			"transition"),
		nT = tT(JM, "transform"),
		iT = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (b
			.transform3dSupported ? "will-change:transform;" : "");

	function rT(t, e, n) {
		var i, t = t.toFixed(0) + "px",
			e = e.toFixed(0) + "px";
		return b.transformSupported ? (i = "translate" + ((i = b.transform3dSupported) ? "3d" : "") + "(" + t +
			"," + e + (i ? ",0" : "") + ")", n ? "top:0;left:0;" + nT + ":" + i + ";" : [
				["top", 0],
				["left", 0],
				[JM, i]
			]) : n ? "top:" + e + ";left:" + t + ";" : [
			["top", e],
			["left", t]
		]
	}

	function oT(i, t, e) {
		var n, r, o = [],
			a = i.get("transitionDuration"),
			s = i.get("backgroundColor"),
			l = i.get("shadowBlur"),
			u = i.get("shadowColor"),
			h = i.get("shadowOffsetX"),
			c = i.get("shadowOffsetY"),
			p = i.getModel("textStyle"),
			d = jg(i, "html");
		return o.push("box-shadow:" + (h + "px " + c + "px " + l + "px " + u)), t && a && o.push((u = "opacity" + (
				l = " " + (h = a) / 2 + "s " + (c = "cubic-bezier(0.23,1,0.32,1)")) + ",visibility" + l,
			e || (l = " " + h + "s " + c, u += b.transformSupported ? "," + nT + l : ",left" + l + ",top" +
				l), eT + ":" + u)), s && o.push("background-color:" + s), E(["width", "color", "radius"],
			function(t) {
				var e = "border-" + t,
					n = Bp(e),
					n = i.get(n);
				null != n && o.push(e + ":" + n + ("color" === t ? "" : "px"))
			}), o.push((r = [], t = (n = p).get("fontSize"), (a = n.getTextColor()) && r.push("color:" + a), r
			.push("font:" + n.getFont()), t && r.push("line-height:" + Math.round(3 * t / 2) + "px"), a = n
			.get("textShadowColor"), t = n.get("textShadowBlur") || 0, e = n.get("textShadowOffsetX") || 0,
			h = n.get("textShadowOffsetY") || 0, a && t && r.push("text-shadow:" + e + "px " + h + "px " +
				t + "px " + a), E(["decoration", "align"], function(t) {
				var e = n.get(t);
				e && r.push("text-" + t + ":" + e)
			}), r.join(";"))), null != d && o.push("padding:" + Fp(d).join("px ") + "px"), o.join(";") + ";"
	}

	function aT(t, e, n, i, r) {
		var o, a, s = e && e.painter;
		n ? (n = s && s.getViewportRoot()) && (o = t, a = document.body, ye(ge, n, i, r, !0)) && ye(o, a, ge[0], ge[
			1]) : (t[0] = i, t[1] = r, (n = s && s.getViewportRootOffset()) && (t[0] += n.offsetLeft, t[1] += n
			.offsetTop)), t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight()
	}
	lT.prototype.update = function(t) {
		var e = this._container,
			n = (n = "position", (i = (i = e).currentStyle || document.defaultView && document.defaultView
				.getComputedStyle(i)) ? n ? i[n] : i : null),
			i = e.style,
			e = ("absolute" !== i.position && "absolute" !== n && (i.position = "relative"), t.get(
				"alwaysShowContent"));
		e && this._moveIfResized(), this._alwaysShowContent = e, this.el.className = t.get("className") || ""
	}, lT.prototype.show = function(t, e) {
		clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
		var n = this.el,
			i = n.style,
			r = this._styleCoord;
		n.innerHTML ? i.cssText = iT + oT(t, !this._firstShow, this._longHide) + rT(r[0], r[1], !0) +
			"border-color:" + Xp(e) + ";" + (t.get("extraCssText") || "") + ";pointer-events:" + (this
				._enterable ? "auto" : "none") : i.display = "none", this._show = !0, this._firstShow = !1, this
			._longHide = !1
	}, lT.prototype.setContent = function(t, e, n, i, r) {
		var o, a, s, l, u, h = this.el;
		if (null != t) {
			var c = "";
			if (H(r) && "item" === n.get("trigger") && !$M(n) && (n = n, i = i, c = H(r = r) && "inside" !== r ?
					(o = n.get("backgroundColor"), n = n.get("borderWidth"), i = Xp(i), r = "left" === (r = r) ?
						"right" : "right" === r ? "left" : "top" === r ? "bottom" : "top", p = Math.max(1.5 *
							Math.round(n), 6), a = "", s = nT + ":", -1 < I(["left", "right"], r) ? (a +=
							"top:50%", s += "translateY(-50%) rotate(" + (u = "left" == r ? -225 : -45) + "deg)"
						) : (a += "left:50%", s += "translateX(-50%) rotate(" + (u = "top" == r ? 225 :
							45) + "deg)"), u = u * Math.PI / 180, u = (l = p + n) * Math.abs(Math.cos(u)) + l *
						Math.abs(Math.sin(u)), i = i + " solid " + n + "px;", '<div style="' + [
							"position:absolute;width:" + p + "px;height:" + p + "px;z-index:-1;", (a += ";" +
								r + ":-" + Math.round(100 * ((u - Math.SQRT2 * n) / 2 + Math.SQRT2 * n - (u -
									l) / 2)) / 100 + "px") + ";" + s + ";", "border-bottom:" + i,
							"border-right:" + i, "background-color:" + o + ";"
						].join("") + '"></div>') : ""), H(t)) h.innerHTML = t + c;
			else if (t) {
				h.innerHTML = "", V(t) || (t = [t]);
				for (var p, d = 0; d < t.length; d++) mt(t[d]) && t[d].parentNode !== h && h.appendChild(t[d]);
				c && h.childNodes.length && ((p = document.createElement("div")).innerHTML = c, h.appendChild(
					p))
			}
		} else h.innerHTML = ""
	}, lT.prototype.setEnterable = function(t) {
		this._enterable = t
	}, lT.prototype.getSize = function() {
		var t = this.el;
		return [t.offsetWidth, t.offsetHeight]
	}, lT.prototype.moveTo = function(t, e) {
		var n, i = this._styleCoord;
		aT(i, this._zr, this._appendToBody, t, e), null != i[0] && null != i[1] && (n = this.el.style, E(rT(i[
			0], i[1]), function(t) {
			n[t[0]] = t[1]
		}))
	}, lT.prototype._moveIfResized = function() {
		var t = this._styleCoord[2],
			e = this._styleCoord[3];
		this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight())
	}, lT.prototype.hide = function() {
		var t = this,
			e = this.el.style;
		e.visibility = "hidden", e.opacity = "0", b.transform3dSupported && (e.willChange = ""), this._show = !
			1, this._longHideTimeout = setTimeout(function() {
				return t._longHide = !0
			}, 500)
	}, lT.prototype.hideLater = function(t) {
		!this._show || this._inContent && this._enterable || this._alwaysShowContent || (t ? (this._hideDelay =
			t, this._show = !1, this._hideTimeout = setTimeout(pt(this.hide, this), t)) : this.hide())
	}, lT.prototype.isShow = function() {
		return this._show
	}, lT.prototype.dispose = function() {
		this.el.parentNode.removeChild(this.el)
	};
	var sT = lT;

	function lT(t, e, n) {
		if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1,
			this._firstShow = !0, this._longHide = !0, b.wxa) return null;
		var i = document.createElement("div"),
			r = (i.domBelongToZr = !0, this.el = i, this._zr = e.getZr()),
			n = this._appendToBody = n && n.appendToBody,
			o = (aT(this._styleCoord, r, n, e.getWidth() / 2, e.getHeight() / 2), (n ? document.body : t)
				.appendChild(i), this._container = t, this);
		i.onmouseenter = function() {
			o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0
		}, i.onmousemove = function(t) {
			var e;
			t = t || window.event, o._enterable || (e = r.handler, Ie(r.painter.getViewportRoot(), t, !0), e
				.dispatch("mousemove", t))
		}, i.onmouseleave = function() {
			o._inContent = !1, o._enterable && o._show && o.hideLater(o._hideDelay)
		}
	}
	hT.prototype.update = function(t) {
		t = t.get("alwaysShowContent");
		t && this._moveIfResized(), this._alwaysShowContent = t
	}, hT.prototype.show = function() {
		this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0
	}, hT.prototype.setContent = function(t, e, n, i, r) {
		var o = this,
			a = (L(t) && f(""), this.el && this._zr.remove(this.el), n.getModel("textStyle")),
			s = (this.el = new Ks({
				style: {
					rich: e.richTextStyles,
					text: t,
					lineHeight: 22,
					borderWidth: 1,
					borderColor: i,
					textShadowColor: a.get("textShadowColor"),
					fill: n.get(["textStyle", "color"]),
					padding: jg(n, "richText"),
					verticalAlign: "top",
					align: "left"
				},
				z: n.get("z")
			}), E(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX",
				"shadowOffsetY"
			], function(t) {
				o.el.style[t] = n.get(t)
			}), E(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(t) {
				o.el.style[t] = a.get(t) || 0
			}), this._zr.add(this.el), this);
		this.el.on("mouseover", function() {
			s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0
		}), this.el.on("mouseout", function() {
			s._enterable && s._show && s.hideLater(s._hideDelay), s._inContent = !1
		})
	}, hT.prototype.setEnterable = function(t) {
		this._enterable = t
	}, hT.prototype.getSize = function() {
		var t = this.el,
			e = this.el.getBoundingRect(),
			t = pT(t.style);
		return [e.width + t.left + t.right, e.height + t.top + t.bottom]
	}, hT.prototype.moveTo = function(t, e) {
		var n, i, r = this.el;
		r && (dT(i = this._styleCoord, this._zr, t, e), t = i[0], e = i[1], n = cT((i = r.style).borderWidth ||
			0), i = pT(i), r.x = t + n + i.left, r.y = e + n + i.top, r.markRedraw())
	}, hT.prototype._moveIfResized = function() {
		var t = this._styleCoord[2],
			e = this._styleCoord[3];
		this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight())
	}, hT.prototype.hide = function() {
		this.el && this.el.hide(), this._show = !1
	}, hT.prototype.hideLater = function(t) {
		!this._show || this._inContent && this._enterable || this._alwaysShowContent || (t ? (this._hideDelay =
			t, this._show = !1, this._hideTimeout = setTimeout(pt(this.hide, this), t)) : this.hide())
	}, hT.prototype.isShow = function() {
		return this._show
	}, hT.prototype.dispose = function() {
		this._zr.remove(this.el)
	};
	var uT = hT;

	function hT(t) {
		this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this
			._zr = t.getZr(), dT(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2)
	}

	function cT(t) {
		return Math.max(0, t)
	}

	function pT(t) {
		var e = cT(t.shadowBlur || 0),
			n = cT(t.shadowOffsetX || 0),
			t = cT(t.shadowOffsetY || 0);
		return {
			left: cT(e - n),
			right: cT(e + n),
			top: cT(e - t),
			bottom: cT(e + t)
		}
	}

	function dT(t, e, n, i) {
		t[0] = n, t[1] = i, t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight()
	}
	var fT, gT = new Xs({
			shape: {
				x: -1,
				y: -1,
				width: 2,
				height: 2
			}
		}),
		yT = (u(mT, fT = uy), mT.prototype.init = function(t, e) {
			var n;
			!b.node && e.getDom() && (t = t.getComponent("tooltip"), n = this._renderMode = "auto" === (n = t
					.get("renderMode")) ? b.domSupported ? "html" : "richText" : n || "html", this
				._tooltipContent = "richText" === n ? new uT(e) : new sT(e.getDom(), e, {
					appendToBody: t.get("appendToBody", !0)
				}))
		}, mT.prototype.render = function(t, e, n) {
			!b.node && n.getDom() && (this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this
				._api = n, (e = this._tooltipContent).update(t), e.setEnterable(t.get("enterable")), this
				._initGlobalListener(), this._keepShow(), "richText" !== this._renderMode && t.get(
					"transitionDuration") ? Ty(this, "_updatePosition", 50, "fixRate") : Cy(this,
					"_updatePosition"))
		}, mT.prototype._initGlobalListener = function() {
			var i = this._tooltipModel.get("triggerOn");
			LM("itemTooltip", this._api, pt(function(t, e, n) {
				"none" !== i && (0 <= i.indexOf(t) ? this._tryShow(e, n) : "leave" === t && this
					._hide(n))
			}, this))
		}, mT.prototype._keepShow = function() {
			var t, e = this._tooltipModel,
				n = this._ecModel,
				i = this._api,
				r = e.get("triggerOn");
			null != this._lastX && null != this._lastY && "none" !== r && "click" !== r && (t = this,
				clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(
					function() {
						i.isDisposed() || t.manuallyShowTip(e, n, i, {
							x: t._lastX,
							y: t._lastY,
							dataByCoordSys: t._lastDataByCoordSys
						})
					}))
		}, mT.prototype.manuallyShowTip = function(t, e, n, i) {
			var r, o, a, s;
			i.from !== this.uid && !b.node && n.getDom() && (r = _T(i, n), this._ticket = "", s = i
				.dataByCoordSys, (o = function(n, t, e) {
					var i = Zo(n).queryOptionMap,
						r = i.keys()[0];
					if (r && "series" !== r) {
						var o, t = $o(t, r, i.get(r), {
							useDefault: !1,
							enableAll: !1,
							enableNone: !1
						}).models[0];
						if (t) return e.getViewOfComponentModel(t).group.traverse(function(t) {
							var e = k(t).tooltipConfig;
							if (e && e.name === n.name) return o = t, !0
						}), o ? {
							componentMainType: r,
							componentIndex: t.componentIndex,
							el: o
						} : void 0
					}
				}(i, e, n)) ? ((a = o.el.getBoundingRect().clone()).applyTransform(o.el.transform), this
					._tryShow({
						offsetX: a.x + a.width / 2,
						offsetY: a.y + a.height / 2,
						target: o.el,
						position: i.position,
						positionDefault: "bottom"
					}, r)) : i.tooltip && null != i.x && null != i.y ? ((a = gT).x = i.x, a.y = i.y, a
					.update(), k(a).tooltipConfig = {
						name: null,
						option: i.tooltip
					}, this._tryShow({
						offsetX: i.x,
						offsetY: i.y,
						target: a
					}, r)) : s ? this._tryShow({
					offsetX: i.x,
					offsetY: i.y,
					position: i.position,
					dataByCoordSys: s,
					tooltipOption: i.tooltipOption
				}, r) : null != i.seriesIndex ? this._manuallyAxisShowTip(t, e, n, i) || (a = (o = FM(i, e))
					.point[0], s = o.point[1], null != a && null != s && this._tryShow({
						offsetX: a,
						offsetY: s,
						target: o.el,
						position: i.position,
						positionDefault: "bottom"
					}, r)) : null != i.x && null != i.y && (n.dispatchAction({
					type: "updateAxisPointer",
					x: i.x,
					y: i.y
				}), this._tryShow({
					offsetX: i.x,
					offsetY: i.y,
					position: i.position,
					target: n.getZr().findHover(i.x, i.y).target
				}, r)))
		}, mT.prototype.manuallyHideTip = function(t, e, n, i) {
			var r = this._tooltipContent;
			this._tooltipModel && r.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY =
				this._lastDataByCoordSys = null, i.from !== this.uid && this._hide(_T(i, n))
		}, mT.prototype._manuallyAxisShowTip = function(t, e, n, i) {
			var r = i.seriesIndex,
				o = i.dataIndex,
				a = e.getComponent("axisPointer").coordSysAxesInfo;
			if (null != r && null != o && null != a) {
				a = e.getSeriesByIndex(r);
				if (a && "axis" === vT([a.getData().getItemModel(o), a, (a.coordinateSystem || {}).model], this
						._tooltipModel).get("trigger")) return n.dispatchAction({
					type: "updateAxisPointer",
					seriesIndex: r,
					dataIndex: o,
					position: i.position
				}), !0
			}
		}, mT.prototype._tryShow = function(t, e) {
			var n, i, r, o = t.target;
			this._tooltipModel && (this._lastX = t.offsetX, this._lastY = t.offsetY, (n = t.dataByCoordSys) && n
				.length ? this._showAxisTooltip(n, t) : o ? (im(o, function(t) {
						return null != k(t).dataIndex ? (i = t, 1) : null != k(t).tooltipConfig && (r =
							t, 1)
					}, !(this._lastDataByCoordSys = null)), i ? this._showSeriesItemTooltip(t, i, e) : r ?
					this._showComponentItemTooltip(t, r, e) : this._hide(e)) : (this._lastDataByCoordSys =
					null, this._hide(e)))
		}, mT.prototype._showOrMove = function(t, e) {
			t = t.get("showDelay");
			e = pt(e, this), clearTimeout(this._showTimout), 0 < t ? this._showTimout = setTimeout(e, t) : e()
		}, mT.prototype._showAxisTooltip = function(t, e) {
			var u = this._ecModel,
				h = this._tooltipModel,
				n = [e.offsetX, e.offsetY],
				i = vT([e.tooltipOption], h),
				c = this._renderMode,
				p = [],
				d = Vg("section", {
					blocks: [],
					noHeader: !0
				}),
				f = [],
				g = new Zg,
				r = (E(t, function(t) {
					E(t.dataByAxis, function(r) {
						var o, a, s = u.getComponent(r.axisDim + "Axis", r.axisIndex),
							l = r.value;
						s && null != l && (o = _M(l, s.axis, u, r.seriesDataIndices, r
							.valueLabelOpt), a = Vg("section", {
							header: o,
							noHeader: !It(o),
							sortBlocks: !0,
							blocks: []
						}), d.blocks.push(a), E(r.seriesDataIndices, function(t) {
							var e, n = u.getSeriesByIndex(t.seriesIndex),
								t = t.dataIndexInside,
								i = n.getDataParams(t);
							i.dataIndex < 0 || (i.axisDim = r.axisDim, i.axisIndex =
								r.axisIndex, i.axisType = r.axisType, i.axisId =
								r.axisId, i.axisValue = j_(s.axis, {
									value: l
								}), i.axisValueLabel = o, i.marker = g
								.makeTooltipMarker("item", Xp(i.color), c), (e =
									(t = Wf(n.formatTooltip(t, !0, null))).frag
								) && (n = vT([n], h).get("valueFormatter"),
									a.blocks.push(n ? O({
										valueFormatter: n
									}, e) : e)), t.text && f.push(t.text), p
								.push(i))
						}))
					})
				}), d.blocks.reverse(), f.reverse(), e.position),
				e = i.get("order"),
				e = Xg(d, g, c, e, u.get("useUTC"), i.get("textStyle")),
				e = (e && f.unshift(e), "richText" === c ? "\n\n" : "<br/>"),
				o = f.join(e);
			this._showOrMove(i, function() {
				this._updateContentNotChangedOnAxis(t, p) ? this._updatePosition(i, r, n[0], n[1], this
					._tooltipContent, p) : this._showTooltipContent(i, o, p, Math.random() + "", n[
					0], n[1], r, null, g)
			})
		}, mT.prototype._showSeriesItemTooltip = function(t, e, n) {
			var i, r, o, a, s, l = this._ecModel,
				e = k(e),
				u = e.seriesIndex,
				h = l.getSeriesByIndex(u),
				c = e.dataModel || h,
				p = e.dataIndex,
				e = e.dataType,
				d = c.getData(e),
				f = this._renderMode,
				g = t.positionDefault,
				y = vT([d.getItemModel(p), c, h && (h.coordinateSystem || {}).model], this._tooltipModel, g ? {
					position: g
				} : null),
				h = y.get("trigger");
			null != h && "item" !== h || (i = c.getDataParams(p, e), r = new Zg, i.marker = r.makeTooltipMarker(
					"item", Xp(i.color), f), g = Wf(c.formatTooltip(p, !1, e)), h = y.get("order"), e = y
				.get("valueFormatter"), o = g.frag, a = o ? Xg(e ? O({
					valueFormatter: e
				}, o) : o, r, f, h, l.get("useUTC"), y.get("textStyle")) : g.text, s = "item_" + c.name +
				"_" + p, this._showOrMove(y, function() {
					this._showTooltipContent(y, a, i, s, t.offsetX, t.offsetY, t.position, t.target, r)
				}), n({
					type: "showTip",
					dataIndexInside: p,
					dataIndex: d.getRawIndex(p),
					seriesIndex: u,
					from: this.uid
				}))
		}, mT.prototype._showComponentItemTooltip = function(e, n, t) {
			var i = k(n),
				r = i.tooltipConfig.option || {},
				o = [r = H(r) ? {
					content: r,
					formatter: r
				} : r],
				i = this._ecModel.getComponent(i.componentMainType, i.componentIndex),
				i = (i && o.push(i), o.push({
					formatter: r.content
				}), e.positionDefault),
				a = vT(o, this._tooltipModel, i ? {
					position: i
				} : null),
				s = a.get("content"),
				l = Math.random() + "",
				u = new Zg;
			this._showOrMove(a, function() {
				var t = _(a.get("formatterParams") || {});
				this._showTooltipContent(a, s, t, l, e.offsetX, e.offsetY, e.position, n, u)
			}), t({
				type: "showTip",
				from: this.uid
			})
		}, mT.prototype._showTooltipContent = function(n, t, i, e, r, o, a, s, l) {
			var u, h, c, p, d;
			this._ticket = "", n.get("showContent") && n.get("show") && ((u = this._tooltipContent)
				.setEnterable(n.get("enterable")), h = n.get("formatter"), a = a || n.get("position"), t =
				t, c = this._getNearestPoint([r, o], i, n.get("trigger"), n.get("borderColor")).color, h &&
				(t = H(h) ? (p = n.ecModel.get("useUTC"), t = h, Wp(t = (d = V(i) ? i[0] : i) && d
					.axisType && 0 <= d.axisType.indexOf("time") ? wp(d.axisValue, t, p) : t, i, !0
				)) : S(h) ? (d = pt(function(t, e) {
					t === this._ticket && (u.setContent(e, l, n, c, a), this._updatePosition(n,
						a, r, o, u, i, s))
				}, this), this._ticket = e, h(i, e, d)) : h), u.setContent(t, l, n, c, a), u.show(n, c),
				this._updatePosition(n, a, r, o, u, i, s))
		}, mT.prototype._getNearestPoint = function(t, e, n, i) {
			return "axis" === n || V(e) ? {
				color: i || ("html" === this._renderMode ? "#fff" : "none")
			} : V(e) ? void 0 : {
				color: i || e.color || e.borderColor
			}
		}, mT.prototype._updatePosition = function(t, e, n, i, r, o, a) {
			var s, l, u, h, c = this._api.getWidth(),
				p = this._api.getHeight(),
				d = (e = e || t.get("position"), r.getSize()),
				f = t.get("align"),
				g = t.get("verticalAlign"),
				y = a && a.getBoundingRect().clone();
			a && y.applyTransform(a.transform), V(e = S(e) ? e([n, i], o, r.el, y, {
				viewSize: [c, p],
				contentSize: d.slice()
			}) : e) ? (n = fo(e[0], c), i = fo(e[1], p)) : L(e) ? ((o = e).width = d[0], o.height = d[1],
				n = (o = Qp(o, {
					width: c,
					height: p
				})).x, i = o.y, g = f = null) : i = (n = (s = H(e) && a ? function(t, e, n, i) {
				var r = n[0],
					o = n[1],
					a = Math.ceil(Math.SQRT2 * i) + 8,
					s = 0,
					l = 0,
					u = e.width,
					h = e.height;
				switch (t) {
					case "inside":
						s = e.x + u / 2 - r / 2, l = e.y + h / 2 - o / 2;
						break;
					case "top":
						s = e.x + u / 2 - r / 2, l = e.y - o - a;
						break;
					case "bottom":
						s = e.x + u / 2 - r / 2, l = e.y + h + a;
						break;
					case "left":
						s = e.x - r - a, l = e.y + h / 2 - o / 2;
						break;
					case "right":
						s = e.x + u + a, l = e.y + h / 2 - o / 2
				}
				return [s, l]
			}(e, y, d, t.get("borderWidth")) : (o = n, a = i, e = c, y = p, l = f ? null : 20, u =
				g ? null : 20, h = (h = r).getSize(), s = h[0], h = h[1], null != l && (e < o + s +
					l + 2 ? o -= s + l : o += l), null != u && (y < a + h + u ? a -= h + u : a +=
					u), [o, a]))[0], s[1]), f && (n -= xT(f) ? d[0] / 2 : "right" === f ? d[0] : 0), g && (
				i -=
				xT(g) ? d[1] / 2 : "bottom" === g ? d[1] : 0), $M(t) && (e = n, l = i, y = c, h = p, u = (
				u = r).getSize(), o = u[0], u = u[1], e = Math.min(e + o, y) - o, l = Math.min(l + u,
				h) - u, n = (s = [e = Math.max(e, 0), l = Math.max(l, 0)])[0], i = s[1]), r.moveTo(n, i)
		}, mT.prototype._updateContentNotChangedOnAxis = function(n, o) {
			var t = this._lastDataByCoordSys,
				a = this._cbParamsList,
				s = !!t && t.length === n.length;
			return s && E(t, function(t, e) {
				var t = t.dataByAxis || [],
					r = (n[e] || {}).dataByAxis || [];
				(s = s && t.length === r.length) && E(t, function(t, e) {
					var e = r[e] || {},
						n = t.seriesDataIndices || [],
						i = e.seriesDataIndices || [];
					(s = s && t.value === e.value && t.axisType === e.axisType && t.axisId === e
						.axisId && n.length === i.length) && E(n, function(t, e) {
						e = i[e];
						s = s && t.seriesIndex === e.seriesIndex && t.dataIndex === e
							.dataIndex
					}), a && E(t.seriesDataIndices, function(t) {
						var t = t.seriesIndex,
							e = o[t],
							t = a[t];
						e && t && t.data !== e.data && (s = !1)
					})
				})
			}), this._lastDataByCoordSys = n, this._cbParamsList = o, !!s
		}, mT.prototype._hide = function(t) {
			this._lastDataByCoordSys = null, t({
				type: "hideTip",
				from: this.uid
			})
		}, mT.prototype.dispose = function(t, e) {
			!b.node && e.getDom() && (Cy(this, "_updatePosition"), this._tooltipContent.dispose(), NM(
				"itemTooltip", e))
		}, mT.type = "tooltip", mT);

	function mT() {
		var t = null !== fT && fT.apply(this, arguments) || this;
		return t.type = mT.type, t
	}

	function vT(t, e, n) {
		for (var i = e.ecModel, r = n ? (r = new Qc(n, i, i), new Qc(e.option, r, i)) : e, o = t.length - 1; 0 <=
			o; o--) {
			var a = t[o];
			a && (a = H(a = a instanceof Qc ? a.get("tooltip", !0) : a) ? {
				formatter: a
			} : a) && (r = new Qc(a, r, i))
		}
		return r
	}

	function _T(t, e) {
		return t.dispatchAction || pt(e.dispatchAction, e)
	}

	function xT(t) {
		return "center" === t || "middle" === t
	}
	n1(function(t) {
		n1(qM), t.registerComponentModel(ZM), t.registerComponentView(yT), t.registerAction({
			type: "showTip",
			event: "showTip",
			update: "tooltip:manuallyShowTip"
		}, Vt), t.registerAction({
			type: "hideTip",
			event: "hideTip",
			update: "tooltip:manuallyHideTip"
		}, Vt)
	}), n1(Cx);
	var wT = {
			value: "eq",
			"<": "lt",
			"<=": "lte",
			">": "gt",
			">=": "gte",
			"=": "eq",
			"!=": "ne",
			"<>": "ne"
		},
		bT = (OT.prototype.evaluate = function(t) {
			var e = typeof t;
			return H(e) ? this._condVal.test(t) : !!G(e) && this._condVal.test(t + "")
		}, OT),
		ST = (LT.prototype.evaluate = function() {
			return this.value
		}, LT),
		MT = (PT.prototype.evaluate = function() {
			for (var t = this.children, e = 0; e < t.length; e++)
				if (!t[e].evaluate()) return !1;
			return !0
		}, PT),
		TT = (AT.prototype.evaluate = function() {
			for (var t = this.children, e = 0; e < t.length; e++)
				if (t[e].evaluate()) return !0;
			return !1
		}, AT),
		CT = (DT.prototype.evaluate = function() {
			return !this.child.evaluate()
		}, DT),
		IT = (kT.prototype.evaluate = function() {
			for (var t = !!this.valueParser, e = (0, this.getValue)(this.valueGetterParam), n = t ? this
					.valueParser(e) : null, i = 0; i < this.subCondList.length; i++)
				if (!this.subCondList[i].evaluate(t ? n : e)) return !1;
			return !0
		}, kT);

	function kT() {}

	function DT() {}

	function AT() {}

	function PT() {}

	function LT() {}

	function OT(t) {
		null == (this._condVal = H(t) ? new RegExp(t) : xt(t) ? t : null) && f("")
	}

	function RT(t, e) {
		var n;
		if (!0 === t || !1 === t) return (n = new ST).value = t, n; {
			if (ET(t) || f(""), t.and) return NT("and", t, e);
			if (t.or) return NT("or", t, e);
			if (t.not) n = e, ET(o = (o = t).not) || f(""), (l = new CT).child = RT(o, n), l.child || f("");
			else {
				for (var i = t, r = e, o = r.prepareGetValue(i), a = [], s = R(i), l = i.parser, u = l ? rg(l) :
						null, h = 0; h < s.length; h++) {
					var c, p = s[h];
					"parser" === p || r.valueGetterAttrMap.get(p) || (c = Ft(wT, p) ? wT[p] : p, p = i[p], p = u ?
						u(p) : p, (c = function(t, e) {
							return "eq" === t || "ne" === t ? new hg("eq" === t, e) : Ft(og, t) ? new ag(t,
								e) : null
						}(c, p) || "reg" === c && new bT(p)) || f(""), a.push(c))
				}
				a.length || f(""), (l = new IT).valueGetterParam = o, l.valueParser = u, l.getValue = r.getValue, l
					.subCondList = a
			}
			return l
		}
	}

	function NT(t, e, n) {
		e = e[t], V(e) || f(""), e.length || f(""), t = new("and" === t ? MT : TT);
		return t.children = F(e, function(t) {
			return RT(t, n)
		}), t.children.length || f(""), t
	}

	function ET(t) {
		return L(t) && !ut(t)
	}
	BT.prototype.evaluate = function() {
		return this._cond.evaluate()
	};
	var zT = BT;

	function BT(t, e) {
		this._cond = RT(t, e)
	}
	var FT = {
			type: "echarts:filter",
			transform: function(t) {
				for (var e, n, i = t.upstream, r = (t = t.config, n = {
						valueGetterAttrMap: z({
							dimension: !0
						}),
						prepareGetValue: function(t) {
							var e = t.dimension,
								t = (Ft(t, "dimension") || f(""), i.getDimensionInfo(e));
							return t || f(""), {
								dimIdx: t.index
							}
						},
						getValue: function(t) {
							return i.retrieveValueFromItem(e, t.dimIdx)
						}
					}, new zT(t, n)), o = [], a = 0, s = i.count(); a < s; a++) e = i.getRawDataItem(a), r
					.evaluate() && o.push(e);
				return {
					data: o
				}
			}
		},
		VT = {
			type: "echarts:sort",
			transform: function(t) {
				var a = t.upstream,
					t = t.config,
					t = Ro(t),
					s = (t.length || f(""), []),
					t = (E(t, function(t) {
						var e = t.dimension,
							n = t.order,
							i = t.parser,
							t = t.incomparable,
							e = (null == e && f(""), "asc" !== n && "desc" !== n && f(""), t &&
								"min" !== t && "max" !== t && f(""), "asc" !== n && "desc" !== n && f(
									""), a.getDimensionInfo(e)),
							r = (e || f(""), i ? rg(i) : null);
						i && !r && f(""), s.push({
							dimIdx: e.index,
							parser: r,
							comparator: new sg(n, t)
						})
					}), a.sourceFormat);
				t !== pd && t !== dd && f("");
				for (var e = [], n = 0, i = a.count(); n < i; n++) e.push(a.getRawDataItem(n));
				return e.sort(function(t, e) {
					for (var n = 0; n < s.length; n++) {
						var i = s[n],
							r = a.retrieveValueFromItem(t, i.dimIdx),
							o = a.retrieveValueFromItem(e, i.dimIdx),
							i = (i.parser && (r = i.parser(r), o = i.parser(o)), i.comparator.evaluate(
								r, o));
						if (0 !== i) return i
					}
					return 0
				}), {
					data: e
				}
			}
		};
	n1(function(t) {
		t.registerTransform(FT), t.registerTransform(VT)
	});
	var HT = Math.sin,
		GT = Math.cos,
		WT = Math.PI,
		UT = 2 * Math.PI,
		XT = 180 / WT,
		YT = (qT.prototype.reset = function(t) {
			this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, t || 4)
		}, qT.prototype.moveTo = function(t, e) {
			this._add("M", t, e)
		}, qT.prototype.lineTo = function(t, e) {
			this._add("L", t, e)
		}, qT.prototype.bezierCurveTo = function(t, e, n, i, r, o) {
			this._add("C", t, e, n, i, r, o)
		}, qT.prototype.quadraticCurveTo = function(t, e, n, i) {
			this._add("Q", t, e, n, i)
		}, qT.prototype.arc = function(t, e, n, i, r, o) {
			this.ellipse(t, e, n, n, 0, i, r, o)
		}, qT.prototype.ellipse = function(t, e, n, i, r, o, a, s) {
			var l, u = a - o,
				s = !s,
				h = Math.abs(u),
				c = Ti(h - UT) || (s ? UT <= u : UT <= -u),
				h = !!c || !Ti(h) && WT <= (0 < u ? u % UT : u % UT + UT) == !!s,
				u = t + n * GT(o),
				p = e + i * HT(o),
				r = (this._start && this._add("M", u, p), Math.round(r * XT));
			c ? (c = 1 / this._p, this._add("A", n, i, r, 1, +s, t + n * GT(o + (l = (s ? 1 : -1) * (UT - c))),
				e + i * HT(o + l)), .01 < c && this._add("A", n, i, r, 0, +s, u, p)) : (o = t + n * GT(a),
				l = e + i * HT(a), this._add("A", n, i, r, +h, +s, o, l))
		}, qT.prototype.rect = function(t, e, n, i) {
			this._add("M", t, e), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add(
				"Z")
		}, qT.prototype.closePath = function() {
			0 < this._d.length && this._add("Z")
		}, qT.prototype._add = function(t, e, n, i, r, o, a, s, l) {
			for (var u = [], h = this._p, c = 1; c < arguments.length; c++) {
				var p = arguments[c];
				if (isNaN(p)) return void(this._invalid = !0);
				u.push(Math.round(p * h) / h)
			}
			this._d.push(t + u.join(" ")), this._start = "Z" === t
		}, qT.prototype.generateStr = function() {
			this._str = this._invalid ? "" : this._d.join(""), this._d = []
		}, qT.prototype.getStr = function() {
			return this._str
		}, qT);

	function qT() {}
	var jT = "none",
		ZT = Math.round;
	var KT = ["lineCap", "miterLimit", "lineJoin"],
		$T = F(KT, function(t) {
			return "stroke-" + t.toLowerCase()
		});

	function QT(t, e, n, i) {
		var r = null == e.opacity ? 1 : e.opacity;
		if (n instanceof Es) t("opacity", r);
		else if (null != (o = (o = e).fill) && o !== jT ? (t("fill", (o = Mi(e.fill)).color), o = null != e
				.fillOpacity ? e.fillOpacity * o.opacity * r : o.opacity * r, (i || o < 1) && t("fill-opacity", o)
			) : t("fill", jT), null != (o = (o = e).stroke) && o !== jT) {
			var o = Mi(e.stroke),
				a = (t("stroke", o.color), e.strokeNoScale ? n.getLineScale() : 1),
				a = a ? (e.lineWidth || 0) / a : 0,
				o = null != e.strokeOpacity ? e.strokeOpacity * o.opacity * r : o.opacity * r,
				r = e.strokeFirst;
			!i && 1 == a || t("stroke-width", a), (i || r) && t("paint-order", r ? "stroke" : "fill"), (i || o <
				1) && t("stroke-opacity", o), e.lineDash ? (r = (a = bm(n))[0], o = a[1], r && (o = ZT(o || 0),
				t(
					"stroke-dasharray", r.join(",")), o || i) && t("stroke-dashoffset", o)) : i && t(
				"stroke-dasharray", jT);
			for (var s = 0; s < KT.length; s++) {
				var l = KT[s];
				(i || e[l] !== Cs[l]) && (l = e[l] || Cs[l]) && t($T[s], l)
			}
		} else i && t("stroke", jT)
	}
	var JT = "http://www.w3.org/2000/svg",
		tC = "http://www.w3.org/1999/xlink",
		eC = "http://www.w3.org/2000/xmlns/",
		nC = "http://www.w3.org/XML/1998/namespace";

	function iC(t) {
		return document.createElementNS(JT, t)
	}

	function rC(t, e, n, i, r) {
		return {
			tag: t,
			attrs: n || {},
			children: i,
			text: r,
			key: e
		}
	}

	function oC(t, e) {
		var o = (e = e || {}).newline ? "\n" : "";
		return function t(e) {
			var n = e.children,
				i = e.tag,
				r = e.attrs,
				e = e.text;
			return function(t, e) {
					var n = [];
					if (e)
						for (var i in e) {
							var r = e[i];
							!1 !== r && (!0 !== r && null != r && (i += '="' + r + '"'), n.push(i))
						}
					return "<" + t + " " + n.join(" ") + ">"
				}(i, r) + ("style" !== i ? xe(e) : e || "") + (n ? o + F(n, t).join(o) + o : "") + "</" + i +
				">"
		}(t)
	}

	function aC(t) {
		return {
			zrId: t,
			shadowCache: {},
			patternCache: {},
			gradientCache: {},
			clipPathCache: {},
			defs: {},
			cssNodes: {},
			cssAnims: {},
			cssClassIdx: 0,
			cssAnimIdx: 0,
			shadowIdx: 0,
			gradientIdx: 0,
			patternIdx: 0,
			clipPathIdx: 0
		}
	}

	function sC(t, e, n, i) {
		return rC("svg", "root", {
			width: t,
			height: e,
			xmlns: JT,
			"xmlns:xlink": tC,
			version: "1.1",
			baseProfile: "full",
			viewBox: !!i && "0 0 " + t + " " + e
		}, n)
	}
	var lC = {
			cubicIn: "0.32,0,0.67,0",
			cubicOut: "0.33,1,0.68,1",
			cubicInOut: "0.65,0,0.35,1",
			quadraticIn: "0.11,0,0.5,0",
			quadraticOut: "0.5,1,0.89,1",
			quadraticInOut: "0.45,0,0.55,1",
			quarticIn: "0.5,0,0.75,0",
			quarticOut: "0.25,1,0.5,1",
			quarticInOut: "0.76,0,0.24,1",
			quinticIn: "0.64,0,0.78,0",
			quinticOut: "0.22,1,0.36,1",
			quinticInOut: "0.83,0,0.17,1",
			sinusoidalIn: "0.12,0,0.39,0",
			sinusoidalOut: "0.61,1,0.88,1",
			sinusoidalInOut: "0.37,0,0.63,1",
			exponentialIn: "0.7,0,0.84,0",
			exponentialOut: "0.16,1,0.3,1",
			exponentialInOut: "0.87,0,0.13,1",
			circularIn: "0.55,0,1,0.45",
			circularOut: "0,0.55,0.45,1",
			circularInOut: "0.85,0,0.15,1"
		},
		uC = "transform-origin";
	var hC = {
		fill: "fill",
		opacity: "opacity",
		lineWidth: "stroke-width",
		lineDashOffset: "stroke-dashoffset"
	};

	function cC(t, e) {
		var n = e.zrId + "-ani-" + e.cssAnimIdx++;
		return e.cssAnims[n] = t, n
	}

	function pC(t) {
		return H(t) ? lC[t] ? "cubic-bezier(" + lC[t] + ")" : Zn(t) ? t : "" : ""
	}

	function dC(D, A, P, L) {
		var t = D.animators,
			e = t.length,
			n = [];
		if (D instanceof Ih) {
			if (r = function(t, e, u) {
					var h, c, t = t.shape.paths,
						p = {};
					if (E(t, function(t) {
							var e = aC(u.zrId),
								t = (e.animation = !0, dC(t, {}, e, !0), e.cssAnims),
								n = e.cssNodes,
								e = R(t),
								i = e.length;
							if (i) {
								var r, o, a = t[c = e[i - 1]];
								for (r in a) {
									var s = a[r];
									p[r] = p[r] || {
										d: ""
									}, p[r].d += s.d || ""
								}
								for (o in n) {
									var l = n[o].animation;
									0 <= l.indexOf(c) && (h = l)
								}
							}
						}), h) return e.d = !1, t = cC(p, u), h.replace(c, t)
				}(D, A, P)) n.push(r);
			else if (!e) return
		} else if (!e) return;
		for (var i, r, o, a = {}, s = 0; s < e; s++) {
			var l = t[s],
				u = [l.getMaxTime() / 1e3 + "s"],
				h = pC(l.getClip().easing),
				c = l.getDelay(),
				h = (u.push(h || "linear"), c && u.push(c / 1e3 + "s"), l.getLoop() && u.push("infinite"), u.join(
					" "));
			a[h] = a[h] || [h, []], a[h][1].push(l)
		}

		function p(t) {
			var e, n = t[1],
				i = n.length,
				r = {},
				o = {},
				a = {},
				f = "animation-timing-function";

			function s(t, e, n) {
				for (var i = t.getTracks(), r = t.getMaxTime(), o = 0; o < i.length; o++) {
					var a = i[o];
					if (a.needsAnimate()) {
						var s = a.keyframes,
							l = a.propName;
						if (l = n ? n(l) : l)
							for (var u = 0; u < s.length; u++) {
								var h = s[u],
									c = Math.round(h.time / r * 100) + "%",
									p = pC(h.easing),
									d = h.rawValue;
								(H(d) || G(d)) && (e[c] = e[c] || {}, e[c][l] = h.rawValue, p) && (e[c][f] = p)
							}
					}
				}
			}
			for (var l, u = 0; u < i; u++)(v = (m = n[u]).targetName) ? "shape" === v && s(m, o) : L || s(m, r);
			for (S in r) {
				var h = {},
					c = (Rr(h, D), O(h, r[S]), Ei(h)),
					p = r[S][f];
				a[S] = c ? {
					transform: c
				} : {}, c = a[S], l = void 0, l = (h = h).originX, h = h.originY, (l || h) && (c[uC] = l +
					"px " + h + "px"), p && (a[S][f] = p)
			}
			var d, g, y, m, v, _ = !0;
			for (S in o) {
				a[S] = a[S] || {};
				var x = !e,
					p = o[S][f],
					w = (e = x ? new cs : e).len(),
					b = (e.reset(), a[S].d = (g = o[S], y = e, b = void 0, b = O({}, (d = D).shape), O(b, g), d
						.buildPath(y, b), (g = new YT).reset(Ni(d)), y.rebuildPath(g, 1), g.generateStr(), g
						.getStr()), e.len());
				if (!x && w !== b) {
					_ = !1;
					break
				}
				p && (a[S][f] = p)
			}
			if (!_)
				for (var S in a) delete a[S].d;
			if (!L)
				for (u = 0; u < i; u++) "style" === (v = (m = n[u]).targetName) && s(m, a, function(t) {
					return hC[t]
				});
			for (var M, T = R(a), C = !0, u = 1; u < T.length; u++) {
				var I = T[u - 1],
					k = T[u];
				if (a[I][uC] !== a[k][uC]) {
					C = !1;
					break
				}
				M = a[I][uC]
			}
			if (C && M) {
				for (var S in a) a[S][uC] && delete a[S][uC];
				A[uC] = M
			}
			if (ct(T, function(t) {
					return 0 < R(a[t]).length
				}).length) return cC(a, P) + " " + t[0] + " both"
		}
		for (i in a)(r = p(a[i])) && n.push(r);
		n.length && (o = P.zrId + "-cls-" + P.cssClassIdx++, P.cssNodes["." + o] = {
			animation: n.join(",")
		}, A.class = o)
	}
	var fC = Math.round;

	function gC(t) {
		return t && H(t.src)
	}

	function yC(t) {
		return t && S(t.toDataURL)
	}

	function mC(i, r, o, a) {
		QT(function(t, e) {
			var n = "fill" === t || "stroke" === t;
			n && Oi(e) ? CC(r, i, t, a) : n && Ai(e) ? IC(o, i, t, a) : i[t] = e
		}, r, o, !1);
		var t = i,
			e = a;
		if (function(t) {
				return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY)
			}(f = (u = o).style)) {
			var n = function(t) {
					var e = t.style,
						t = t.getGlobalScale();
					return [e.shadowColor, (e.shadowBlur || 0).toFixed(2), (e.shadowOffsetX || 0).toFixed(2), (e
						.shadowOffsetY || 0).toFixed(2), t[0], t[1]].join(",")
				}(u),
				s = e.shadowCache,
				l = s[n];
			if (!l) {
				var u = u.getGlobalScale(),
					h = u[0],
					u = u[1];
				if (!h || !u) return;
				var c = f.shadowOffsetX || 0,
					p = f.shadowOffsetY || 0,
					d = f.shadowBlur,
					f = Mi(f.shadowColor),
					g = f.opacity,
					f = f.color,
					d = d / 2 / h + " " + d / 2 / u;
				l = e.zrId + "-s" + e.shadowIdx++, e.defs[l] = rC("filter", l, {
					id: l,
					x: "-100%",
					y: "-100%",
					width: "300%",
					height: "300%"
				}, [rC("feDropShadow", "", {
					dx: c / h,
					dy: p / u,
					stdDeviation: d,
					"flood-color": f,
					"flood-opacity": g
				})]), s[n] = l
			}
			t.filter = Ri(l)
		}
	}

	function vC(t) {
		return Ti(t[0] - 1) && Ti(t[1]) && Ti(t[2]) && Ti(t[3] - 1)
	}

	function _C(t, e, n) {
		var i;
		!e || Ti((i = e)[4]) && Ti(i[5]) && vC(e) || (i = n ? 10 : 1e4, t.transform = vC(e) ? "translate(" + fC(e[
				4] * i) / i + " " + fC(e[5] * i) / i + ")" : "matrix(" + Ci((n = e)[0]) + "," + Ci(n[1]) + "," +
			Ci(n[2]) + "," + Ci(n[3]) + "," + Ii(n[4]) + "," + Ii(n[5]) + ")")
	}

	function xC(t, e, n) {
		for (var i = t.points, r = [], o = 0; o < i.length; o++) r.push(fC(i[o][0] * n) / n), r.push(fC(i[o][1] *
			n) / n);
		e.points = r.join(" ")
	}

	function wC(t) {
		return !t.smooth
	}
	var bC, SC = {
		circle: [(bC = F(["cx", "cy", "r"], function(t) {
			return "string" == typeof t ? [t, t] : t
		}), function(t, e, n) {
			for (var i = 0; i < bC.length; i++) {
				var r = bC[i],
					o = t[r[0]];
				null != o && (e[r[1]] = fC(o * n) / n)
			}
		})],
		polyline: [xC, wC],
		polygon: [xC, wC]
	};

	function MC(t, e) {
		var n, i, r, o = t.style,
			a = t.shape,
			s = SC[t.type],
			l = {},
			u = e.animation,
			h = "path",
			c = t.style.strokePercent,
			p = e.compress && Ni(t) || 4;
		return !s || e.willUpdate || s[1] && !s[1](a) || u && function(t) {
			for (var e = t.animators, n = 0; n < e.length; n++)
				if ("shape" === e[n].targetName) return 1
		}(t) || c < 1 ? (u = !t.path || t.shapeChanged(), t.path || t.createPathProxy(), r = t.path, u && (r
				.beginPath(), t.buildPath(r, t.shape), t.pathUpdated()), u = r.getVersion(), i = (n = t)
			.__svgPathBuilder, n.__svgPathVersion === u && i && c === n.__svgPathStrokePercent || ((i = i || (n
					.__svgPathBuilder = new YT)).reset(p), r.rebuildPath(i, c), i.generateStr(), n
				.__svgPathVersion = u, n.__svgPathStrokePercent = c), l.d = i.getStr()) : (h = t.type, r = Math
			.pow(10, p), s[0](a, l, r)), _C(l, t.transform), mC(l, o, t, e), e.animation && dC(t, l, e), rC(h, t
			.id + "", l)
	}

	function TC(t, e) {
		{
			if (t instanceof Z) return MC(t, e);
			if (t instanceof Es) {
				var n, i = e,
					r = (n = t).style,
					o;
				if ((o = r.image) && !H(o) && (gC(o) ? o = o.src : yC(o) && (o = o.toDataURL())), o) return a = r
					.x || 0, s = r.y || 0, o = {
						href: o,
						width: r.width,
						height: r.height
					}, a && (o.x = a), s && (o.y = s), _C(o, n.transform), mC(o, r, n, i), i.animation && dC(n,
						o, i), rC("image", n.id + "", o)
			} else if (t instanceof Ps) {
				var a = t,
					s = e;
				if (r = a.style, null != (i = r.text) && (i += ""), i && !isNaN(r.x) && !isNaN(r.y)) {
					var n = r.font || K,
						o = r.x || 0,
						l = (t = r.y || 0, e = Hr(n), "top" === (l = r.textBaseline) ? t += e / 2 : "bottom" ===
							l && (t -= e / 2), t),
						e = {
							"dominant-baseline": "central",
							"text-anchor": ki[r.textAlign] || r.textAlign
						};
					if (il(r)) {
						var t = "",
							u = r.fontStyle,
							h = el(r.fontSize);
						if (!parseFloat(h)) return;
						var c = r.fontFamily || w,
							p = r.fontWeight;
						t += "font-size:" + h + ";font-family:" + c + ";", u && "normal" !== u && (t +=
								"font-style:" + u + ";"), p && "normal" !== p && (t += "font-weight:" + p + ";"), e
							.style = t
					} else e.style = "font: " + n;
					return i.match(/\s/) && (e["xml:space"] = "preserve"), o && (e.x = o), l && (e.y = l), _C(e, a
						.transform), mC(e, r, a, s), s.animation && dC(a, e, s), rC("text", a.id + "", e,
						void 0, i)
				}
			}
		}
	}

	function CC(t, e, n, i) {
		var r, t = t[n],
			o = {
				gradientUnits: t.global ? "userSpaceOnUse" : "objectBoundingBox"
			};
		if (Pi(t)) r = "linearGradient", o.x1 = t.x, o.y1 = t.y, o.x2 = t.x2, o.y2 = t.y2;
		else {
			if (!Li(t)) return;
			r = "radialGradient", o.cx = N(t.x, .5), o.cy = N(t.y, .5), o.r = N(t.r, .5)
		}
		for (var a = t.colorStops, s = [], l = 0, u = a.length; l < u; ++l) {
			var h = 100 * Ii(a[l].offset) + "%",
				c = Mi(a[l].color),
				p = c.color,
				c = c.opacity,
				h = {
					offset: h
				};
			h["stop-color"] = p, c < 1 && (h["stop-opacity"] = c), s.push(rC("stop", l + "", h))
		}
		var t = oC(rC(r, "", o, s)),
			d = i.gradientCache,
			f = d[t];
		f || (f = i.zrId + "-g" + i.gradientIdx++, d[t] = f, o.id = f, i.defs[f] = rC(r, f, o, s)), e[n] = Ri(f)
	}

	function IC(t, e, n, i) {
		var r, o, a, s, l, u, h, c, p = t.style[n],
			d = t.getBoundingRect(),
			f = {},
			g = p.repeat,
			y = "no-repeat" === g,
			m = "repeat-x" === g,
			v = "repeat-y" === g;
		Di(p) ? (o = p.imageWidth, a = p.imageHeight, g = void 0, H(h = p.image) ? g = h : gC(h) ? g = h.src : yC(
				h) && (g = h.toDataURL()), "undefined" == typeof Image ? (Ct(o, h =
				"Image width/height must been given explictly in svg-ssr renderer."), Ct(a, h)) : null != o &&
			null != a || (s = function(t, e) {
				var n, i;
				t && (n = t.elm, i = o || e.width, e = a || e.height, "pattern" === t.tag && (m ? (e = 1,
						i /= d.width) : v && (i = 1, e /= d.height)), t.attrs.width = i, t.attrs
					.height = e, n) && (n.setAttribute("width", i), n.setAttribute("height", e))
			}, (h = ga(g, null, t, function(t) {
				y || s(u, t), s(r, t)
			})) && h.width && h.height && (o = o || h.width, a = a || h.height)), r = rC("image", "img", {
				href: g,
				width: o,
				height: a
			}), f.width = o, f.height = a) : p.svgElement && (r = _(p.svgElement), f.width = p.svgWidth, f
			.height = p.svgHeight), r && (y ? c = l = 1 : m ? (l = 1, c = f.width / d.width) : v ? (c = 1, l = f
				.height / d.height) : f.patternUnits = "userSpaceOnUse", null == c || isNaN(c) || (f.width = c),
			null == l || isNaN(l) || (f.height = l), (t = Ei(p)) && (f.patternTransform = t), h = oC(u = rC(
				"pattern", "", f, [r])), (c = (g = i.patternCache)[h]) || (c = i.zrId + "-p" + i.patternIdx++,
				g[h] = c, f.id = c, u = i.defs[c] = rC("pattern", c, f, [r])), e[n] = Ri(c))
	}

	function kC(t) {
		return document.createTextNode(t)
	}

	function DC(t, e, n) {
		t.insertBefore(e, n)
	}

	function AC(t, e) {
		t.removeChild(e)
	}

	function PC(t, e) {
		t.appendChild(e)
	}

	function LC(t) {
		return t.parentNode
	}

	function OC(t) {
		return t.nextSibling
	}

	function RC(t, e) {
		t.textContent = e
	}
	var NC = 58,
		EC = 120,
		zC = rC("", "");

	function BC(t) {
		return void 0 === t
	}

	function FC(t) {
		return void 0 !== t
	}

	function VC(t, e) {
		var n = t.key === e.key;
		return t.tag === e.tag && n
	}

	function HC(t) {
		var e, n = t.children,
			i = t.tag;
		if (FC(i)) {
			var r = t.elm = iC(i);
			if (UC(zC, t), V(n))
				for (e = 0; e < n.length; ++e) {
					var o = n[e];
					null != o && PC(r, HC(o))
				} else FC(t.text) && !L(t.text) && PC(r, kC(t.text))
		} else t.elm = kC(t.text);
		return t.elm
	}

	function GC(t, e, n, i, r) {
		for (; i <= r; ++i) {
			var o = n[i];
			null != o && DC(t, HC(o), e)
		}
	}

	function WC(t, e, n, i) {
		for (; n <= i; ++n) {
			var r = e[n];
			null != r && (FC(r.tag) ? AC(LC(r.elm), r.elm) : AC(t, r.elm))
		}
	}

	function UC(t, e) {
		var n, i = e.elm,
			r = t && t.attrs || {},
			o = e.attrs || {};
		if (r !== o) {
			for (n in o) {
				var a = o[n];
				r[n] !== a && (!0 === a ? i.setAttribute(n, "") : !1 === a ? i.removeAttribute(n) : n.charCodeAt(
						0) !== EC ? i.setAttribute(n, a) : "xmlns:xlink" === n || "xmlns" === n ? i
					.setAttributeNS(
						eC, n, a) : n.charCodeAt(3) === NC ? i.setAttributeNS(nC, n, a) : n.charCodeAt(5) ===
					NC ? i.setAttributeNS(tC, n, a) : i.setAttribute(n, a))
			}
			for (n in r) n in o || i.removeAttribute(n)
		}
	}

	function XC(t, e, n) {
		for (var i, r, o, a = 0, s = 0, l = e.length - 1, u = e[0], h = e[l], c = n.length - 1, p = n[0], d = n[
				c]; a <= l && s <= c;) null == u ? u = e[++a] : null == h ? h = e[--l] : null == p ? p = n[++s] :
			null == d ? d = n[--c] : VC(u, p) ? (YC(u, p), u = e[++a], p = n[++s]) : VC(h, d) ? (YC(h, d), h = e[--
				l], d = n[--c]) : VC(u, d) ? (YC(u, d), DC(t, u.elm, OC(h.elm)), u = e[++a], d = n[--c]) : p = (VC(
				h, p) ? (YC(h, p), DC(t, h.elm, u.elm), h = e[--l]) : (BC(i) && (i = function(t, e, n) {
				for (var i = {}, r = e; r <= n; ++r) {
					var o = t[r].key;
					void 0 !== o && (i[o] = r)
				}
				return i
			}(e, a, l)), BC(r = i[p.key]) || (o = e[r]).tag !== p.tag ? DC(t, HC(p), u.elm) : (YC(o, p), e[
				r] = void 0, DC(t, o.elm, u.elm))), n[++s]);
		(a <= l || s <= c) && (l < a ? GC(t, null == n[c + 1] ? null : n[c + 1].elm, n, s, c) : WC(t, e, a, l))
	}

	function YC(t, e) {
		var n = e.elm = t.elm,
			i = t.children,
			r = e.children;
		t !== e && (UC(t, e), BC(e.text) ? FC(i) && FC(r) ? i !== r && XC(n, i, r) : FC(r) ? (FC(t.text) && RC(n,
			""), GC(n, null, r, 0, r.length - 1)) : FC(i) ? WC(n, i, 0, i.length - 1) : FC(t.text) && RC(n,
			"") : t.text !== e.text && (FC(i) && WC(n, i, 0, i.length - 1), RC(n, e.text)))
	}
	var qC = 0;

	function jC(t, e, n) {
		var i;
		this.type = "svg", this.refreshHover = ZC(), this.configLayer = ZC(), this.storage = e, this._opts = n =
			O({}, n), this.root = t, this._id = "zr" + qC++, this._oldVNode = sC(n.width, n.height), t && !n.ssr &&
			((e = this._viewport = document.createElement("div")).style.cssText =
				"position:relative;overflow:hidden", i = this._svgDom = this._oldVNode.elm = iC("svg"), UC(null,
					this._oldVNode), e.appendChild(i), t.appendChild(e)), this.resize(n.width, n.height)
	}

	function ZC() {
		return function() {}
	}
	jC.prototype.getType = function() {
			return this.type
		}, jC.prototype.getViewportRoot = function() {
			return this._viewport
		}, jC.prototype.getViewportRootOffset = function() {
			var t = this.getViewportRoot();
			if (t) return {
				offsetLeft: t.offsetLeft || 0,
				offsetTop: t.offsetTop || 0
			}
		}, jC.prototype.getSvgDom = function() {
			return this._svgDom
		}, jC.prototype.refresh = function() {
			var t, e, n, i, r;
			this.root && ((t = this.renderToVNode({
				willUpdate: !0
			})).attrs.style = "position:absolute;left:0;top:0;user-select:none", VC(e = this._oldVNode, n =
				t) ? YC(e, n) : (r = LC(i = e.elm), HC(n), null !== r && (DC(r, n.elm, OC(i)), WC(r, [e], 0,
				0))), this._oldVNode = t)
		}, jC.prototype.renderOneToVNode = function(t) {
			return TC(t, aC(this._id))
		}, jC.prototype.renderToVNode = function(t) {
			t = t || {};
			var n, r, o, a, s, e = this.storage.getDisplayList(!0),
				i = this._width,
				l = this._height,
				u = aC(this._id),
				h = (u.animation = t.animation, u.willUpdate = t.willUpdate, u.compress = t.compress, []),
				c = this._bgVNode = function(t, e, n, i) {
					var r;
					n && "none" !== n && (r = rC("rect", "bg", {
						width: t,
						height: e,
						x: "0",
						y: "0",
						id: "0"
					}), Oi(n) ? CC({
						fill: n
					}, r.attrs, "fill", i) : Ai(n) ? IC({
						style: {
							fill: n
						},
						dirty: Vt,
						getBoundingRect: function() {
							return {
								width: t,
								height: e
							}
						}
					}, r.attrs, "fill", i) : (i = Mi(n), n = i.color, i = i.opacity, r.attrs.fill = n, i <
						1 && (r.attrs["fill-opacity"] = i)));
					return r
				}(i, l, this._backgroundColor, u),
				c = (c && h.push(c), t.compress ? null : this._mainVNode = rC("g", "main", {}, [])),
				e = (this._paintList(e, u, c ? c.children : h), c && h.push(c), F(R(u.defs), function(t) {
					return u.defs[t]
				}));
			return e.length && h.push(rC("defs", "defs", {}, e)), t.animation && (n = u.cssNodes, r = u.cssAnims,
				o = (c = (c = {
					newline: !0
				}) || {}).newline ? "\n" : "", a = " {" + o, s = o + "}", c = F(R(n), function(e) {
					return e + a + F(R(n[e]), function(t) {
						return t + ":" + n[e][t] + ";"
					}).join(o) + s
				}).join(o), e = F(R(r), function(i) {
					return "@keyframes " + i + a + F(R(r[i]), function(n) {
						return n + a + F(R(r[i][n]), function(t) {
							var e = r[i][n][t];
							return t + ":" + (e = "d" === t ? 'path("' + e + '")' : e) + ";"
						}).join(o) + s
					}).join(o) + s
				}).join(o), c = c || e ? ["<![CDATA[", c, e, "]]>"].join(o) : "") && (e = rC("style", "stl", {},
				[], c), h.push(e)), sC(i, l, h, t.useViewBox)
		}, jC.prototype.renderToString = function(t) {
			return oC(this.renderToVNode({
				animation: N((t = t || {}).cssAnimation, !0),
				willUpdate: !1,
				compress: !0,
				useViewBox: N(t.useViewBox, !0)
			}), {
				newline: !0
			})
		}, jC.prototype.setBackgroundColor = function(t) {
			this._backgroundColor = t
		}, jC.prototype.getSvgRoot = function() {
			return this._mainVNode && this._mainVNode.elm
		}, jC.prototype._paintList = function(t, e, n) {
			for (var i, r, o, a, s, l, u, h = t.length, c = [], p = 0, d = 0, f = 0; f < h; f++) {
				var g = t[f];
				if (!g.invisible) {
					for (var y = g.__clipPaths, m = y && y.length || 0, v = M && M.length || 0, _ = void 0, _ = Math
							.max(m - 1, v - 1); 0 <= _ && (!y || !M || y[_] !== M[_]); _--);
					for (var x = v - 1; _ < x; x--) i = c[--p - 1];
					for (var w = _ + 1; w < m; w++) {
						var b = {},
							S = (r = y[w], o = b, u = S = l = s = void 0, l = (a = e).clipPathCache, S = a.defs, (
								u = l[r.id]) || (s = {
								id: u = a.zrId + "-c" + a.clipPathIdx++
							}, S[l[r.id] = u] = rC("clipPath", u, s, [MC(r, a)])), o["clip-path"] = Ri(u), rC(
								"g", "clip-g-" + d++, b, []));
						(i ? i.children : n).push(S), i = c[p++] = S
					}
					var M = y,
						v = TC(g, e);
					v && (i ? i.children : n).push(v)
				}
			}
		}, jC.prototype.resize = function(t, e) {
			var n = this._opts,
				i = this.root,
				r = this._viewport;
			null != t && (n.width = t), null != e && (n.height = e), i && r && (r.style.display = "none", t = wm(i,
				0, n), e = wm(i, 1, n), r.style.display = ""), this._width === t && this._height === e || (this
				._width = t, this._height = e, r && ((i = r.style).width = t + "px", i.height = e + "px"), Ai(
					this._backgroundColor) ? this.refresh() : ((n = this._svgDom) && (n.setAttribute("width",
					t), n.setAttribute("height", e)), (r = this._bgVNode && this._bgVNode.elm) && (r
					.setAttribute("width", t), r.setAttribute("height", e))))
		}, jC.prototype.getWidth = function() {
			return this._width
		}, jC.prototype.getHeight = function() {
			return this._height
		}, jC.prototype.dispose = function() {
			this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode =
				this._bgVNode = this._mainVNode = null
		}, jC.prototype.clear = function() {
			this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null
		}, jC.prototype.toDataURL = function(t) {
			var e = this.renderToString(),
				n = "data:image/svg+xml;";
			return t ? (e = zi(e)) && n + "base64," + e : n + "charset=UTF-8," + encodeURIComponent(e)
		}, uo("svg", jC), t.Axis = Zc, t.ChartView = fy, t.ComponentModel = g, t.ComponentView = uy, t.List = Ev, t
		.Model = Qc, t.PRIORITY = um, t.SeriesModel = ey, t.color = bi, t.connect = function(e) {
			var t;
			return V(e) && (t = e, e = null, E(t, function(t) {
				null != t.group && (e = t.group)
			}), e = e || "g_" + W0++, E(t, function(t) {
				t.group = e
			})), H0[e] = !0, e
		}, t.dataTool = {}, t.dependencies = {
			zrender: "5.4.4"
		}, t.disConnect = lm, t.disconnect = X0, t.dispose = function(t) {
			H(t) ? t = V0[t] : t instanceof C0 || (t = Y0(t)), t instanceof C0 && !t.isDisposed() && t.dispose()
		}, t.env = b, t.extendChartView = function(t) {
			return t = fy.extend(t), fy.registerClass(t), t
		}, t.extendComponentModel = function(t) {
			return t = g.extend(t), g.registerClass(t), t
		}, t.extendComponentView = function(t) {
			return t = uy.extend(t), uy.registerClass(t), t
		}, t.extendSeriesModel = function(t) {
			return t = ey.extend(t), ey.registerClass(t), t
		}, t.format = qc, t.getCoordinateSystemDimensions = function(t) {
			if (t = Gd.get(t)) return t.getDimensionsInfo ? t.getDimensionsInfo() : t.dimensions.slice()
		}, t.getInstanceByDom = Y0, t.getInstanceById = function(t) {
			return V0[t]
		}, t.getMap = function(t) {
			var e = Zm.getMap;
			return e && e(t)
		}, t.graphic = gp, t.helper = hm, t.init = function(t, e, n) {
			var i = !(n && n.ssr);
			if (i) {
				var r = Y0(t);
				if (r) return r
			}
			return (r = new C0(t, e, n)).id = "ec_" + G0++, V0[r.id] = r, i && Qo(t, U0, r.id), _0(r), jm.trigger(
				"afterinit", r), r
		}, t.innerDrawElementOnCanvas = Hm, t.matrix = He, t.number = pa, t.parseGeoJSON = _1, t.parseGeoJson = _1,
		t.registerAction = J0, t.registerCoordinateSystem = tv, t.registerLayout = ev, t.registerLoading = ov, t
		.registerLocale = up, t.registerMap = av, t.registerPostInit = K0, t.registerPostUpdate = $0, t
		.registerPreprocessor = j0, t.registerProcessor = Z0, t.registerTheme = q0, t.registerTransform = sv, t
		.registerUpdateLifecycle = Q0, t.registerVisual = nv, t.setCanvasCreator = function(t) {
			D({
				createCanvas: t
			})
		}, t.setPlatformAPI = D, t.throttle = My, t.time = fc, t.use = n1, t.util = Wc, t.vector = ae, t.version =
		"5.4.3", t.zrUtil = Gt, t.zrender = ho
});